/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/spine_runtime/SkeletonBinary3.5.js":
/*!************************************************!*\
  !*** ./src/spine_runtime/SkeletonBinary3.5.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBinary": () => (/* binding */ SkeletonBinary)
/* harmony export */ });
function SkeletonBinary() {}

SkeletonBinary.prototype = {
  data: null,
  scale: 0x1,
  json: {},
  nextNum: 0x0,
  chars: null,
  readByte: function () {
    return this.nextNum < this.data.length ? this.data[this.nextNum++] : null;
  },
  readBoolean: function () {
    return this.readByte() != 0x0;
  },
  readShort: function () {
    return (this.readByte() << 0x8) | this.readByte();
  },
  readInt: function (optimizePositive) {
    if (typeof optimizePositive === "undefined") {
      return (
        (this.readByte() << 0x18) |
        (this.readByte() << 0x10) |
        (this.readByte() << 0x8) |
        this.readByte()
      );
    }
    let b = this.readByte();
    let result = b & 0x7f;
    if ((b & 0x80) != 0x0) {
      b = this.readByte();
      result |= (b & 0x7f) << 0x7;
      if ((b & 0x80) != 0x0) {
        b = this.readByte();
        result |= (b & 0x7f) << 0xe;
        if ((b & 0x80) != 0x0) {
          b = this.readByte();
          result |= (b & 0x7f) << 0x15;
          if ((b & 0x80) != 0x0) {
            b = this.readByte();
            result |= (b & 0x7f) << 0x1c;
          }
        }
      }
    }
    return optimizePositive ? result : (result >> 0x1) ^ -(result & 0x1);
  },
  bytes2Float32: function (bytes) {
    let sign = bytes & 0x80000000 ? -0x1 : 0x1;
    let exponent = ((bytes >> 0x17) & 0xff) - 0x7f;
    let significand = bytes & ~(-0x1 << 0x17);
    if (exponent == 0x80)
      return sign * (significand ? Number.NaN : Number.POSITIVE_INFINITY);
    if (exponent == -0x7f) {
      if (significand == 0x0) return sign * 0x0;
      exponent = -0x7e;
      significand /= 0x1 << 0x16;
    } else significand = (significand | (0x1 << 0x17)) / (0x1 << 0x17);
    return sign * significand * Math.pow(0x2, exponent);
  },
  readFloat: function () {
    return this.bytes2Float32(
      (this.readByte() << 0x18) +
        (this.readByte() << 0x10) +
        (this.readByte() << 0x8) +
        (this.readByte() << 0x0)
    );
  },
  readVertices: function (vertexCount) {
    let verticesLength = vertexCount << 0x1;
    if (!this.readBoolean()) {
      return this.readFloatArray(verticesLength, this.scale);
    }
    let bonesArray = new Array();
    for (let i = 0x0; i < vertexCount; i++) {
      let dataLength = this.readInt(!![]);
      bonesArray.push(dataLength);
      for (let j = 0x0; j < dataLength; j++) {
        bonesArray.push(this.readInt(!![]));
        bonesArray.push(this.readFloat() * this.scale);
        bonesArray.push(this.readFloat() * this.scale);
        bonesArray.push(this.readFloat());
      }
    }
    return bonesArray;
  },
  readFloatArray: function (length, scale) {
    let array = new Array(length);
    if (scale == 0x1) {
      for (let i = 0x0; i < length; i++) {
        array[i] = this.readFloat();
      }
    } else {
      for (let i = 0x0; i < length; i++) {
        array[i] = this.readFloat() * scale;
      }
    }
    return array;
  },
  readShortArray: function () {
    let n = this.readInt(!![]);
    let array = new Array(n);
    for (let i = 0x0; i < n; i++) {
      array[i] = this.readShort();
    }
    return array;
  },
  readIntArray: function () {
    let n = this.readInt(!![]);
    let array = new Array(n);
    for (let i = 0x0; i < n; i++) array[i] = this.readInt(!![]);
    return array;
  },
  readHex: function () {
    let hex = this.readByte().toString(0x10);
    return hex.length == 0x2 ? hex : "0" + hex;
  },
  readColor: function () {
    return this.readHex() + this.readHex() + this.readHex() + this.readHex();
  },
  readString: function () {
    let charCount = this.readInt(this, !![]);
    switch (charCount) {
      case 0x0:
        return null;
      case 0x1:
        return "";
    }
    charCount--;
    this.chars = "";
    let charIndex = 0x0;
    for (let i = 0x0; i < charCount; ) {
      charIndex = this.readByte();
      switch (charIndex >> 0x4) {
        case 0xc:
        case 0xd:
          this.chars += String.fromCharCode(
            ((charIndex & 0x1f) << 0x6) | (this.readByte() & 0x3f)
          );
          i += 0x2;
          break;
        case 0xe:
          this.chars += String.fromCharCode(
            ((charIndex & 0xf) << 0xc) |
              ((this.readByte() & 0x3f) << 0x6) |
              (this.readByte() & 0x3f)
          );
          i += 0x3;
          break;
        default:
          this.chars += String.fromCharCode(charIndex);
          i++;
      }
    }
    return this.chars;
  },
  initJson: function () {
    this.json.skeleton = {};
    let skeleton = this.json.skeleton;
    skeleton.hash = this.readString();
    if (skeleton.hash.length == 0x0) skeleton.hash = null;
    skeleton.spine = this.readString();
    if (skeleton.spine.length == 0x0) skeleton.spine = null;
    skeleton.width = this.readFloat();
    skeleton.height = this.readFloat();
    let nonessential = this.readBoolean();
    if (nonessential) {
      skeleton.fps = this.readFloat();
      skeleton.images = this.readString();
      if (skeleton.images.length == 0x0) skeleton.images = null;
    }
    this.json.bones = new Array(this.readInt(!![]));
    let bones = this.json.bones;
    for (let i = 0x0; i < bones.length; i++) {
      let boneData = {};
      boneData.name = this.readString();
      boneData.parent = null;
      if (i != 0x0) {
        const nonessential = this.readInt(!![]);
        boneData.parent = bones[nonessential].name;
      }
      boneData.rotation = this.readFloat();
      boneData["x"] = this.readFloat() * this.scale;
      boneData["y"] = this.readFloat() * this.scale;
      boneData.scaleX = this.readFloat();
      boneData.scaleY = this.readFloat();
      boneData.shearX = this.readFloat();
      boneData.shearY = this.readFloat();
      boneData.length = this.readFloat() * this.scale;
      boneData.transform = TransformMode[this.readInt(!![])];
      if (nonessential) {
        boneData.color = this.readColor();
      }
      bones[i] = boneData;
    }
    this.json.slots = new Array(this.readInt(!![]));
    let slots = this.json.slots;
    for (let i = 0x0; i < slots.length; i++) {
      let slotData = {};
      slotData.name = this.readString();
      const boneData = this.json.bones[this.readInt(!![])];
      slotData.bone = boneData.name;
      slotData.color = this.readColor();
      slotData.attachment = this.readString();
      slotData.blend = BlendMode[this.readInt(!![])];
      slots[i] = slotData;
    }
    this.json["ik"] = new Array(this.readInt(!![]));
    let ik = this.json["ik"];
    for (let i = 0x0; i < ik.length; i++) {
      let ikConstraints = {};
      ikConstraints.name = this.readString();
      ikConstraints.order = this.readInt(!![]);
      ikConstraints.bones = new Array(this.readInt(!![]));
      for (let j = 0x0; j < ikConstraints.bones.length; j++) {
        ikConstraints.bones[j] = this.json.bones[this.readInt(!![])].name;
      }
      ikConstraints.target = this.json.bones[this.readInt(!![])].name;
      ikConstraints.mix = this.readFloat();
      ikConstraints.bendPositive = this.readByte() != 0xff;
      ik[i] = ikConstraints;
    }
    this.json.transform = new Array(this.readInt(!![]));
    let transform = this.json.transform;
    for (let i = 0x0; i < transform.length; i++) {
      let transformData = {};
      transformData.name = this.readString();
      transformData.order = this.readInt(!![]);
      const bones = new Array(this.readInt(!![]));
      for (let j = 0x0, len = bones.length; j < len; j++) {
        bones[j] = this.json.bones[this.readInt(!![])].name;
      }
      transformData.bones = bones;
      transformData.target = this.json.bones[this.readInt(!![])].name;
      transformData.rotation = this.readFloat();
      transformData["x"] = this.readFloat() * this.scale;
      transformData["y"] = this.readFloat() * this.scale;
      transformData.scaleX = this.readFloat();
      transformData.scaleY = this.readFloat();
      transformData.shearY = this.readFloat();
      transformData.rotateMix = this.readFloat();
      transformData.translateMix = this.readFloat();
      transformData.scaleMix = this.readFloat();
      transformData.shearMix = this.readFloat();
      transform[i] = transformData;
    }
    this.json.path = new Array(this.readInt(!![]));
    let path = this.json.path;
    for (let i = 0x0; i < path.length; i++) {
      let pathData = {};
      pathData.name = this.readString();
      pathData.order = this.readInt(!![]);
      pathData.bones = new Array(this.readInt(!![]));
      for (let j = 0x0, len = pathData.bones.length; j < len; j++) {
        pathData.bones[j] = this.json.bones[this.readInt(!![])].name;
      }
      pathData.target = this.json.slots[this.readInt(!![])].name;
      pathData.positionMode = PositionMode[this.readInt(!![])];
      pathData.spacingMode = SpacingMode[this.readInt(!![])];
      pathData.rotateMode = RotateMode[this.readInt(!![])];
      pathData.rotation = this.readFloat();
      pathData.position = this.readFloat();
      if (pathData.positionMode == "fixed") {
        pathData.position *= this.scale;
      }
      pathData.spacing = this.readFloat();
      if (pathData.spacingMode == "length" || pathData.spacingMode == "fixed") {
        pathData.spacing *= this.scale;
      }
      pathData.rotateMix = this.readFloat();
      pathData.translateMix = this.readFloat();
      path[i] = pathData;
    }
    this.json.skins = {};
    this.json.skinsName = new Array();
    let skins = this.json.skins;
    let skinData = this.readSkin("default", nonessential);
    if (skinData != null) {
      skins.default = skinData;
      this.json.skinsName.push("default");
    }
    for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
      let skinName = this.readString();
      let skin = this.readSkin(skinName, nonessential);
      skins[skinName] = skin;
      this.json.skinsName.push(skinName);
    }
    this.json.events = [];
    this.json.eventsName = [];
    let events = this.json.events;
    for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
      let eventName = this.readString();
      let event = {};
      event.int = this.readInt(![]);
      event.float = this.readFloat();
      event.string = this.readString();
      events[eventName] = event;
      this.json.eventsName[i] = eventName;
    }
    this.json.animations = {};
    let animations = this.json.animations;
    for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
      let animationName = this.readString();
      let animation = this.readAnimation(animationName);
      animations[animationName] = animation;
    }
  },
  readSkin(slotIndex, nonessential) {
    let slotCount = this.readInt(!![]);
    if (slotCount == 0x0) return null;
    let skin = {};
    for (let i = 0x0; i < slotCount; i++) {
      const slotIndex = this.readInt(!![]);
      const slot = {};
      for (let j = 0x0, n = this.readInt(!![]); j < n; j++) {
        let name = this.readString();
        let attachment = this.readAttachment(name, nonessential);
        if (attachment != null) {
          slot[name] = attachment;
        }
      }
      skin[this.json.slots[slotIndex].name] = slot;
    }
    return skin;
  },
  readAttachment(attachmentName, nonessential) {
    let scale = this.scale;
    let name = this.readString();
    if (name == null) name = attachmentName;

    let path,
      n,
      region = {},
      box = {},
      mesh = {},
      linkdeMesh = {};
    let array;
    let point = {};
    let clipping = {};

    switch (AttachmentType[this.readByte()]) {
      case "region":
        path = this.readString();
        if (path == null) path = name;
        region.type = "region";
        region.name = name;
        region.path = path.trim();
        region.rotation = this.readFloat();
        region["x"] = this.readFloat() * scale;
        region["y"] = this.readFloat() * scale;
        region.scaleX = this.readFloat();
        region.scaleY = this.readFloat();
        region.width = this.readFloat() * scale;
        region.height = this.readFloat() * scale;
        region.color = this.readColor();
        return region;
      case "boundingbox":
        box.type = "boundingbox";
        box.name = name;
        n = this.readInt(!![]);
        box.vertexCount = n;
        box.vertices = this.readVertices(n);
        if (this.nonessential) {
          box.color = this.readColor();
        }
        return box;
      case "mesh":
        path = this.readString();
        if (path == null) path = name;
        mesh.type = "mesh";
        mesh.name = name;
        mesh.path = path;
        mesh.color = this.readColor();
        n = this.readInt(!![]);
        mesh.uvs = this.readFloatArray(n << 0x1, 0x1);
        mesh.triangles = this.readShortArray();
        mesh.vertices = this.readVertices(n);
        mesh.hull = this.readInt(!![]) << 0x1;
        if (nonessential) {
          mesh.edges = this.readShortArray();
          mesh.width = this.readFloat() * scale;
          mesh.height = this.readFloat() * scale;
        }
        return mesh;
      case "linkedmesh":
        path = this.readString();
        if (path == null) path = name;
        linkdeMesh.type = "linkedmesh";
        linkdeMesh.name = name;
        linkdeMesh.path = path;
        linkdeMesh.color = this.readColor();
        linkdeMesh.skin = this.readString();
        linkdeMesh.parent = this.readString();
        linkdeMesh.deform = this.readBoolean();
        if (nonessential) {
          linkdeMesh.width = this.readFloat() * scale;
          linkdeMesh.height = this.readFloat() * scale;
        }
        return linkdeMesh;
      case "path":
        path = {};
        path.type = "path";
        path.name = name;
        path.closed = this.readBoolean();
        path.constantSpeed = this.readBoolean();
        n = this.readInt(!![]);
        path.vertexCount = n;
        path.vertices = this.readVertices(n);
        array = array = new Array(n / 0x3);
        for (let i = 0x0; i < array.length; i++) {
          array[i] = this.readFloat() * scale;
        }
        path.lengths = array;
        if (nonessential) {
          path.color = this.readColor();
        }
        return path;
      case "point":
        point.type = "point";
        point.name = name;
        point.rotation = this.readFloat();
        point["x"] = this.readFloat() * scale;
        point["y"] = this.readFloat() * scale;
        if (nonessential) {
          path.color = this.readColor();
        }
        return point;
      case "clipping":
        clipping.type = "clipping";
        clipping.name = name;
        clipping.end = this.readInt(!![]);
        n = this.readInt(!![]);
        clipping.vertexCount = n;
        clipping.vertices = this.readVertices(n);
        if (nonessential) {
          clipping.color = this.readColor();
        }
        return clipping;
    }
    return null;
  },
  readCurve(frameIndex, timeline) {
    let cx1, cy1, cx2, cy2;
    switch (this.readByte()) {
      case 0x0:
        timeline[frameIndex].curve = "linear";
        break;
      case 0x1:
        timeline[frameIndex].curve = "stepped";
        break;
      case 0x2:
        cx1 = this.readFloat();
        cy1 = this.readFloat();
        cx2 = this.readFloat();
        cy2 = this.readFloat();
        timeline[frameIndex].curve = [cx1, cy1, cx2, cy2];
    }
  },
  readAnimation(name) {
    let animation = {};
    let scale = this.scale;
    let duration = 0x0;
    let slots = {};
    for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
      let slotIndex = this.readInt(!![]);
      let slotMap = {};
      let timeCount = this.readInt(!![]);
      for (let ii = 0x0; ii < timeCount; ii++) {
        let timelineType = this.readByte();
        let frameCount = this.readInt(!![]);
        let timeline;
        switch (timelineType) {
          case 0x0:
            timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              let time = this.readFloat();
              let color = this.readString();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              timeline[frameIndex].name = color;
            }
            slotMap.attachment = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
          case 0x1:
            timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              const time = this.readFloat();
              const color = this.readColor();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              timeline[frameIndex].color = color;
              if (frameIndex < frameCount - 0x1) {
                this.readCurve(frameIndex, timeline); //let curve
              }
            }
            slotMap.color = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
          case 0x2:
            timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              const time = this.readFloat();
              let lightColor = this.readColor();
              let darkColor = this.readColor();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              timeline[frameIndex].light = lightColor;
              timeline[frameIndex].dark = darkColor;
              if (frameIndex < frameCount - 0x1) {
                this.readCurve(frameIndex, timeline); // let curve
              }
            }
            slotMap.twoColor = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
        }
      }
      slots[this.json.slots[slotIndex].name] = slotMap;
    }
    animation.slots = slots;
    let bones = {};
    for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
      let boneIndex = this.readInt(!![]);
      let boneMap = {};
      for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
        const timelineType = this.readByte();
        const frameCount = this.readInt(!![]);
        let timeline;
        let timelineScale = 0x1;

        switch (timelineType) {
          case 0x0:
            timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              const time = this.readFloat();
              const tlangle = this.readFloat();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              timeline[frameIndex].angle = tlangle;
              if (frameIndex < frameCount - 0x1) {
                this.readCurve(frameIndex, timeline);
              }
            }
            boneMap.rotate = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
          case 0x1:
          case 0x2:
          case 0x3:
            timeline = new Array(frameCount);
            if (timelineType == 0x1) {
              timelineScale = scale;
            }
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              let tltime = this.readFloat();
              let tlx = this.readFloat();
              let tly = this.readFloat();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = tltime;
              timeline[frameIndex]["x"] = tlx * timelineScale;
              timeline[frameIndex]["y"] = tly * timelineScale;
              if (frameIndex < frameCount - 0x1) {
                this.readCurve(frameIndex, timeline);
              }
            }
            if (timelineType == 0x1) {
              boneMap.translate = timeline;
            } else if (timelineType == 0x2) {
              boneMap.scale = timeline;
            } else {
              boneMap.shear = timeline;
            }
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
        }
      }
      bones[this.json.bones[boneIndex].name] = boneMap;
    }
    animation.bones = bones;
    let ik = {};
    for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
      const ikIndex = this.readInt(!![]);
      const frameCount = this.readInt(!![]);
      const timeline = new Array(frameCount);
      for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
        const time = this.readFloat();
        const mix = this.readFloat();
        const bendPositive = this.readByte() != 0xff;
        timeline[frameIndex] = {};
        timeline[frameIndex].time = time;
        timeline[frameIndex].mix = mix;
        timeline[frameIndex].bendPositive = bendPositive;
        if (frameIndex < frameCount - 0x1) {
          this.readCurve(frameIndex, timeline);
        }
      }
      ik[this.json["ik"][ikIndex].name] = timeline;
      duration = Math.max(duration, timeline[frameCount - 0x1].time);
    }
    animation["ik"] = ik;
    let ffd = {};
    for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
      const slotIndex = this.readInt(!![]);
      const frameCount = this.readInt(!![]);
      const timeline = new Array(frameCount);
      for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
        timeline[frameIndex] = {};
        timeline[frameIndex].time = this.readFloat();
        timeline[frameIndex].rotateMix = this.readFloat();
        timeline[frameIndex].translateMix = this.readFloat();
        timeline[frameIndex].scaleMix = this.readFloat();
        timeline[frameIndex].shearMix = this.readFloat();
        if (frameIndex < frameCount - 0x1) {
          this.readCurve(frameIndex, timeline);
        }
      }
      ffd[this.json.transform[slotIndex].name] = timeline;
      duration = Math.max(duration, timeline[frameCount - 0x1].time);
    }
    animation.transform = ffd;

    let path = {};
    for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
      let pathOrder = this.readInt(!![]);
      let pathData = this.json.path[pathOrder];
      let data = {};
      for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
        const timelineType = this.readByte();
        const frameCount = this.readInt(!![]);
        let timeline, time, timelineScale;
        switch (timelineType) {
          case 0x0:
          case 0x1:
            timeline = new Array(frameCount);
            timelineScale = 0x1;
            if (timelineType == 0x1) {
              if (
                pathData.spacingMode == "length" ||
                pathData.spacingMode == "fixed"
              ) {
                timelineScale = this.scale;
              }
            } else {
              if (pathData.positionMode == "fixed") {
                timelineScale = this.scale;
              }
            }
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              time = this.readFloat();
              let _0xebc795 = this.readFloat();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              if (timelineType == 0x0) {
                timeline[frameIndex].position = _0xebc795 * timelineScale;
              } else {
                timeline[frameIndex].spacing = _0xebc795 * timelineScale;
              }
              if (frameIndex < frameCount - 0x1)
                this.readCurve(frameIndex, timeline);
            }
            if (timelineType == 0x0) {
              data.position = timeline;
            } else {
              data.spacing = timeline;
            }
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
          case 0x2:
            timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
              time = this.readFloat();
              let _0x47f0f0 = this.readFloat();
              let _0x1bb1d7 = this.readFloat();
              timeline[frameIndex] = {};
              timeline[frameIndex].time = time;
              timeline[frameIndex].rotateMix = _0x47f0f0;
              timeline[frameIndex].translateMix = _0x1bb1d7;
              if (frameIndex < frameCount - 0x1)
                this.readCurve(frameIndex, timeline);
            }
            data.mix = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
            break;
        }
      }
      path[this.json.path[pathOrder].name] = data;
    }
    animation.paths = path;

    // å˜é‡åå¯èƒ½ä¸å¯¹
    let deform = {};
    for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
      let index = this.readInt(!![]);
      let skinName = this.json.skinsName[index];
      let deformData = {};
      for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
        const slotIndex = this.readInt(!![]);
        const slot = this.json.slots[slotIndex];
        const attachment = {};
        for (let iii = 0x0, nnn = this.readInt(!![]); iii < nnn; iii++) {
          const name = this.readString();
          const frameCount = this.readInt(!![]);
          const timeline = new Array(frameCount);
          for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
            const time = this.readFloat();
            const end = this.readInt(!![]);
            timeline[frameIndex] = {};
            timeline[frameIndex].time = time;
            if (end != 0x0) {
              let vertices = new Array(end);
              let start = this.readInt(!![]);
              if (this.scale == 0x1) {
                for (let i = 0x0; i < end; i++) {
                  vertices[i] = this.readFloat();
                }
              } else {
                for (let i = 0x0; i < end; i++) {
                  vertices[i] = this.readFloat() * this.scale;
                }
              }
              timeline[frameIndex].offset = start;
              timeline[frameIndex].vertices = vertices;
            }
            if (frameIndex < frameCount - 0x1)
              this.readCurve(frameIndex, timeline);
          }
          attachment[name] = timeline;
          duration = Math.max(duration, timeline[frameCount - 0x1].time);
        }
        deformData[slot.name] = attachment;
      }
      deform[skinName] = deformData;
    }
    animation.deform = deform;

    let drawOrderCount = this.readInt(!![]);
    if (drawOrderCount > 0x0) {
      let drawOrders = new Array(drawOrderCount);
      for (let i = 0x0; i < drawOrderCount; i++) {
        const drawOrderMap = {};
        const time = this.readFloat();
        const offsetCount = this.readInt(!![]);
        const offsets = new Array(offsetCount);
        for (let ii = 0x0; ii < offsetCount; ii++) {
          const offsetMap = {};
          const slotIndex = this.readInt(!![]);
          offsetMap.slot = this.json.slots[slotIndex].name;
          let dooffset = this.readInt(!![]);
          offsetMap.offset = dooffset;
          offsets[ii] = offsetMap;
        }
        drawOrderMap.offsets = offsets;
        drawOrderMap.time = time;
        drawOrders[i] = drawOrderMap;
      }
      duration = Math.max(duration, drawOrders[drawOrderCount - 0x1].time);
      animation.drawOrder = drawOrders;
    }
    let eventCount = this.readInt(!![]);
    if (eventCount > 0x0) {
      let events = new Array(eventCount);
      for (let i = 0x0; i < eventCount; i++) {
        const time = this.readFloat();
        const name = this.json.eventsName[this.readInt(!![])];
        const eventData = this.json.events[name];
        const e = {};
        e.name = name;
        e.int = this.readInt(![]);
        e.float = this.readFloat();
        e.string = this.readBoolean() ? this.readString() : eventData.string;
        e.time = time;
        events[i] = e;
      }
      duration = Math.max(duration, events[eventCount - 0x1].time);
      animation.events = events;
    }
    return animation;
  },
};

var BlendMode = ["normal", "additive", "multiply", "screen"];

var AttachmentType = [
  "region",
  "boundingbox",
  "mesh",
  "linkedmesh",
  "path",
  "point",
  "clipping",
];

var TransformMode = [
  "normal",
  "onlyTranslation",
  "noRotationOrReflection",
  "noScale",
  "noScaleOrReflection",
];

var PositionMode = ["fixed", "percent"];

var SpacingMode = ["length", "fixed", "percent"];

var RotateMode = ["tangent", "chain", "chainScale"];


/***/ }),

/***/ "./src/spine_runtime/spine-widget.js":
/*!*******************************************!*\
  !*** ./src/spine_runtime/spine-widget.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __extends = (undefined && undefined.__extends) || function (d, b) {
	for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	function __() { this.constructor = d; }
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var spine;
(function (spine) {
	var Animation = (function () {
		function Animation(name, timelines, duration) {
			if (name == null)
				throw new Error("name cannot be null.");
			if (timelines == null)
				throw new Error("timelines cannot be null.");
			this.name = name;
			this.timelines = timelines;
			this.duration = duration;
		}
		Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			if (loop && this.duration != 0) {
				time %= this.duration;
				if (lastTime > 0)
					lastTime %= this.duration;
			}
			var timelines = this.timelines;
			for (var i = 0, n = timelines.length; i < n; i++)
				timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);
		};
		Animation.binarySearch = function (values, target, step) {
			if (step === void 0) { step = 1; }
			var low = 0;
			var high = values.length / step - 2;
			if (high == 0)
				return step;
			var current = high >>> 1;
			while (true) {
				if (values[(current + 1) * step] <= target)
					low = current + 1;
				else
					high = current;
				if (low == high)
					return (low + 1) * step;
				current = (low + high) >>> 1;
			}
		};
		Animation.linearSearch = function (values, target, step) {
			for (var i = 0, last = values.length - step; i <= last; i += step)
				if (values[i] > target)
					return i;
			return -1;
		};
		return Animation;
	}());
	spine.Animation = Animation;
	(function (MixPose) {
		MixPose[MixPose["setup"] = 0] = "setup";
		MixPose[MixPose["current"] = 1] = "current";
		MixPose[MixPose["currentLayered"] = 2] = "currentLayered";
	})(spine.MixPose || (spine.MixPose = {}));
	var MixPose = spine.MixPose;
	(function (MixDirection) {
		MixDirection[MixDirection["in"] = 0] = "in";
		MixDirection[MixDirection["out"] = 1] = "out";
	})(spine.MixDirection || (spine.MixDirection = {}));
	var MixDirection = spine.MixDirection;
	(function (TimelineType) {
		TimelineType[TimelineType["rotate"] = 0] = "rotate";
		TimelineType[TimelineType["translate"] = 1] = "translate";
		TimelineType[TimelineType["scale"] = 2] = "scale";
		TimelineType[TimelineType["shear"] = 3] = "shear";
		TimelineType[TimelineType["attachment"] = 4] = "attachment";
		TimelineType[TimelineType["color"] = 5] = "color";
		TimelineType[TimelineType["deform"] = 6] = "deform";
		TimelineType[TimelineType["event"] = 7] = "event";
		TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
		TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
		TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
		TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
		TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
		TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
		TimelineType[TimelineType["twoColor"] = 14] = "twoColor";
	})(spine.TimelineType || (spine.TimelineType = {}));
	var TimelineType = spine.TimelineType;
	var CurveTimeline = (function () {
		function CurveTimeline(frameCount) {
			if (frameCount <= 0)
				throw new Error("frameCount must be > 0: " + frameCount);
			this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
		}
		CurveTimeline.prototype.getFrameCount = function () {
			return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
		};
		CurveTimeline.prototype.setLinear = function (frameIndex) {
			this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
		};
		CurveTimeline.prototype.setStepped = function (frameIndex) {
			this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
		};
		CurveTimeline.prototype.getCurveType = function (frameIndex) {
			var index = frameIndex * CurveTimeline.BEZIER_SIZE;
			if (index == this.curves.length)
				return CurveTimeline.LINEAR;
			var type = this.curves[index];
			if (type == CurveTimeline.LINEAR)
				return CurveTimeline.LINEAR;
			if (type == CurveTimeline.STEPPED)
				return CurveTimeline.STEPPED;
			return CurveTimeline.BEZIER;
		};
		CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {
			var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
			var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
			var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
			var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
			var i = frameIndex * CurveTimeline.BEZIER_SIZE;
			var curves = this.curves;
			curves[i++] = CurveTimeline.BEZIER;
			var x = dfx, y = dfy;
			for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
				curves[i] = x;
				curves[i + 1] = y;
				dfx += ddfx;
				dfy += ddfy;
				ddfx += dddfx;
				ddfy += dddfy;
				x += dfx;
				y += dfy;
			}
		};
		CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {
			percent = spine.MathUtils.clamp(percent, 0, 1);
			var curves = this.curves;
			var i = frameIndex * CurveTimeline.BEZIER_SIZE;
			var type = curves[i];
			if (type == CurveTimeline.LINEAR)
				return percent;
			if (type == CurveTimeline.STEPPED)
				return 0;
			i++;
			var x = 0;
			for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
				x = curves[i];
				if (x >= percent) {
					var prevX = void 0, prevY = void 0;
					if (i == start) {
						prevX = 0;
						prevY = 0;
					}
					else {
						prevX = curves[i - 2];
						prevY = curves[i - 1];
					}
					return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
				}
			}
			var y = curves[i - 1];
			return y + (1 - y) * (percent - x) / (1 - x);
		};
		CurveTimeline.LINEAR = 0;
		CurveTimeline.STEPPED = 1;
		CurveTimeline.BEZIER = 2;
		CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
		return CurveTimeline;
	}());
	spine.CurveTimeline = CurveTimeline;
	var RotateTimeline = (function (_super) {
		__extends(RotateTimeline, _super);
		function RotateTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount << 1);
		}
		RotateTimeline.prototype.getPropertyId = function () {
			return (TimelineType.rotate << 24) + this.boneIndex;
		};
		RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {
			frameIndex <<= 1;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
		};
		RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						bone.rotation = bone.data.rotation;
						return;
					case MixPose.current:
						var r_1 = bone.data.rotation - bone.rotation;
						r_1 -= (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360;
						bone.rotation += r_1 * alpha;
				}
				return;
			}
			if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
				if (pose == MixPose.setup)
					bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;
				else {
					var r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;
					r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;
					bone.rotation += r_2 * alpha;
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
			var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
			var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
			r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
			r = prevRotation + r * percent;
			if (pose == MixPose.setup) {
				r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
				bone.rotation = bone.data.rotation + r * alpha;
			}
			else {
				r = bone.data.rotation + r - bone.rotation;
				r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
				bone.rotation += r * alpha;
			}
		};
		RotateTimeline.ENTRIES = 2;
		RotateTimeline.PREV_TIME = -2;
		RotateTimeline.PREV_ROTATION = -1;
		RotateTimeline.ROTATION = 1;
		return RotateTimeline;
	}(CurveTimeline));
	spine.RotateTimeline = RotateTimeline;
	var TranslateTimeline = (function (_super) {
		__extends(TranslateTimeline, _super);
		function TranslateTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
		}
		TranslateTimeline.prototype.getPropertyId = function () {
			return (TimelineType.translate << 24) + this.boneIndex;
		};
		TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {
			frameIndex *= TranslateTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TranslateTimeline.X] = x;
			this.frames[frameIndex + TranslateTimeline.Y] = y;
		};
		TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						bone.x = bone.data.x;
						bone.y = bone.data.y;
						return;
					case MixPose.current:
						bone.x += (bone.data.x - bone.x) * alpha;
						bone.y += (bone.data.y - bone.y) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
				x = frames[frames.length + TranslateTimeline.PREV_X];
				y = frames[frames.length + TranslateTimeline.PREV_Y];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
				x = frames[frame + TranslateTimeline.PREV_X];
				y = frames[frame + TranslateTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
				x += (frames[frame + TranslateTimeline.X] - x) * percent;
				y += (frames[frame + TranslateTimeline.Y] - y) * percent;
			}
			if (pose == MixPose.setup) {
				bone.x = bone.data.x + x * alpha;
				bone.y = bone.data.y + y * alpha;
			}
			else {
				bone.x += (bone.data.x + x - bone.x) * alpha;
				bone.y += (bone.data.y + y - bone.y) * alpha;
			}
		};
		TranslateTimeline.ENTRIES = 3;
		TranslateTimeline.PREV_TIME = -3;
		TranslateTimeline.PREV_X = -2;
		TranslateTimeline.PREV_Y = -1;
		TranslateTimeline.X = 1;
		TranslateTimeline.Y = 2;
		return TranslateTimeline;
	}(CurveTimeline));
	spine.TranslateTimeline = TranslateTimeline;
	var ScaleTimeline = (function (_super) {
		__extends(ScaleTimeline, _super);
		function ScaleTimeline(frameCount) {
			_super.call(this, frameCount);
		}
		ScaleTimeline.prototype.getPropertyId = function () {
			return (TimelineType.scale << 24) + this.boneIndex;
		};
		ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						bone.scaleX = bone.data.scaleX;
						bone.scaleY = bone.data.scaleY;
						return;
					case MixPose.current:
						bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
						bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
				x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
				y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
			}
			else {
				var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
				x = frames[frame + ScaleTimeline.PREV_X];
				y = frames[frame + ScaleTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
				x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
				y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
			}
			if (alpha == 1) {
				bone.scaleX = x;
				bone.scaleY = y;
			}
			else {
				var bx = 0, by = 0;
				if (pose == MixPose.setup) {
					bx = bone.data.scaleX;
					by = bone.data.scaleY;
				}
				else {
					bx = bone.scaleX;
					by = bone.scaleY;
				}
				if (direction == MixDirection.out) {
					x = Math.abs(x) * spine.MathUtils.signum(bx);
					y = Math.abs(y) * spine.MathUtils.signum(by);
				}
				else {
					bx = Math.abs(bx) * spine.MathUtils.signum(x);
					by = Math.abs(by) * spine.MathUtils.signum(y);
				}
				bone.scaleX = bx + (x - bx) * alpha;
				bone.scaleY = by + (y - by) * alpha;
			}
		};
		return ScaleTimeline;
	}(TranslateTimeline));
	spine.ScaleTimeline = ScaleTimeline;
	var ShearTimeline = (function (_super) {
		__extends(ShearTimeline, _super);
		function ShearTimeline(frameCount) {
			_super.call(this, frameCount);
		}
		ShearTimeline.prototype.getPropertyId = function () {
			return (TimelineType.shear << 24) + this.boneIndex;
		};
		ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						bone.shearX = bone.data.shearX;
						bone.shearY = bone.data.shearY;
						return;
					case MixPose.current:
						bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
						bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
				x = frames[frames.length + ShearTimeline.PREV_X];
				y = frames[frames.length + ShearTimeline.PREV_Y];
			}
			else {
				var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
				x = frames[frame + ShearTimeline.PREV_X];
				y = frames[frame + ShearTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
				x = x + (frames[frame + ShearTimeline.X] - x) * percent;
				y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
			}
			if (pose == MixPose.setup) {
				bone.shearX = bone.data.shearX + x * alpha;
				bone.shearY = bone.data.shearY + y * alpha;
			}
			else {
				bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
				bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
			}
		};
		return ShearTimeline;
	}(TranslateTimeline));
	spine.ShearTimeline = ShearTimeline;
	var ColorTimeline = (function (_super) {
		__extends(ColorTimeline, _super);
		function ColorTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
		}
		ColorTimeline.prototype.getPropertyId = function () {
			return (TimelineType.color << 24) + this.slotIndex;
		};
		ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {
			frameIndex *= ColorTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + ColorTimeline.R] = r;
			this.frames[frameIndex + ColorTimeline.G] = g;
			this.frames[frameIndex + ColorTimeline.B] = b;
			this.frames[frameIndex + ColorTimeline.A] = a;
		};
		ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var slot = skeleton.slots[this.slotIndex];
			var frames = this.frames;
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						slot.color.setFromColor(slot.data.color);
						return;
					case MixPose.current:
						var color = slot.color, setup = slot.data.color;
						color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
				}
				return;
			}
			var r = 0, g = 0, b = 0, a = 0;
			if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
				var i = frames.length;
				r = frames[i + ColorTimeline.PREV_R];
				g = frames[i + ColorTimeline.PREV_G];
				b = frames[i + ColorTimeline.PREV_B];
				a = frames[i + ColorTimeline.PREV_A];
			}
			else {
				var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
				r = frames[frame + ColorTimeline.PREV_R];
				g = frames[frame + ColorTimeline.PREV_G];
				b = frames[frame + ColorTimeline.PREV_B];
				a = frames[frame + ColorTimeline.PREV_A];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
				r += (frames[frame + ColorTimeline.R] - r) * percent;
				g += (frames[frame + ColorTimeline.G] - g) * percent;
				b += (frames[frame + ColorTimeline.B] - b) * percent;
				a += (frames[frame + ColorTimeline.A] - a) * percent;
			}
			if (alpha == 1)
				slot.color.set(r, g, b, a);
			else {
				var color = slot.color;
				if (pose == MixPose.setup)
					color.setFromColor(slot.data.color);
				color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
			}
		};
		ColorTimeline.ENTRIES = 5;
		ColorTimeline.PREV_TIME = -5;
		ColorTimeline.PREV_R = -4;
		ColorTimeline.PREV_G = -3;
		ColorTimeline.PREV_B = -2;
		ColorTimeline.PREV_A = -1;
		ColorTimeline.R = 1;
		ColorTimeline.G = 2;
		ColorTimeline.B = 3;
		ColorTimeline.A = 4;
		return ColorTimeline;
	}(CurveTimeline));
	spine.ColorTimeline = ColorTimeline;
	var TwoColorTimeline = (function (_super) {
		__extends(TwoColorTimeline, _super);
		function TwoColorTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);
		}
		TwoColorTimeline.prototype.getPropertyId = function () {
			return (TimelineType.twoColor << 24) + this.slotIndex;
		};
		TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {
			frameIndex *= TwoColorTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TwoColorTimeline.R] = r;
			this.frames[frameIndex + TwoColorTimeline.G] = g;
			this.frames[frameIndex + TwoColorTimeline.B] = b;
			this.frames[frameIndex + TwoColorTimeline.A] = a;
			this.frames[frameIndex + TwoColorTimeline.R2] = r2;
			this.frames[frameIndex + TwoColorTimeline.G2] = g2;
			this.frames[frameIndex + TwoColorTimeline.B2] = b2;
		};
		TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var slot = skeleton.slots[this.slotIndex];
			var frames = this.frames;
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						slot.color.setFromColor(slot.data.color);
						slot.darkColor.setFromColor(slot.data.darkColor);
						return;
					case MixPose.current:
						var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
						light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
						dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
				}
				return;
			}
			var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
			if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {
				var i = frames.length;
				r = frames[i + TwoColorTimeline.PREV_R];
				g = frames[i + TwoColorTimeline.PREV_G];
				b = frames[i + TwoColorTimeline.PREV_B];
				a = frames[i + TwoColorTimeline.PREV_A];
				r2 = frames[i + TwoColorTimeline.PREV_R2];
				g2 = frames[i + TwoColorTimeline.PREV_G2];
				b2 = frames[i + TwoColorTimeline.PREV_B2];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);
				r = frames[frame + TwoColorTimeline.PREV_R];
				g = frames[frame + TwoColorTimeline.PREV_G];
				b = frames[frame + TwoColorTimeline.PREV_B];
				a = frames[frame + TwoColorTimeline.PREV_A];
				r2 = frames[frame + TwoColorTimeline.PREV_R2];
				g2 = frames[frame + TwoColorTimeline.PREV_G2];
				b2 = frames[frame + TwoColorTimeline.PREV_B2];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));
				r += (frames[frame + TwoColorTimeline.R] - r) * percent;
				g += (frames[frame + TwoColorTimeline.G] - g) * percent;
				b += (frames[frame + TwoColorTimeline.B] - b) * percent;
				a += (frames[frame + TwoColorTimeline.A] - a) * percent;
				r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;
				g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;
				b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;
			}
			if (alpha == 1) {
				slot.color.set(r, g, b, a);
				slot.darkColor.set(r2, g2, b2, 1);
			}
			else {
				var light = slot.color, dark = slot.darkColor;
				if (pose == MixPose.setup) {
					light.setFromColor(slot.data.color);
					dark.setFromColor(slot.data.darkColor);
				}
				light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
				dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
			}
		};
		TwoColorTimeline.ENTRIES = 8;
		TwoColorTimeline.PREV_TIME = -8;
		TwoColorTimeline.PREV_R = -7;
		TwoColorTimeline.PREV_G = -6;
		TwoColorTimeline.PREV_B = -5;
		TwoColorTimeline.PREV_A = -4;
		TwoColorTimeline.PREV_R2 = -3;
		TwoColorTimeline.PREV_G2 = -2;
		TwoColorTimeline.PREV_B2 = -1;
		TwoColorTimeline.R = 1;
		TwoColorTimeline.G = 2;
		TwoColorTimeline.B = 3;
		TwoColorTimeline.A = 4;
		TwoColorTimeline.R2 = 5;
		TwoColorTimeline.G2 = 6;
		TwoColorTimeline.B2 = 7;
		return TwoColorTimeline;
	}(CurveTimeline));
	spine.TwoColorTimeline = TwoColorTimeline;
	var AttachmentTimeline = (function () {
		function AttachmentTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.attachmentNames = new Array(frameCount);
		}
		AttachmentTimeline.prototype.getPropertyId = function () {
			return (TimelineType.attachment << 24) + this.slotIndex;
		};
		AttachmentTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {
			this.frames[frameIndex] = time;
			this.attachmentNames[frameIndex] = attachmentName;
		};
		AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
			var slot = skeleton.slots[this.slotIndex];
			if (direction == MixDirection.out && pose == MixPose.setup) {
				var attachmentName_1 = slot.data.attachmentName;
				slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
				return;
			}
			var frames = this.frames;
			if (time < frames[0]) {
				if (pose == MixPose.setup) {
					var attachmentName_2 = slot.data.attachmentName;
					slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
				}
				return;
			}
			var frameIndex = 0;
			if (time >= frames[frames.length - 1])
				frameIndex = frames.length - 1;
			else
				frameIndex = Animation.binarySearch(frames, time, 1) - 1;
			var attachmentName = this.attachmentNames[frameIndex];
			skeleton.slots[this.slotIndex]
				.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
		};
		return AttachmentTimeline;
	}());
	spine.AttachmentTimeline = AttachmentTimeline;
	var DeformTimeline = (function (_super) {
		__extends(DeformTimeline, _super);
		function DeformTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.frameVertices = new Array(frameCount);
		}
		DeformTimeline.prototype.getPropertyId = function () {
			return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
		};
		DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {
			this.frames[frameIndex] = time;
			this.frameVertices[frameIndex] = vertices;
		};
		DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var slot = skeleton.slots[this.slotIndex];
			var slotAttachment = slot.getAttachment();
			if (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))
				return;
			var verticesArray = slot.attachmentVertices;
			var frameVertices = this.frameVertices;
			var vertexCount = frameVertices[0].length;
			if (verticesArray.length != vertexCount && pose != MixPose.setup)
				alpha = 1;
			var vertices = spine.Utils.setArraySize(verticesArray, vertexCount);
			var frames = this.frames;
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						verticesArray.length = 0;
						return;
					case MixPose.current:
						alpha = 1 - alpha;
						for (var i = 0; i < vertexCount; i++)
							vertices[i] *= alpha;
				}
				return;
			}
			if (time >= frames[frames.length - 1]) {
				var lastVertices = frameVertices[frames.length - 1];
				if (alpha == 1) {
					spine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
				}
				else if (pose == MixPose.setup) {
					var vertexAttachment = slotAttachment;
					if (vertexAttachment.bones == null) {
						var setupVertices = vertexAttachment.vertices;
						for (var i = 0; i < vertexCount; i++) {
							var setup = setupVertices[i];
							vertices[i] = setup + (lastVertices[i] - setup) * alpha;
						}
					}
					else {
						for (var i = 0; i < vertexCount; i++)
							vertices[i] = lastVertices[i] * alpha;
					}
				}
				else {
					for (var i = 0; i < vertexCount; i++)
						vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time);
			var prevVertices = frameVertices[frame - 1];
			var nextVertices = frameVertices[frame];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
			if (alpha == 1) {
				for (var i = 0; i < vertexCount; i++) {
					var prev = prevVertices[i];
					vertices[i] = prev + (nextVertices[i] - prev) * percent;
				}
			}
			else if (pose == MixPose.setup) {
				var vertexAttachment = slotAttachment;
				if (vertexAttachment.bones == null) {
					var setupVertices = vertexAttachment.vertices;
					for (var i = 0; i < vertexCount; i++) {
						var prev = prevVertices[i], setup = setupVertices[i];
						vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
					}
				}
				else {
					for (var i = 0; i < vertexCount; i++) {
						var prev = prevVertices[i];
						vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
					}
				}
			}
			else {
				for (var i = 0; i < vertexCount; i++) {
					var prev = prevVertices[i];
					vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
				}
			}
		};
		return DeformTimeline;
	}(CurveTimeline));
	spine.DeformTimeline = DeformTimeline;
	var EventTimeline = (function () {
		function EventTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.events = new Array(frameCount);
		}
		EventTimeline.prototype.getPropertyId = function () {
			return TimelineType.event << 24;
		};
		EventTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		EventTimeline.prototype.setFrame = function (frameIndex, event) {
			this.frames[frameIndex] = event.time;
			this.events[frameIndex] = event;
		};
		EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			if (firedEvents == null)
				return;
			var frames = this.frames;
			var frameCount = this.frames.length;
			if (lastTime > time) {
				this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);
				lastTime = -1;
			}
			else if (lastTime >= frames[frameCount - 1])
				return;
			if (time < frames[0])
				return;
			var frame = 0;
			if (lastTime < frames[0])
				frame = 0;
			else {
				frame = Animation.binarySearch(frames, lastTime);
				var frameTime = frames[frame];
				while (frame > 0) {
					if (frames[frame - 1] != frameTime)
						break;
					frame--;
				}
			}
			for (; frame < frameCount && time >= frames[frame]; frame++)
				firedEvents.push(this.events[frame]);
		};
		return EventTimeline;
	}());
	spine.EventTimeline = EventTimeline;
	var DrawOrderTimeline = (function () {
		function DrawOrderTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.drawOrders = new Array(frameCount);
		}
		DrawOrderTimeline.prototype.getPropertyId = function () {
			return TimelineType.drawOrder << 24;
		};
		DrawOrderTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {
			this.frames[frameIndex] = time;
			this.drawOrders[frameIndex] = drawOrder;
		};
		DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var drawOrder = skeleton.drawOrder;
			var slots = skeleton.slots;
			if (direction == MixDirection.out && pose == MixPose.setup) {
				spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
				return;
			}
			var frames = this.frames;
			if (time < frames[0]) {
				if (pose == MixPose.setup)
					spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
				return;
			}
			var frame = 0;
			if (time >= frames[frames.length - 1])
				frame = frames.length - 1;
			else
				frame = Animation.binarySearch(frames, time) - 1;
			var drawOrderToSetupIndex = this.drawOrders[frame];
			if (drawOrderToSetupIndex == null)
				spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
			else {
				for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
					drawOrder[i] = slots[drawOrderToSetupIndex[i]];
			}
		};
		return DrawOrderTimeline;
	}());
	spine.DrawOrderTimeline = DrawOrderTimeline;
	var IkConstraintTimeline = (function (_super) {
		__extends(IkConstraintTimeline, _super);
		function IkConstraintTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
		}
		IkConstraintTimeline.prototype.getPropertyId = function () {
			return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
		};
		IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {
			frameIndex *= IkConstraintTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
			this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
		};
		IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var frames = this.frames;
			var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						constraint.mix = constraint.data.mix;
						constraint.bendDirection = constraint.data.bendDirection;
						return;
					case MixPose.current:
						constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
						constraint.bendDirection = constraint.data.bendDirection;
				}
				return;
			}
			if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
				if (pose == MixPose.setup) {
					constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
					constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection
						: frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
				}
				else {
					constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
					if (direction == MixDirection.in)
						constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
			var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
			if (pose == MixPose.setup) {
				constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
				constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
			}
			else {
				constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
				if (direction == MixDirection.in)
					constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
			}
		};
		IkConstraintTimeline.ENTRIES = 3;
		IkConstraintTimeline.PREV_TIME = -3;
		IkConstraintTimeline.PREV_MIX = -2;
		IkConstraintTimeline.PREV_BEND_DIRECTION = -1;
		IkConstraintTimeline.MIX = 1;
		IkConstraintTimeline.BEND_DIRECTION = 2;
		return IkConstraintTimeline;
	}(CurveTimeline));
	spine.IkConstraintTimeline = IkConstraintTimeline;
	var TransformConstraintTimeline = (function (_super) {
		__extends(TransformConstraintTimeline, _super);
		function TransformConstraintTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
		}
		TransformConstraintTimeline.prototype.getPropertyId = function () {
			return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
		};
		TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
			frameIndex *= TransformConstraintTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
			this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
			this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
			this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
		};
		TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var frames = this.frames;
			var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
			if (time < frames[0]) {
				var data = constraint.data;
				switch (pose) {
					case MixPose.setup:
						constraint.rotateMix = data.rotateMix;
						constraint.translateMix = data.translateMix;
						constraint.scaleMix = data.scaleMix;
						constraint.shearMix = data.shearMix;
						return;
					case MixPose.current:
						constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
						constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
						constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
						constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
				}
				return;
			}
			var rotate = 0, translate = 0, scale = 0, shear = 0;
			if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
				var i = frames.length;
				rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
				translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
				scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
				shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
				rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
				translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
				scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
				shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
				rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
				translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
				scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
				shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
			}
			if (pose == MixPose.setup) {
				var data = constraint.data;
				constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
				constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
				constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
				constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
			}
			else {
				constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
				constraint.translateMix += (translate - constraint.translateMix) * alpha;
				constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
				constraint.shearMix += (shear - constraint.shearMix) * alpha;
			}
		};
		TransformConstraintTimeline.ENTRIES = 5;
		TransformConstraintTimeline.PREV_TIME = -5;
		TransformConstraintTimeline.PREV_ROTATE = -4;
		TransformConstraintTimeline.PREV_TRANSLATE = -3;
		TransformConstraintTimeline.PREV_SCALE = -2;
		TransformConstraintTimeline.PREV_SHEAR = -1;
		TransformConstraintTimeline.ROTATE = 1;
		TransformConstraintTimeline.TRANSLATE = 2;
		TransformConstraintTimeline.SCALE = 3;
		TransformConstraintTimeline.SHEAR = 4;
		return TransformConstraintTimeline;
	}(CurveTimeline));
	spine.TransformConstraintTimeline = TransformConstraintTimeline;
	var PathConstraintPositionTimeline = (function (_super) {
		__extends(PathConstraintPositionTimeline, _super);
		function PathConstraintPositionTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
		}
		PathConstraintPositionTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
		};
		PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {
			frameIndex *= PathConstraintPositionTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
		};
		PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						constraint.position = constraint.data.position;
						return;
					case MixPose.current:
						constraint.position += (constraint.data.position - constraint.position) * alpha;
				}
				return;
			}
			var position = 0;
			if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])
				position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
				position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
				position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
			}
			if (pose == MixPose.setup)
				constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
			else
				constraint.position += (position - constraint.position) * alpha;
		};
		PathConstraintPositionTimeline.ENTRIES = 2;
		PathConstraintPositionTimeline.PREV_TIME = -2;
		PathConstraintPositionTimeline.PREV_VALUE = -1;
		PathConstraintPositionTimeline.VALUE = 1;
		return PathConstraintPositionTimeline;
	}(CurveTimeline));
	spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
	var PathConstraintSpacingTimeline = (function (_super) {
		__extends(PathConstraintSpacingTimeline, _super);
		function PathConstraintSpacingTimeline(frameCount) {
			_super.call(this, frameCount);
		}
		PathConstraintSpacingTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
		};
		PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						constraint.spacing = constraint.data.spacing;
						return;
					case MixPose.current:
						constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
				}
				return;
			}
			var spacing = 0;
			if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
				spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
				spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
				spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
			}
			if (pose == MixPose.setup)
				constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
			else
				constraint.spacing += (spacing - constraint.spacing) * alpha;
		};
		return PathConstraintSpacingTimeline;
	}(PathConstraintPositionTimeline));
	spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
	var PathConstraintMixTimeline = (function (_super) {
		__extends(PathConstraintMixTimeline, _super);
		function PathConstraintMixTimeline(frameCount) {
			_super.call(this, frameCount);
			this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
		}
		PathConstraintMixTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
		};
		PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {
			frameIndex *= PathConstraintMixTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
			this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
		};
		PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (time < frames[0]) {
				switch (pose) {
					case MixPose.setup:
						constraint.rotateMix = constraint.data.rotateMix;
						constraint.translateMix = constraint.data.translateMix;
						return;
					case MixPose.current:
						constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
						constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
				}
				return;
			}
			var rotate = 0, translate = 0;
			if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
				rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
				translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
			}
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
				rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
				translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
				rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
				translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
			}
			if (pose == MixPose.setup) {
				constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
				constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
			}
			else {
				constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
				constraint.translateMix += (translate - constraint.translateMix) * alpha;
			}
		};
		PathConstraintMixTimeline.ENTRIES = 3;
		PathConstraintMixTimeline.PREV_TIME = -3;
		PathConstraintMixTimeline.PREV_ROTATE = -2;
		PathConstraintMixTimeline.PREV_TRANSLATE = -1;
		PathConstraintMixTimeline.ROTATE = 1;
		PathConstraintMixTimeline.TRANSLATE = 2;
		return PathConstraintMixTimeline;
	}(CurveTimeline));
	spine.PathConstraintMixTimeline = PathConstraintMixTimeline;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AnimationState = (function () {
		function AnimationState(data) {
			this.tracks = new Array();
			this.events = new Array();
			this.listeners = new Array();
			this.queue = new EventQueue(this);
			this.propertyIDs = new spine.IntSet();
			this.mixingTo = new Array();
			this.animationsChanged = false;
			this.timeScale = 1;
			this.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });
			this.data = data;
		}
		AnimationState.prototype.update = function (delta) {
			delta *= this.timeScale;
			var tracks = this.tracks;
			for (var i = 0, n = tracks.length; i < n; i++) {
				var current = tracks[i];
				if (current == null)
					continue;
				current.animationLast = current.nextAnimationLast;
				current.trackLast = current.nextTrackLast;
				var currentDelta = delta * current.timeScale;
				if (current.delay > 0) {
					current.delay -= currentDelta;
					if (current.delay > 0)
						continue;
					currentDelta = -current.delay;
					current.delay = 0;
				}
				var next = current.next;
				if (next != null) {
					var nextTime = current.trackLast - next.delay;
					if (nextTime >= 0) {
						next.delay = 0;
						next.trackTime = nextTime + delta * next.timeScale;
						current.trackTime += currentDelta;
						this.setCurrent(i, next, true);
						while (next.mixingFrom != null) {
							next.mixTime += currentDelta;
							next = next.mixingFrom;
						}
						continue;
					}
				}
				else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
					tracks[i] = null;
					this.queue.end(current);
					this.disposeNext(current);
					continue;
				}
				if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
					var from = current.mixingFrom;
					current.mixingFrom = null;
					while (from != null) {
						this.queue.end(from);
						from = from.mixingFrom;
					}
				}
				current.trackTime += currentDelta;
			}
			this.queue.drain();
		};
		AnimationState.prototype.updateMixingFrom = function (to, delta) {
			var from = to.mixingFrom;
			if (from == null)
				return true;
			var finished = this.updateMixingFrom(from, delta);
			if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {
				if (from.totalAlpha == 0) {
					to.mixingFrom = from.mixingFrom;
					to.interruptAlpha = from.interruptAlpha;
					this.queue.end(from);
				}
				return finished;
			}
			from.animationLast = from.nextAnimationLast;
			from.trackLast = from.nextTrackLast;
			from.trackTime += delta * from.timeScale;
			to.mixTime += delta * to.timeScale;
			return false;
		};
		AnimationState.prototype.apply = function (skeleton) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			if (this.animationsChanged)
				this._animationsChanged();
			var events = this.events;
			var tracks = this.tracks;
			var applied = false;
			for (var i = 0, n = tracks.length; i < n; i++) {
				var current = tracks[i];
				if (current == null || current.delay > 0)
					continue;
				applied = true;
				var currentPose = i == 0 ? spine.MixPose.current : spine.MixPose.currentLayered;
				var mix = current.alpha;
				if (current.mixingFrom != null)
					mix *= this.applyMixingFrom(current, skeleton, currentPose);
				else if (current.trackTime >= current.trackEnd && current.next == null)
					mix = 0;
				var animationLast = current.animationLast, animationTime = current.getAnimationTime();
				var timelineCount = current.animation.timelines.length;
				var timelines = current.animation.timelines;
				if (mix == 1) {
					for (var ii = 0; ii < timelineCount; ii++)
						timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, spine.MixPose.setup, spine.MixDirection.in);
				}
				else {
					var timelineData = current.timelineData;
					var firstFrame = current.timelinesRotation.length == 0;
					if (firstFrame)
						spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
					var timelinesRotation = current.timelinesRotation;
					for (var ii = 0; ii < timelineCount; ii++) {
						var timeline = timelines[ii];
						var pose = timelineData[ii] >= AnimationState.FIRST ? spine.MixPose.setup : currentPose;
						if (timeline instanceof spine.RotateTimeline) {
							this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);
						}
						else
							timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, spine.MixDirection.in);
					}
				}
				this.queueEvents(current, animationTime);
				events.length = 0;
				current.nextAnimationLast = animationTime;
				current.nextTrackLast = current.trackTime;
			}
			this.queue.drain();
			return applied;
		};
		AnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {
			var from = to.mixingFrom;
			if (from.mixingFrom != null)
				this.applyMixingFrom(from, skeleton, currentPose);
			var mix = 0;
			if (to.mixDuration == 0)
				mix = 1;
			else {
				mix = to.mixTime / to.mixDuration;
				if (mix > 1)
					mix = 1;
			}
			var events = mix < from.eventThreshold ? this.events : null;
			var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
			var animationLast = from.animationLast, animationTime = from.getAnimationTime();
			var timelineCount = from.animation.timelines.length;
			var timelines = from.animation.timelines;
			var timelineData = from.timelineData;
			var timelineDipMix = from.timelineDipMix;
			var firstFrame = from.timelinesRotation.length == 0;
			if (firstFrame)
				spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
			var timelinesRotation = from.timelinesRotation;
			var pose;
			var alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;
			from.totalAlpha = 0;
			for (var i = 0; i < timelineCount; i++) {
				var timeline = timelines[i];
				switch (timelineData[i]) {
					case AnimationState.SUBSEQUENT:
						if (!attachments && timeline instanceof spine.AttachmentTimeline)
							continue;
						if (!drawOrder && timeline instanceof spine.DrawOrderTimeline)
							continue;
						pose = currentPose;
						alpha = alphaMix;
						break;
					case AnimationState.FIRST:
						pose = spine.MixPose.setup;
						alpha = alphaMix;
						break;
					case AnimationState.DIP:
						pose = spine.MixPose.setup;
						alpha = alphaDip;
						break;
					default:
						pose = spine.MixPose.setup;
						alpha = alphaDip;
						var dipMix = timelineDipMix[i];
						alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);
						break;
				}
				from.totalAlpha += alpha;
				if (timeline instanceof spine.RotateTimeline)
					this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);
				else {
					timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, spine.MixDirection.out);
				}
			}
			if (to.mixDuration > 0)
				this.queueEvents(from, animationTime);
			this.events.length = 0;
			from.nextAnimationLast = animationTime;
			from.nextTrackLast = from.trackTime;
			return mix;
		};
		AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {
			if (firstFrame)
				timelinesRotation[i] = 0;
			if (alpha == 1) {
				timeline.apply(skeleton, 0, time, null, 1, pose, spine.MixDirection.in);
				return;
			}
			var rotateTimeline = timeline;
			var frames = rotateTimeline.frames;
			var bone = skeleton.bones[rotateTimeline.boneIndex];
			if (time < frames[0]) {
				if (pose == spine.MixPose.setup)
					bone.rotation = bone.data.rotation;
				return;
			}
			var r2 = 0;
			if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])
				r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];
			else {
				var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);
				var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];
				var frameTime = frames[frame];
				var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));
				r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;
				r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
				r2 = prevRotation + r2 * percent + bone.data.rotation;
				r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
			}
			var r1 = pose == spine.MixPose.setup ? bone.data.rotation : bone.rotation;
			var total = 0, diff = r2 - r1;
			if (diff == 0) {
				total = timelinesRotation[i];
			}
			else {
				diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;
				var lastTotal = 0, lastDiff = 0;
				if (firstFrame) {
					lastTotal = 0;
					lastDiff = diff;
				}
				else {
					lastTotal = timelinesRotation[i];
					lastDiff = timelinesRotation[i + 1];
				}
				var current = diff > 0, dir = lastTotal >= 0;
				if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
					if (Math.abs(lastTotal) > 180)
						lastTotal += 360 * spine.MathUtils.signum(lastTotal);
					dir = current;
				}
				total = diff + lastTotal - lastTotal % 360;
				if (dir != current)
					total += 360 * spine.MathUtils.signum(lastTotal);
				timelinesRotation[i] = total;
			}
			timelinesRotation[i + 1] = diff;
			r1 += total * alpha;
			bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;
		};
		AnimationState.prototype.queueEvents = function (entry, animationTime) {
			var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
			var duration = animationEnd - animationStart;
			var trackLastWrapped = entry.trackLast % duration;
			var events = this.events;
			var i = 0, n = events.length;
			for (; i < n; i++) {
				var event_1 = events[i];
				if (event_1.time < trackLastWrapped)
					break;
				if (event_1.time > animationEnd)
					continue;
				this.queue.event(entry, event_1);
			}
			if (entry.loop ? (trackLastWrapped > entry.trackTime % duration)
				: (animationTime >= animationEnd && entry.animationLast < animationEnd)) {
				this.queue.complete(entry);
			}
			for (; i < n; i++) {
				var event_2 = events[i];
				if (event_2.time < animationStart)
					continue;
				this.queue.event(entry, events[i]);
			}
		};
		AnimationState.prototype.clearTracks = function () {
			var oldDrainDisabled = this.queue.drainDisabled;
			this.queue.drainDisabled = true;
			for (var i = 0, n = this.tracks.length; i < n; i++)
				this.clearTrack(i);
			this.tracks.length = 0;
			this.queue.drainDisabled = oldDrainDisabled;
			this.queue.drain();
		};
		AnimationState.prototype.clearTrack = function (trackIndex) {
			if (trackIndex >= this.tracks.length)
				return;
			var current = this.tracks[trackIndex];
			if (current == null)
				return;
			this.queue.end(current);
			this.disposeNext(current);
			var entry = current;
			while (true) {
				var from = entry.mixingFrom;
				if (from == null)
					break;
				this.queue.end(from);
				entry.mixingFrom = null;
				entry = from;
			}
			this.tracks[current.trackIndex] = null;
			this.queue.drain();
		};
		AnimationState.prototype.setCurrent = function (index, current, interrupt) {
			var from = this.expandToIndex(index);
			this.tracks[index] = current;
			if (from != null) {
				if (interrupt)
					this.queue.interrupt(from);
				current.mixingFrom = from;
				current.mixTime = 0;
				if (from.mixingFrom != null && from.mixDuration > 0)
					current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
				from.timelinesRotation.length = 0;
			}
			this.queue.start(current);
		};
		AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {
			var animation = this.data.skeletonData.findAnimation(animationName);
			if (animation == null)
				throw new Error("Animation not found: " + animationName);
			return this.setAnimationWith(trackIndex, animation, loop);
		};
		AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {
			if (animation == null)
				throw new Error("animation cannot be null.");
			var interrupt = true;
			var current = this.expandToIndex(trackIndex);
			if (current != null) {
				if (current.nextTrackLast == -1) {
					this.tracks[trackIndex] = current.mixingFrom;
					this.queue.interrupt(current);
					this.queue.end(current);
					this.disposeNext(current);
					current = current.mixingFrom;
					interrupt = false;
				}
				else
					this.disposeNext(current);
			}
			var entry = this.trackEntry(trackIndex, animation, loop, current);
			this.setCurrent(trackIndex, entry, interrupt);
			this.queue.drain();
			return entry;
		};
		AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {
			var animation = this.data.skeletonData.findAnimation(animationName);
			if (animation == null)
				throw new Error("Animation not found: " + animationName);
			return this.addAnimationWith(trackIndex, animation, loop, delay);
		};
		AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {
			if (animation == null)
				throw new Error("animation cannot be null.");
			var last = this.expandToIndex(trackIndex);
			if (last != null) {
				while (last.next != null)
					last = last.next;
			}
			var entry = this.trackEntry(trackIndex, animation, loop, last);
			if (last == null) {
				this.setCurrent(trackIndex, entry, true);
				this.queue.drain();
			}
			else {
				last.next = entry;
				if (delay <= 0) {
					var duration = last.animationEnd - last.animationStart;
					if (duration != 0)
						delay += duration * (1 + ((last.trackTime / duration) | 0)) - this.data.getMix(last.animation, animation);
					else
						delay = 0;
				}
			}
			entry.delay = delay;
			return entry;
		};
		AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {
			var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
			entry.mixDuration = mixDuration;
			entry.trackEnd = mixDuration;
			return entry;
		};
		AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {
			if (delay <= 0)
				delay -= mixDuration;
			var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
			entry.mixDuration = mixDuration;
			entry.trackEnd = mixDuration;
			return entry;
		};
		AnimationState.prototype.setEmptyAnimations = function (mixDuration) {
			var oldDrainDisabled = this.queue.drainDisabled;
			this.queue.drainDisabled = true;
			for (var i = 0, n = this.tracks.length; i < n; i++) {
				var current = this.tracks[i];
				if (current != null)
					this.setEmptyAnimation(current.trackIndex, mixDuration);
			}
			this.queue.drainDisabled = oldDrainDisabled;
			this.queue.drain();
		};
		AnimationState.prototype.expandToIndex = function (index) {
			if (index < this.tracks.length)
				return this.tracks[index];
			spine.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
			this.tracks.length = index + 1;
			return null;
		};
		AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {
			var entry = this.trackEntryPool.obtain();
			entry.trackIndex = trackIndex;
			entry.animation = animation;
			entry.loop = loop;
			entry.eventThreshold = 0;
			entry.attachmentThreshold = 0;
			entry.drawOrderThreshold = 0;
			entry.animationStart = 0;
			entry.animationEnd = animation.duration;
			entry.animationLast = -1;
			entry.nextAnimationLast = -1;
			entry.delay = 0;
			entry.trackTime = 0;
			entry.trackLast = -1;
			entry.nextTrackLast = -1;
			entry.trackEnd = Number.MAX_VALUE;
			entry.timeScale = 1;
			entry.alpha = 1;
			entry.interruptAlpha = 1;
			entry.mixTime = 0;
			entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
			return entry;
		};
		AnimationState.prototype.disposeNext = function (entry) {
			var next = entry.next;
			while (next != null) {
				this.queue.dispose(next);
				next = next.next;
			}
			entry.next = null;
		};
		AnimationState.prototype._animationsChanged = function () {
			this.animationsChanged = false;
			var propertyIDs = this.propertyIDs;
			propertyIDs.clear();
			var mixingTo = this.mixingTo;
			var lastEntry = null;
			for (var i = 0, n = this.tracks.length; i < n; i++) {
				var entry = this.tracks[i];
				if (entry != null) {
					entry.setTimelineData(lastEntry, mixingTo, propertyIDs);
					lastEntry = entry;
				}
			}
		};
		AnimationState.prototype.getCurrent = function (trackIndex) {
			if (trackIndex >= this.tracks.length)
				return null;
			return this.tracks[trackIndex];
		};
		AnimationState.prototype.addListener = function (listener) {
			if (listener == null)
				throw new Error("listener cannot be null.");
			this.listeners.push(listener);
		};
		AnimationState.prototype.removeListener = function (listener) {
			var index = this.listeners.indexOf(listener);
			if (index >= 0)
				this.listeners.splice(index, 1);
		};
		AnimationState.prototype.clearListeners = function () {
			this.listeners.length = 0;
		};
		AnimationState.prototype.clearListenerNotifications = function () {
			this.queue.clear();
		};
		AnimationState.emptyAnimation = new spine.Animation("<empty>", [], 0);
		AnimationState.SUBSEQUENT = 0;
		AnimationState.FIRST = 1;
		AnimationState.DIP = 2;
		AnimationState.DIP_MIX = 3;
		return AnimationState;
	}());
	spine.AnimationState = AnimationState;
	var TrackEntry = (function () {
		function TrackEntry() {
			this.timelineData = new Array();
			this.timelineDipMix = new Array();
			this.timelinesRotation = new Array();
		}
		TrackEntry.prototype.reset = function () {
			this.next = null;
			this.mixingFrom = null;
			this.animation = null;
			this.listener = null;
			this.timelineData.length = 0;
			this.timelineDipMix.length = 0;
			this.timelinesRotation.length = 0;
		};
		TrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {
			if (to != null)
				mixingToArray.push(to);
			var lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;
			if (to != null)
				mixingToArray.pop();
			var mixingTo = mixingToArray;
			var mixingToLast = mixingToArray.length - 1;
			var timelines = this.animation.timelines;
			var timelinesCount = this.animation.timelines.length;
			var timelineData = spine.Utils.setArraySize(this.timelineData, timelinesCount);
			this.timelineDipMix.length = 0;
			var timelineDipMix = spine.Utils.setArraySize(this.timelineDipMix, timelinesCount);
			outer: for (var i = 0; i < timelinesCount; i++) {
				var id = timelines[i].getPropertyId();
				if (!propertyIDs.add(id))
					timelineData[i] = AnimationState.SUBSEQUENT;
				else if (to == null || !to.hasTimeline(id))
					timelineData[i] = AnimationState.FIRST;
				else {
					for (var ii = mixingToLast; ii >= 0; ii--) {
						var entry = mixingTo[ii];
						if (!entry.hasTimeline(id)) {
							if (entry.mixDuration > 0) {
								timelineData[i] = AnimationState.DIP_MIX;
								timelineDipMix[i] = entry;
								continue outer;
							}
						}
					}
					timelineData[i] = AnimationState.DIP;
				}
			}
			return lastEntry;
		};
		TrackEntry.prototype.hasTimeline = function (id) {
			var timelines = this.animation.timelines;
			for (var i = 0, n = timelines.length; i < n; i++)
				if (timelines[i].getPropertyId() == id)
					return true;
			return false;
		};
		TrackEntry.prototype.getAnimationTime = function () {
			if (this.loop) {
				var duration = this.animationEnd - this.animationStart;
				if (duration == 0)
					return this.animationStart;
				return (this.trackTime % duration) + this.animationStart;
			}
			return Math.min(this.trackTime + this.animationStart, this.animationEnd);
		};
		TrackEntry.prototype.setAnimationLast = function (animationLast) {
			this.animationLast = animationLast;
			this.nextAnimationLast = animationLast;
		};
		TrackEntry.prototype.isComplete = function () {
			return this.trackTime >= this.animationEnd - this.animationStart;
		};
		TrackEntry.prototype.resetRotationDirections = function () {
			this.timelinesRotation.length = 0;
		};
		return TrackEntry;
	}());
	spine.TrackEntry = TrackEntry;
	var EventQueue = (function () {
		function EventQueue(animState) {
			this.objects = [];
			this.drainDisabled = false;
			this.animState = animState;
		}
		EventQueue.prototype.start = function (entry) {
			this.objects.push(EventType.start);
			this.objects.push(entry);
			this.animState.animationsChanged = true;
		};
		EventQueue.prototype.interrupt = function (entry) {
			this.objects.push(EventType.interrupt);
			this.objects.push(entry);
		};
		EventQueue.prototype.end = function (entry) {
			this.objects.push(EventType.end);
			this.objects.push(entry);
			this.animState.animationsChanged = true;
		};
		EventQueue.prototype.dispose = function (entry) {
			this.objects.push(EventType.dispose);
			this.objects.push(entry);
		};
		EventQueue.prototype.complete = function (entry) {
			this.objects.push(EventType.complete);
			this.objects.push(entry);
		};
		EventQueue.prototype.event = function (entry, event) {
			this.objects.push(EventType.event);
			this.objects.push(entry);
			this.objects.push(event);
		};
		EventQueue.prototype.drain = function () {
			if (this.drainDisabled)
				return;
			this.drainDisabled = true;
			var objects = this.objects;
			var listeners = this.animState.listeners;
			for (var i = 0; i < objects.length; i += 2) {
				var type = objects[i];
				var entry = objects[i + 1];
				switch (type) {
					case EventType.start:
						if (entry.listener != null && entry.listener.start)
							entry.listener.start(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].start)
								listeners[ii].start(entry);
						break;
					case EventType.interrupt:
						if (entry.listener != null && entry.listener.interrupt)
							entry.listener.interrupt(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].interrupt)
								listeners[ii].interrupt(entry);
						break;
					case EventType.end:
						if (entry.listener != null && entry.listener.end)
							entry.listener.end(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].end)
								listeners[ii].end(entry);
					case EventType.dispose:
						if (entry.listener != null && entry.listener.dispose)
							entry.listener.dispose(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].dispose)
								listeners[ii].dispose(entry);
						this.animState.trackEntryPool.free(entry);
						break;
					case EventType.complete:
						if (entry.listener != null && entry.listener.complete)
							entry.listener.complete(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].complete)
								listeners[ii].complete(entry);
						break;
					case EventType.event:
						var event_3 = objects[i++ + 2];
						if (entry.listener != null && entry.listener.event)
							entry.listener.event(entry, event_3);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].event)
								listeners[ii].event(entry, event_3);
						break;
				}
			}
			this.clear();
			this.drainDisabled = false;
		};
		EventQueue.prototype.clear = function () {
			this.objects.length = 0;
		};
		return EventQueue;
	}());
	spine.EventQueue = EventQueue;
	(function (EventType) {
		EventType[EventType["start"] = 0] = "start";
		EventType[EventType["interrupt"] = 1] = "interrupt";
		EventType[EventType["end"] = 2] = "end";
		EventType[EventType["dispose"] = 3] = "dispose";
		EventType[EventType["complete"] = 4] = "complete";
		EventType[EventType["event"] = 5] = "event";
	})(spine.EventType || (spine.EventType = {}));
	var EventType = spine.EventType;
	var AnimationStateAdapter2 = (function () {
		function AnimationStateAdapter2() {
		}
		AnimationStateAdapter2.prototype.start = function (entry) {
		};
		AnimationStateAdapter2.prototype.interrupt = function (entry) {
		};
		AnimationStateAdapter2.prototype.end = function (entry) {
		};
		AnimationStateAdapter2.prototype.dispose = function (entry) {
		};
		AnimationStateAdapter2.prototype.complete = function (entry) {
		};
		AnimationStateAdapter2.prototype.event = function (entry, event) {
		};
		return AnimationStateAdapter2;
	}());
	spine.AnimationStateAdapter2 = AnimationStateAdapter2;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AnimationStateData = (function () {
		function AnimationStateData(skeletonData) {
			this.animationToMixTime = {};
			this.defaultMix = 0;
			if (skeletonData == null)
				throw new Error("skeletonData cannot be null.");
			this.skeletonData = skeletonData;
		}
		AnimationStateData.prototype.setMix = function (fromName, toName, duration) {
			var from = this.skeletonData.findAnimation(fromName);
			if (from == null)
				throw new Error("Animation not found: " + fromName);
			var to = this.skeletonData.findAnimation(toName);
			if (to == null)
				throw new Error("Animation not found: " + toName);
			this.setMixWith(from, to, duration);
		};
		AnimationStateData.prototype.setMixWith = function (from, to, duration) {
			if (from == null)
				throw new Error("from cannot be null.");
			if (to == null)
				throw new Error("to cannot be null.");
			var key = from.name + to.name;
			this.animationToMixTime[key] = duration;
		};
		AnimationStateData.prototype.getMix = function (from, to) {
			var key = from.name + to.name;
			var value = this.animationToMixTime[key];
			return value === undefined ? this.defaultMix : value;
		};
		return AnimationStateData;
	}());
	spine.AnimationStateData = AnimationStateData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AssetManager = (function () {
		function AssetManager(textureLoader, pathPrefix) {
			if (pathPrefix === void 0) { pathPrefix = ""; }
			this.assets = {};
			this.errors = {};
			this.toLoad = 0;
			this.loaded = 0;
			this.textureLoader = textureLoader;
			this.pathPrefix = pathPrefix;
		}
		AssetManager.prototype.loadText = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			this.toLoad++;
			var request = new XMLHttpRequest();
			request.onreadystatechange = function () {
				if (request.readyState == XMLHttpRequest.DONE) {
					if (request.status >= 200 && request.status < 300) {
						_this.assets[path] = request.responseText;
						if (success)
							success(path, request.responseText);
					}
					else {
						_this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
						if (error)
							error(path, "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
					}
					_this.toLoad--;
					_this.loaded++;
				}
			};
			request.open("GET", path, true);
			request.send();
		};
		AssetManager.prototype.loadTexture = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			this.toLoad++;
			var img = new Image();
			img.crossOrigin = "anonymous";
			img.onload = function (ev) {
				var texture = _this.textureLoader(img);
				_this.assets[path] = texture;
				_this.toLoad--;
				_this.loaded++;
				if (success)
					success(path, img);
			};
			img.onerror = function (ev) {
				_this.errors[path] = "Couldn't load image " + path;
				_this.toLoad--;
				_this.loaded++;
				if (error)
					error(path, "Couldn't load image " + path);
			};
			img.src = path;
		};
		AssetManager.prototype.loadTextureData = function (path, data, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			this.toLoad++;
			var img = new Image();
			img.onload = function (ev) {
				var texture = _this.textureLoader(img);
				_this.assets[path] = texture;
				_this.toLoad--;
				_this.loaded++;
				if (success)
					success(path, img);
			};
			img.onerror = function (ev) {
				_this.errors[path] = "Couldn't load image " + path;
				_this.toLoad--;
				_this.loaded++;
				if (error)
					error(path, "Couldn't load image " + path);
			};
			img.src = data;
		};
		AssetManager.prototype.get = function (path) {
			path = this.pathPrefix + path;
			return this.assets[path];
		};
		AssetManager.prototype.remove = function (path) {
			path = this.pathPrefix + path;
			var asset = this.assets[path];
			if (asset.dispose)
				asset.dispose();
			this.assets[path] = null;
		};
		AssetManager.prototype.removeAll = function () {
			for (var key in this.assets) {
				var asset = this.assets[key];
				if (asset.dispose)
					asset.dispose();
			}
			this.assets = {};
		};
		AssetManager.prototype.isLoadingComplete = function () {
			return this.toLoad == 0;
		};
		AssetManager.prototype.getToLoad = function () {
			return this.toLoad;
		};
		AssetManager.prototype.getLoaded = function () {
			return this.loaded;
		};
		AssetManager.prototype.dispose = function () {
			this.removeAll();
		};
		AssetManager.prototype.hasErrors = function () {
			return Object.keys(this.errors).length > 0;
		};
		AssetManager.prototype.getErrors = function () {
			return this.errors;
		};
		return AssetManager;
	}());
	spine.AssetManager = AssetManager;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AtlasAttachmentLoader = (function () {
		function AtlasAttachmentLoader(atlas) {
			this.atlas = atlas;
		}
		AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {
			var region = this.atlas.findRegion(path);
			if (region == null)
				throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
			region.renderObject = region;
			var attachment = new spine.RegionAttachment(name);
			attachment.setRegion(region);
			return attachment;
		};
		AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {
			var region = this.atlas.findRegion(path);
			if (region == null)
				throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
			region.renderObject = region;
			var attachment = new spine.MeshAttachment(name);
			attachment.region = region;
			return attachment;
		};
		AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {
			return new spine.BoundingBoxAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {
			return new spine.PathAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {
			return new spine.PointAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {
			return new spine.ClippingAttachment(name);
		};
		return AtlasAttachmentLoader;
	}());
	spine.AtlasAttachmentLoader = AtlasAttachmentLoader;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Attachment = (function () {
		function Attachment(name) {
			if (name == null)
				throw new Error("name cannot be null.");
			this.name = name;
		}
		return Attachment;
	}());
	spine.Attachment = Attachment;
	var VertexAttachment = (function (_super) {
		__extends(VertexAttachment, _super);
		function VertexAttachment(name) {
			_super.call(this, name);
			this.id = (VertexAttachment.nextID++ & 65535) << 11;
			this.worldVerticesLength = 0;
		}
		VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {
			count = offset + (count >> 1) * stride;
			var skeleton = slot.bone.skeleton;
			var deformArray = slot.attachmentVertices;
			var vertices = this.vertices;
			var bones = this.bones;
			if (bones == null) {
				if (deformArray.length > 0)
					vertices = deformArray;
				var bone = slot.bone;
				var x = bone.worldX;
				var y = bone.worldY;
				var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
				for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
					var vx = vertices[v_1], vy = vertices[v_1 + 1];
					worldVertices[w] = vx * a + vy * b + x;
					worldVertices[w + 1] = vx * c + vy * d + y;
				}
				return;
			}
			var v = 0, skip = 0;
			for (var i = 0; i < start; i += 2) {
				var n = bones[v];
				v += n + 1;
				skip += n;
			}
			var skeletonBones = skeleton.bones;
			if (deformArray.length == 0) {
				for (var w = offset, b = skip * 3; w < count; w += stride) {
					var wx = 0, wy = 0;
					var n = bones[v++];
					n += v;
					for (; v < n; v++, b += 3) {
						var bone = skeletonBones[bones[v]];
						var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
						wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
						wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
					}
					worldVertices[w] = wx;
					worldVertices[w + 1] = wy;
				}
			}
			else {
				var deform = deformArray;
				for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
					var wx = 0, wy = 0;
					var n = bones[v++];
					n += v;
					for (; v < n; v++, b += 3, f += 2) {
						var bone = skeletonBones[bones[v]];
						var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
						wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
						wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
					}
					worldVertices[w] = wx;
					worldVertices[w + 1] = wy;
				}
			}
		};
		VertexAttachment.prototype.applyDeform = function (sourceAttachment) {
			return this == sourceAttachment;
		};
		VertexAttachment.nextID = 0;
		return VertexAttachment;
	}(Attachment));
	spine.VertexAttachment = VertexAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	(function (AttachmentType) {
		AttachmentType[AttachmentType["Region"] = 0] = "Region";
		AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
		AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
		AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
		AttachmentType[AttachmentType["Path"] = 4] = "Path";
		AttachmentType[AttachmentType["Point"] = 5] = "Point";
	})(spine.AttachmentType || (spine.AttachmentType = {}));
	var AttachmentType = spine.AttachmentType;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var BoundingBoxAttachment = (function (_super) {
		__extends(BoundingBoxAttachment, _super);
		function BoundingBoxAttachment(name) {
			_super.call(this, name);
			this.color = new spine.Color(1, 1, 1, 1);
		}
		return BoundingBoxAttachment;
	}(spine.VertexAttachment));
	spine.BoundingBoxAttachment = BoundingBoxAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var ClippingAttachment = (function (_super) {
		__extends(ClippingAttachment, _super);
		function ClippingAttachment(name) {
			_super.call(this, name);
			this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);
		}
		return ClippingAttachment;
	}(spine.VertexAttachment));
	spine.ClippingAttachment = ClippingAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var MeshAttachment = (function (_super) {
		__extends(MeshAttachment, _super);
		function MeshAttachment(name) {
			_super.call(this, name);
			this.color = new spine.Color(1, 1, 1, 1);
			this.inheritDeform = false;
			this.tempColor = new spine.Color(0, 0, 0, 0);
		}
		MeshAttachment.prototype.updateUVs = function () {
			var u = 0, v = 0, width = 0, height = 0;
			if (this.region == null) {
				u = v = 0;
				width = height = 1;
			}
			else {
				u = this.region.u;
				v = this.region.v;
				width = this.region.u2 - u;
				height = this.region.v2 - v;
			}
			var regionUVs = this.regionUVs;
			if (this.uvs == null || this.uvs.length != regionUVs.length)
				this.uvs = spine.Utils.newFloatArray(regionUVs.length);
			var uvs = this.uvs;
			if (this.region.rotate) {
				for (var i = 0, n = uvs.length; i < n; i += 2) {
					uvs[i] = u + regionUVs[i + 1] * width;
					uvs[i + 1] = v + height - regionUVs[i] * height;
				}
			}
			else {
				for (var i = 0, n = uvs.length; i < n; i += 2) {
					uvs[i] = u + regionUVs[i] * width;
					uvs[i + 1] = v + regionUVs[i + 1] * height;
				}
			}
		};
		MeshAttachment.prototype.applyDeform = function (sourceAttachment) {
			return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);
		};
		MeshAttachment.prototype.getParentMesh = function () {
			return this.parentMesh;
		};
		MeshAttachment.prototype.setParentMesh = function (parentMesh) {
			this.parentMesh = parentMesh;
			if (parentMesh != null) {
				this.bones = parentMesh.bones;
				this.vertices = parentMesh.vertices;
				this.worldVerticesLength = parentMesh.worldVerticesLength;
				this.regionUVs = parentMesh.regionUVs;
				this.triangles = parentMesh.triangles;
				this.hullLength = parentMesh.hullLength;
				this.worldVerticesLength = parentMesh.worldVerticesLength;
			}
		};
		return MeshAttachment;
	}(spine.VertexAttachment));
	spine.MeshAttachment = MeshAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathAttachment = (function (_super) {
		__extends(PathAttachment, _super);
		function PathAttachment(name) {
			_super.call(this, name);
			this.closed = false;
			this.constantSpeed = false;
			this.color = new spine.Color(1, 1, 1, 1);
		}
		return PathAttachment;
	}(spine.VertexAttachment));
	spine.PathAttachment = PathAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PointAttachment = (function (_super) {
		__extends(PointAttachment, _super);
		function PointAttachment(name) {
			_super.call(this, name);
			this.color = new spine.Color(0.38, 0.94, 0, 1);
		}
		PointAttachment.prototype.computeWorldPosition = function (bone, point) {
			point.x = this.x * bone.a + this.y * bone.b + bone.worldX;
			point.y = this.x * bone.c + this.y * bone.d + bone.worldY;
			return point;
		};
		PointAttachment.prototype.computeWorldRotation = function (bone) {
			var cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);
			var x = cos * bone.a + sin * bone.b;
			var y = cos * bone.c + sin * bone.d;
			return Math.atan2(y, x) * spine.MathUtils.radDeg;
		};
		return PointAttachment;
	}(spine.VertexAttachment));
	spine.PointAttachment = PointAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var RegionAttachment = (function (_super) {
		__extends(RegionAttachment, _super);
		function RegionAttachment(name) {
			_super.call(this, name);
			this.x = 0;
			this.y = 0;
			this.scaleX = 1;
			this.scaleY = 1;
			this.rotation = 0;
			this.width = 0;
			this.height = 0;
			this.color = new spine.Color(1, 1, 1, 1);
			this.offset = spine.Utils.newFloatArray(8);
			this.uvs = spine.Utils.newFloatArray(8);
			this.tempColor = new spine.Color(1, 1, 1, 1);
		}
		RegionAttachment.prototype.updateOffset = function () {
			var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
			var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
			var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
			var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
			var localX2 = localX + this.region.width * regionScaleX;
			var localY2 = localY + this.region.height * regionScaleY;
			var radians = this.rotation * Math.PI / 180;
			var cos = Math.cos(radians);
			var sin = Math.sin(radians);
			var localXCos = localX * cos + this.x;
			var localXSin = localX * sin;
			var localYCos = localY * cos + this.y;
			var localYSin = localY * sin;
			var localX2Cos = localX2 * cos + this.x;
			var localX2Sin = localX2 * sin;
			var localY2Cos = localY2 * cos + this.y;
			var localY2Sin = localY2 * sin;
			var offset = this.offset;
			offset[RegionAttachment.OX1] = localXCos - localYSin;
			offset[RegionAttachment.OY1] = localYCos + localXSin;
			offset[RegionAttachment.OX2] = localXCos - localY2Sin;
			offset[RegionAttachment.OY2] = localY2Cos + localXSin;
			offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
			offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
			offset[RegionAttachment.OX4] = localX2Cos - localYSin;
			offset[RegionAttachment.OY4] = localYCos + localX2Sin;
		};
		RegionAttachment.prototype.setRegion = function (region) {
			this.region = region;
			var uvs = this.uvs;
			if (region.rotate) {
				uvs[2] = region.u;
				uvs[3] = region.v2;
				uvs[4] = region.u;
				uvs[5] = region.v;
				uvs[6] = region.u2;
				uvs[7] = region.v;
				uvs[0] = region.u2;
				uvs[1] = region.v2;
			}
			else {
				uvs[0] = region.u;
				uvs[1] = region.v2;
				uvs[2] = region.u;
				uvs[3] = region.v;
				uvs[4] = region.u2;
				uvs[5] = region.v;
				uvs[6] = region.u2;
				uvs[7] = region.v2;
			}
		};
		RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {
			var vertexOffset = this.offset;
			var x = bone.worldX, y = bone.worldY;
			var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
			var offsetX = 0, offsetY = 0;
			offsetX = vertexOffset[RegionAttachment.OX1];
			offsetY = vertexOffset[RegionAttachment.OY1];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX2];
			offsetY = vertexOffset[RegionAttachment.OY2];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX3];
			offsetY = vertexOffset[RegionAttachment.OY3];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX4];
			offsetY = vertexOffset[RegionAttachment.OY4];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
		};
		RegionAttachment.OX1 = 0;
		RegionAttachment.OY1 = 1;
		RegionAttachment.OX2 = 2;
		RegionAttachment.OY2 = 3;
		RegionAttachment.OX3 = 4;
		RegionAttachment.OY3 = 5;
		RegionAttachment.OX4 = 6;
		RegionAttachment.OY4 = 7;
		RegionAttachment.X1 = 0;
		RegionAttachment.Y1 = 1;
		RegionAttachment.C1R = 2;
		RegionAttachment.C1G = 3;
		RegionAttachment.C1B = 4;
		RegionAttachment.C1A = 5;
		RegionAttachment.U1 = 6;
		RegionAttachment.V1 = 7;
		RegionAttachment.X2 = 8;
		RegionAttachment.Y2 = 9;
		RegionAttachment.C2R = 10;
		RegionAttachment.C2G = 11;
		RegionAttachment.C2B = 12;
		RegionAttachment.C2A = 13;
		RegionAttachment.U2 = 14;
		RegionAttachment.V2 = 15;
		RegionAttachment.X3 = 16;
		RegionAttachment.Y3 = 17;
		RegionAttachment.C3R = 18;
		RegionAttachment.C3G = 19;
		RegionAttachment.C3B = 20;
		RegionAttachment.C3A = 21;
		RegionAttachment.U3 = 22;
		RegionAttachment.V3 = 23;
		RegionAttachment.X4 = 24;
		RegionAttachment.Y4 = 25;
		RegionAttachment.C4R = 26;
		RegionAttachment.C4G = 27;
		RegionAttachment.C4B = 28;
		RegionAttachment.C4A = 29;
		RegionAttachment.U4 = 30;
		RegionAttachment.V4 = 31;
		return RegionAttachment;
	}(spine.Attachment));
	spine.RegionAttachment = RegionAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	(function (BlendMode) {
		BlendMode[BlendMode["Normal"] = 0] = "Normal";
		BlendMode[BlendMode["Additive"] = 1] = "Additive";
		BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
		BlendMode[BlendMode["Screen"] = 3] = "Screen";
	})(spine.BlendMode || (spine.BlendMode = {}));
	var BlendMode = spine.BlendMode;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Bone = (function () {
		function Bone(data, skeleton, parent) {
			this.children = new Array();
			this.x = 0;
			this.y = 0;
			this.rotation = 0;
			this.scaleX = 0;
			this.scaleY = 0;
			this.shearX = 0;
			this.shearY = 0;
			this.ax = 0;
			this.ay = 0;
			this.arotation = 0;
			this.ascaleX = 0;
			this.ascaleY = 0;
			this.ashearX = 0;
			this.ashearY = 0;
			this.appliedValid = false;
			this.a = 0;
			this.b = 0;
			this.worldX = 0;
			this.c = 0;
			this.d = 0;
			this.worldY = 0;
			this.sorted = false;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.skeleton = skeleton;
			this.parent = parent;
			this.setToSetupPose();
		}
		Bone.prototype.update = function () {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		Bone.prototype.updateWorldTransform = function () {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
			this.ax = x;
			this.ay = y;
			this.arotation = rotation;
			this.ascaleX = scaleX;
			this.ascaleY = scaleY;
			this.ashearX = shearX;
			this.ashearY = shearY;
			this.appliedValid = true;
			var parent = this.parent;
			if (parent == null) {
				var rotationY = rotation + 90 + shearY;
				var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
				var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
				var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
				var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
				var skeleton = this.skeleton;
				if (skeleton.flipX) {
					x = -x;
					la = -la;
					lb = -lb;
				}
				if (skeleton.flipY) {
					y = -y;
					lc = -lc;
					ld = -ld;
				}
				this.a = la;
				this.b = lb;
				this.c = lc;
				this.d = ld;
				this.worldX = x + skeleton.x;
				this.worldY = y + skeleton.y;
				return;
			}
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			this.worldX = pa * x + pb * y + parent.worldX;
			this.worldY = pc * x + pd * y + parent.worldY;
			switch (this.data.transformMode) {
				case spine.TransformMode.Normal: {
					var rotationY = rotation + 90 + shearY;
					var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
					var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
					var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
					var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
					this.a = pa * la + pb * lc;
					this.b = pa * lb + pb * ld;
					this.c = pc * la + pd * lc;
					this.d = pc * lb + pd * ld;
					return;
				}
				case spine.TransformMode.OnlyTranslation: {
					var rotationY = rotation + 90 + shearY;
					this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
					this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;
					this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
					this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;
					break;
				}
				case spine.TransformMode.NoRotationOrReflection: {
					var s = pa * pa + pc * pc;
					var prx = 0;
					if (s > 0.0001) {
						s = Math.abs(pa * pd - pb * pc) / s;
						pb = pc * s;
						pd = pa * s;
						prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;
					}
					else {
						pa = 0;
						pc = 0;
						prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;
					}
					var rx = rotation + shearX - prx;
					var ry = rotation + shearY - prx + 90;
					var la = spine.MathUtils.cosDeg(rx) * scaleX;
					var lb = spine.MathUtils.cosDeg(ry) * scaleY;
					var lc = spine.MathUtils.sinDeg(rx) * scaleX;
					var ld = spine.MathUtils.sinDeg(ry) * scaleY;
					this.a = pa * la - pb * lc;
					this.b = pa * lb - pb * ld;
					this.c = pc * la + pd * lc;
					this.d = pc * lb + pd * ld;
					break;
				}
				case spine.TransformMode.NoScale:
				case spine.TransformMode.NoScaleOrReflection: {
					var cos = spine.MathUtils.cosDeg(rotation);
					var sin = spine.MathUtils.sinDeg(rotation);
					var za = pa * cos + pb * sin;
					var zc = pc * cos + pd * sin;
					var s = Math.sqrt(za * za + zc * zc);
					if (s > 0.00001)
						s = 1 / s;
					za *= s;
					zc *= s;
					s = Math.sqrt(za * za + zc * zc);
					var r = Math.PI / 2 + Math.atan2(zc, za);
					var zb = Math.cos(r) * s;
					var zd = Math.sin(r) * s;
					var la = spine.MathUtils.cosDeg(shearX) * scaleX;
					var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;
					var lc = spine.MathUtils.sinDeg(shearX) * scaleX;
					var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;
					this.a = za * la + zb * lc;
					this.b = za * lb + zb * ld;
					this.c = zc * la + zd * lc;
					this.d = zc * lb + zd * ld;
					if (this.data.transformMode != spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY) {
						this.b = -this.b;
						this.d = -this.d;
					}
					return;
				}
			}
			if (this.skeleton.flipX) {
				this.a = -this.a;
				this.b = -this.b;
			}
			if (this.skeleton.flipY) {
				this.c = -this.c;
				this.d = -this.d;
			}
		};
		Bone.prototype.setToSetupPose = function () {
			var data = this.data;
			this.x = data.x;
			this.y = data.y;
			this.rotation = data.rotation;
			this.scaleX = data.scaleX;
			this.scaleY = data.scaleY;
			this.shearX = data.shearX;
			this.shearY = data.shearY;
		};
		Bone.prototype.getWorldRotationX = function () {
			return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
		};
		Bone.prototype.getWorldRotationY = function () {
			return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;
		};
		Bone.prototype.getWorldScaleX = function () {
			return Math.sqrt(this.a * this.a + this.c * this.c);
		};
		Bone.prototype.getWorldScaleY = function () {
			return Math.sqrt(this.b * this.b + this.d * this.d);
		};
		Bone.prototype.updateAppliedTransform = function () {
			this.appliedValid = true;
			var parent = this.parent;
			if (parent == null) {
				this.ax = this.worldX;
				this.ay = this.worldY;
				this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
				this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
				this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
				this.ashearX = 0;
				this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;
				return;
			}
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			var pid = 1 / (pa * pd - pb * pc);
			var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
			this.ax = (dx * pd * pid - dy * pb * pid);
			this.ay = (dy * pa * pid - dx * pc * pid);
			var ia = pid * pd;
			var id = pid * pa;
			var ib = pid * pb;
			var ic = pid * pc;
			var ra = ia * this.a - ib * this.c;
			var rb = ia * this.b - ib * this.d;
			var rc = id * this.c - ic * this.a;
			var rd = id * this.d - ic * this.b;
			this.ashearX = 0;
			this.ascaleX = Math.sqrt(ra * ra + rc * rc);
			if (this.ascaleX > 0.0001) {
				var det = ra * rd - rb * rc;
				this.ascaleY = det / this.ascaleX;
				this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;
				this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;
			}
			else {
				this.ascaleX = 0;
				this.ascaleY = Math.sqrt(rb * rb + rd * rd);
				this.ashearY = 0;
				this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;
			}
		};
		Bone.prototype.worldToLocal = function (world) {
			var a = this.a, b = this.b, c = this.c, d = this.d;
			var invDet = 1 / (a * d - b * c);
			var x = world.x - this.worldX, y = world.y - this.worldY;
			world.x = (x * d * invDet - y * b * invDet);
			world.y = (y * a * invDet - x * c * invDet);
			return world;
		};
		Bone.prototype.localToWorld = function (local) {
			var x = local.x, y = local.y;
			local.x = x * this.a + y * this.b + this.worldX;
			local.y = x * this.c + y * this.d + this.worldY;
			return local;
		};
		Bone.prototype.worldToLocalRotation = function (worldRotation) {
			var sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);
			return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg;
		};
		Bone.prototype.localToWorldRotation = function (localRotation) {
			var sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);
			return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;
		};
		Bone.prototype.rotateWorld = function (degrees) {
			var a = this.a, b = this.b, c = this.c, d = this.d;
			var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);
			this.a = cos * a - sin * c;
			this.b = cos * b - sin * d;
			this.c = sin * a + cos * c;
			this.d = sin * b + cos * d;
			this.appliedValid = false;
		};
		return Bone;
	}());
	spine.Bone = Bone;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var BoneData = (function () {
		function BoneData(index, name, parent) {
			this.x = 0;
			this.y = 0;
			this.rotation = 0;
			this.scaleX = 1;
			this.scaleY = 1;
			this.shearX = 0;
			this.shearY = 0;
			this.transformMode = TransformMode.Normal;
			if (index < 0)
				throw new Error("index must be >= 0.");
			if (name == null)
				throw new Error("name cannot be null.");
			this.index = index;
			this.name = name;
			this.parent = parent;
		}
		return BoneData;
	}());
	spine.BoneData = BoneData;
	(function (TransformMode) {
		TransformMode[TransformMode["Normal"] = 0] = "Normal";
		TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
		TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
		TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
		TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
	})(spine.TransformMode || (spine.TransformMode = {}));
	var TransformMode = spine.TransformMode;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Event = (function () {
		function Event(time, data) {
			if (data == null)
				throw new Error("data cannot be null.");
			this.time = time;
			this.data = data;
		}
		return Event;
	}());
	spine.Event = Event;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var EventData = (function () {
		function EventData(name) {
			this.name = name;
		}
		return EventData;
	}());
	spine.EventData = EventData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IkConstraint = (function () {
		function IkConstraint(data, skeleton) {
			this.mix = 1;
			this.bendDirection = 0;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.mix = data.mix;
			this.bendDirection = data.bendDirection;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findBone(data.target.name);
		}
		IkConstraint.prototype.getOrder = function () {
			return this.data.order;
		};
		IkConstraint.prototype.apply = function () {
			this.update();
		};
		IkConstraint.prototype.update = function () {
			var target = this.target;
			var bones = this.bones;
			switch (bones.length) {
				case 1:
					this.apply1(bones[0], target.worldX, target.worldY, this.mix);
					break;
				case 2:
					this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
					break;
			}
		};
		IkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {
			if (!bone.appliedValid)
				bone.updateAppliedTransform();
			var p = bone.parent;
			var id = 1 / (p.a * p.d - p.b * p.c);
			var x = targetX - p.worldX, y = targetY - p.worldY;
			var tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;
			var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;
			if (bone.ascaleX < 0)
				rotationIK += 180;
			if (rotationIK > 180)
				rotationIK -= 360;
			else if (rotationIK < -180)
				rotationIK += 360;
			bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);
		};
		IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {
			if (alpha == 0) {
				child.updateWorldTransform();
				return;
			}
			if (!parent.appliedValid)
				parent.updateAppliedTransform();
			if (!child.appliedValid)
				child.updateAppliedTransform();
			var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;
			var os1 = 0, os2 = 0, s2 = 0;
			if (psx < 0) {
				psx = -psx;
				os1 = 180;
				s2 = -1;
			}
			else {
				os1 = 0;
				s2 = 1;
			}
			if (psy < 0) {
				psy = -psy;
				s2 = -s2;
			}
			if (csx < 0) {
				csx = -csx;
				os2 = 180;
			}
			else
				os2 = 0;
			var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;
			var u = Math.abs(psx - psy) <= 0.0001;
			if (!u) {
				cy = 0;
				cwx = a * cx + parent.worldX;
				cwy = c * cx + parent.worldY;
			}
			else {
				cy = child.ay;
				cwx = a * cx + b * cy + parent.worldX;
				cwy = c * cx + d * cy + parent.worldY;
			}
			var pp = parent.parent;
			a = pp.a;
			b = pp.b;
			c = pp.c;
			d = pp.d;
			var id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;
			var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
			x = cwx - pp.worldX;
			y = cwy - pp.worldY;
			var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
			var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;
			outer: if (u) {
				l2 *= psx;
				var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
				if (cos < -1)
					cos = -1;
				else if (cos > 1)
					cos = 1;
				a2 = Math.acos(cos) * bendDir;
				a = l1 + l2 * cos;
				b = l2 * Math.sin(a2);
				a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
			}
			else {
				a = psx * l2;
				b = psy * l2;
				var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
				c = bb * l1 * l1 + aa * dd - aa * bb;
				var c1 = -2 * bb * l1, c2 = bb - aa;
				d = c1 * c1 - 4 * c2 * c;
				if (d >= 0) {
					var q = Math.sqrt(d);
					if (c1 < 0)
						q = -q;
					q = -(c1 + q) / 2;
					var r0 = q / c2, r1 = c / q;
					var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
					if (r * r <= dd) {
						y = Math.sqrt(dd - r * r) * bendDir;
						a1 = ta - Math.atan2(y, r);
						a2 = Math.atan2(y / psy, (r - l1) / psx);
						break outer;
					}
				}
				var minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
				var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
				c = -a * l1 / (aa - bb);
				if (c >= -1 && c <= 1) {
					c = Math.acos(c);
					x = a * Math.cos(c) + l1;
					y = b * Math.sin(c);
					d = x * x + y * y;
					if (d < minDist) {
						minAngle = c;
						minDist = d;
						minX = x;
						minY = y;
					}
					if (d > maxDist) {
						maxAngle = c;
						maxDist = d;
						maxX = x;
						maxY = y;
					}
				}
				if (dd <= (minDist + maxDist) / 2) {
					a1 = ta - Math.atan2(minY * bendDir, minX);
					a2 = minAngle * bendDir;
				}
				else {
					a1 = ta - Math.atan2(maxY * bendDir, maxX);
					a2 = maxAngle * bendDir;
				}
			}
			var os = Math.atan2(cy, cx) * s2;
			var rotation = parent.arotation;
			a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;
			if (a1 > 180)
				a1 -= 360;
			else if (a1 < -180)
				a1 += 360;
			parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);
			rotation = child.arotation;
			a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
			if (a2 > 180)
				a2 -= 360;
			else if (a2 < -180)
				a2 += 360;
			child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
		};
		return IkConstraint;
	}());
	spine.IkConstraint = IkConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IkConstraintData = (function () {
		function IkConstraintData(name) {
			this.order = 0;
			this.bones = new Array();
			this.bendDirection = 1;
			this.mix = 1;
			this.name = name;
		}
		return IkConstraintData;
	}());
	spine.IkConstraintData = IkConstraintData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathConstraint = (function () {
		function PathConstraint(data, skeleton) {
			this.position = 0;
			this.spacing = 0;
			this.rotateMix = 0;
			this.translateMix = 0;
			this.spaces = new Array();
			this.positions = new Array();
			this.world = new Array();
			this.curves = new Array();
			this.lengths = new Array();
			this.segments = new Array();
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.bones = new Array();
			for (var i = 0, n = data.bones.length; i < n; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findSlot(data.target.name);
			this.position = data.position;
			this.spacing = data.spacing;
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
		}
		PathConstraint.prototype.apply = function () {
			this.update();
		};
		PathConstraint.prototype.update = function () {
			var attachment = this.target.getAttachment();
			if (!(attachment instanceof spine.PathAttachment))
				return;
			var rotateMix = this.rotateMix, translateMix = this.translateMix;
			var translate = translateMix > 0, rotate = rotateMix > 0;
			if (!translate && !rotate)
				return;
			var data = this.data;
			var spacingMode = data.spacingMode;
			var lengthSpacing = spacingMode == spine.SpacingMode.Length;
			var rotateMode = data.rotateMode;
			var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;
			var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
			var bones = this.bones;
			var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;
			var spacing = this.spacing;
			if (scale || lengthSpacing) {
				if (scale)
					lengths = spine.Utils.setArraySize(this.lengths, boneCount);
				for (var i = 0, n = spacesCount - 1; i < n;) {
					var bone = bones[i];
					var setupLength = bone.data.length, x = setupLength * bone.a, y = setupLength * bone.c;
					var length_1 = Math.sqrt(x * x + y * y);
					if (scale)
						lengths[i] = length_1;
					spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
				}
			}
			else {
				for (var i = 1; i < spacesCount; i++)
					spaces[i] = spacing;
			}
			var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, spacingMode == spine.SpacingMode.Percent);
			var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
			var tip = false;
			if (offsetRotation == 0)
				tip = rotateMode == spine.RotateMode.Chain;
			else {
				tip = false;
				var p = this.target.bone;
				offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			}
			for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
				var bone = bones[i];
				bone.worldX += (boneX - bone.worldX) * translateMix;
				bone.worldY += (boneY - bone.worldY) * translateMix;
				var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
				if (scale) {
					var length_2 = lengths[i];
					if (length_2 != 0) {
						var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
						bone.a *= s;
						bone.c *= s;
					}
				}
				boneX = x;
				boneY = y;
				if (rotate) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;
					if (tangents)
						r = positions[p - 1];
					else if (spaces[i + 1] == 0)
						r = positions[p + 2];
					else
						r = Math.atan2(dy, dx);
					r -= Math.atan2(c, a);
					if (tip) {
						cos = Math.cos(r);
						sin = Math.sin(r);
						var length_3 = bone.data.length;
						boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
						boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
					}
					else {
						r += offsetRotation;
					}
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					cos = Math.cos(r);
					sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
				}
				bone.appliedValid = false;
			}
		};
		PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {
			var target = this.target;
			var position = this.position;
			var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
			var closed = path.closed;
			var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;
			if (!path.constantSpeed) {
				var lengths = path.lengths;
				curveCount -= closed ? 1 : 2;
				var pathLength_1 = lengths[curveCount];
				if (percentPosition)
					position *= pathLength_1;
				if (percentSpacing) {
					for (var i = 0; i < spacesCount; i++)
						spaces[i] *= pathLength_1;
				}
				world = spine.Utils.setArraySize(this.world, 8);
				for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
					var space = spaces[i];
					position += space;
					var p = position;
					if (closed) {
						p %= pathLength_1;
						if (p < 0)
							p += pathLength_1;
						curve = 0;
					}
					else if (p < 0) {
						if (prevCurve != PathConstraint.BEFORE) {
							prevCurve = PathConstraint.BEFORE;
							path.computeWorldVertices(target, 2, 4, world, 0, 2);
						}
						this.addBeforePosition(p, world, 0, out, o);
						continue;
					}
					else if (p > pathLength_1) {
						if (prevCurve != PathConstraint.AFTER) {
							prevCurve = PathConstraint.AFTER;
							path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
						}
						this.addAfterPosition(p - pathLength_1, world, 0, out, o);
						continue;
					}
					for (;; curve++) {
						var length_4 = lengths[curve];
						if (p > length_4)
							continue;
						if (curve == 0)
							p /= length_4;
						else {
							var prev = lengths[curve - 1];
							p = (p - prev) / (length_4 - prev);
						}
						break;
					}
					if (curve != prevCurve) {
						prevCurve = curve;
						if (closed && curve == curveCount) {
							path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
							path.computeWorldVertices(target, 0, 4, world, 4, 2);
						}
						else
							path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
					}
					this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
				}
				return out;
			}
			if (closed) {
				verticesLength += 2;
				world = spine.Utils.setArraySize(this.world, verticesLength);
				path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
				path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
				world[verticesLength - 2] = world[0];
				world[verticesLength - 1] = world[1];
			}
			else {
				curveCount--;
				verticesLength -= 4;
				world = spine.Utils.setArraySize(this.world, verticesLength);
				path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
			}
			var curves = spine.Utils.setArraySize(this.curves, curveCount);
			var pathLength = 0;
			var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
			var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
			for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
				cx1 = world[w];
				cy1 = world[w + 1];
				cx2 = world[w + 2];
				cy2 = world[w + 3];
				x2 = world[w + 4];
				y2 = world[w + 5];
				tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
				tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
				dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
				dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
				ddfx = tmpx * 2 + dddfx;
				ddfy = tmpy * 2 + dddfy;
				dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
				dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				ddfx += dddfx;
				ddfy += dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx + dddfx;
				dfy += ddfy + dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				curves[i] = pathLength;
				x1 = x2;
				y1 = y2;
			}
			if (percentPosition)
				position *= pathLength;
			if (percentSpacing) {
				for (var i = 0; i < spacesCount; i++)
					spaces[i] *= pathLength;
			}
			var segments = this.segments;
			var curveLength = 0;
			for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
				var space = spaces[i];
				position += space;
				var p = position;
				if (closed) {
					p %= pathLength;
					if (p < 0)
						p += pathLength;
					curve = 0;
				}
				else if (p < 0) {
					this.addBeforePosition(p, world, 0, out, o);
					continue;
				}
				else if (p > pathLength) {
					this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
					continue;
				}
				for (;; curve++) {
					var length_5 = curves[curve];
					if (p > length_5)
						continue;
					if (curve == 0)
						p /= length_5;
					else {
						var prev = curves[curve - 1];
						p = (p - prev) / (length_5 - prev);
					}
					break;
				}
				if (curve != prevCurve) {
					prevCurve = curve;
					var ii = curve * 6;
					x1 = world[ii];
					y1 = world[ii + 1];
					cx1 = world[ii + 2];
					cy1 = world[ii + 3];
					cx2 = world[ii + 4];
					cy2 = world[ii + 5];
					x2 = world[ii + 6];
					y2 = world[ii + 7];
					tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
					tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
					dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
					dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
					ddfx = tmpx * 2 + dddfx;
					ddfy = tmpy * 2 + dddfy;
					dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
					dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
					curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
					segments[0] = curveLength;
					for (ii = 1; ii < 8; ii++) {
						dfx += ddfx;
						dfy += ddfy;
						ddfx += dddfx;
						ddfy += dddfy;
						curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
						segments[ii] = curveLength;
					}
					dfx += ddfx;
					dfy += ddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[8] = curveLength;
					dfx += ddfx + dddfx;
					dfy += ddfy + dddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[9] = curveLength;
					segment = 0;
				}
				p *= curveLength;
				for (;; segment++) {
					var length_6 = segments[segment];
					if (p > length_6)
						continue;
					if (segment == 0)
						p /= length_6;
					else {
						var prev = segments[segment - 1];
						p = segment + (p - prev) / (length_6 - prev);
					}
					break;
				}
				this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
			}
			return out;
		};
		PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {
			var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		};
		PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {
			var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		};
		PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
			if (p == 0 || isNaN(p))
				p = 0.0001;
			var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
			var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
			var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
			out[o] = x;
			out[o + 1] = y;
			if (tangents)
				out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
		};
		PathConstraint.prototype.getOrder = function () {
			return this.data.order;
		};
		PathConstraint.NONE = -1;
		PathConstraint.BEFORE = -2;
		PathConstraint.AFTER = -3;
		return PathConstraint;
	}());
	spine.PathConstraint = PathConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathConstraintData = (function () {
		function PathConstraintData(name) {
			this.order = 0;
			this.bones = new Array();
			this.name = name;
		}
		return PathConstraintData;
	}());
	spine.PathConstraintData = PathConstraintData;
	(function (PositionMode) {
		PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
		PositionMode[PositionMode["Percent"] = 1] = "Percent";
	})(spine.PositionMode || (spine.PositionMode = {}));
	var PositionMode = spine.PositionMode;
	(function (SpacingMode) {
		SpacingMode[SpacingMode["Length"] = 0] = "Length";
		SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
		SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
	})(spine.SpacingMode || (spine.SpacingMode = {}));
	var SpacingMode = spine.SpacingMode;
	(function (RotateMode) {
		RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
		RotateMode[RotateMode["Chain"] = 1] = "Chain";
		RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
	})(spine.RotateMode || (spine.RotateMode = {}));
	var RotateMode = spine.RotateMode;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Assets = (function () {
		function Assets(clientId) {
			this.toLoad = new Array();
			this.assets = {};
			this.clientId = clientId;
		}
		Assets.prototype.loaded = function () {
			var i = 0;
			for (var v in this.assets)
				i++;
			return i;
		};
		return Assets;
	}());
	var SharedAssetManager = (function () {
		function SharedAssetManager(pathPrefix) {
			if (pathPrefix === void 0) { pathPrefix = ""; }
			this.clientAssets = {};
			this.queuedAssets = {};
			this.rawAssets = {};
			this.errors = {};
			this.pathPrefix = pathPrefix;
		}
		SharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined) {
				clientAssets = new Assets(clientId);
				this.clientAssets[clientId] = clientAssets;
			}
			if (textureLoader !== null)
				clientAssets.textureLoader = textureLoader;
			clientAssets.toLoad.push(path);
			if (this.queuedAssets[path] === path) {
				return false;
			}
			else {
				this.queuedAssets[path] = path;
				return true;
			}
		};
		SharedAssetManager.prototype.loadText = function (clientId, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, null, path))
				return;
			var request = new XMLHttpRequest();
			request.onreadystatechange = function () {
				if (request.readyState == XMLHttpRequest.DONE) {
					if (request.status >= 200 && request.status < 300) {
						_this.rawAssets[path] = request.responseText;
					}
					else {
						_this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
					}
				}
			};
			request.open("GET", path, true);
			request.send();
		};
		SharedAssetManager.prototype.loadJson = function (clientId, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, null, path))
				return;
			var request = new XMLHttpRequest();
			request.onreadystatechange = function () {
				if (request.readyState == XMLHttpRequest.DONE) {
					if (request.status >= 200 && request.status < 300) {
						_this.rawAssets[path] = JSON.parse(request.responseText);
					}
					else {
						_this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
					}
				}
			};
			request.open("GET", path, true);
			request.send();
		};
		SharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, textureLoader, path))
				return;
			var img = new Image();
			img.src = path;
			img.crossOrigin = "anonymous";
			img.onload = function (ev) {
				_this.rawAssets[path] = img;
			};
			img.onerror = function (ev) {
				_this.errors[path] = "Couldn't load image " + path;
			};
		};
		SharedAssetManager.prototype.get = function (clientId, path) {
			path = this.pathPrefix + path;
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined)
				return true;
			return clientAssets.assets[path];
		};
		SharedAssetManager.prototype.updateClientAssets = function (clientAssets) {
			for (var i = 0; i < clientAssets.toLoad.length; i++) {
				var path = clientAssets.toLoad[i];
				var asset = clientAssets.assets[path];
				if (asset === null || asset === undefined) {
					var rawAsset = this.rawAssets[path];
					if (rawAsset === null || rawAsset === undefined)
						continue;
					if (rawAsset instanceof HTMLImageElement) {
						clientAssets.assets[path] = clientAssets.textureLoader(rawAsset);
					}
					else {
						clientAssets.assets[path] = rawAsset;
					}
				}
			}
		};
		SharedAssetManager.prototype.isLoadingComplete = function (clientId) {
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined)
				return true;
			this.updateClientAssets(clientAssets);
			return clientAssets.toLoad.length == clientAssets.loaded();
		};
		SharedAssetManager.prototype.dispose = function () {
		};
		SharedAssetManager.prototype.hasErrors = function () {
			return Object.keys(this.errors).length > 0;
		};
		SharedAssetManager.prototype.getErrors = function () {
			return this.errors;
		};
		return SharedAssetManager;
	}());
	spine.SharedAssetManager = SharedAssetManager;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Skeleton = (function () {
		function Skeleton(data) {
			this._updateCache = new Array();
			this.updateCacheReset = new Array();
			this.time = 0;
			this.flipX = false;
			this.flipY = false;
			this.x = 0;
			this.y = 0;
			if (data == null)
				throw new Error("data cannot be null.");
			this.data = data;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++) {
				var boneData = data.bones[i];
				var bone = void 0;
				if (boneData.parent == null)
					bone = new spine.Bone(boneData, this, null);
				else {
					var parent_1 = this.bones[boneData.parent.index];
					bone = new spine.Bone(boneData, this, parent_1);
					parent_1.children.push(bone);
				}
				this.bones.push(bone);
			}
			this.slots = new Array();
			this.drawOrder = new Array();
			for (var i = 0; i < data.slots.length; i++) {
				var slotData = data.slots[i];
				var bone = this.bones[slotData.boneData.index];
				var slot = new spine.Slot(slotData, bone);
				this.slots.push(slot);
				this.drawOrder.push(slot);
			}
			this.ikConstraints = new Array();
			for (var i = 0; i < data.ikConstraints.length; i++) {
				var ikConstraintData = data.ikConstraints[i];
				this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));
			}
			this.transformConstraints = new Array();
			for (var i = 0; i < data.transformConstraints.length; i++) {
				var transformConstraintData = data.transformConstraints[i];
				this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));
			}
			this.pathConstraints = new Array();
			for (var i = 0; i < data.pathConstraints.length; i++) {
				var pathConstraintData = data.pathConstraints[i];
				this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));
			}
			this.color = new spine.Color(1, 1, 1, 1);
			this.updateCache();
		}
		Skeleton.prototype.updateCache = function () {
			var updateCache = this._updateCache;
			updateCache.length = 0;
			this.updateCacheReset.length = 0;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				bones[i].sorted = false;
			var ikConstraints = this.ikConstraints;
			var transformConstraints = this.transformConstraints;
			var pathConstraints = this.pathConstraints;
			var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
			var constraintCount = ikCount + transformCount + pathCount;
			outer: for (var i = 0; i < constraintCount; i++) {
				for (var ii = 0; ii < ikCount; ii++) {
					var constraint = ikConstraints[ii];
					if (constraint.data.order == i) {
						this.sortIkConstraint(constraint);
						continue outer;
					}
				}
				for (var ii = 0; ii < transformCount; ii++) {
					var constraint = transformConstraints[ii];
					if (constraint.data.order == i) {
						this.sortTransformConstraint(constraint);
						continue outer;
					}
				}
				for (var ii = 0; ii < pathCount; ii++) {
					var constraint = pathConstraints[ii];
					if (constraint.data.order == i) {
						this.sortPathConstraint(constraint);
						continue outer;
					}
				}
			}
			for (var i = 0, n = bones.length; i < n; i++)
				this.sortBone(bones[i]);
		};
		Skeleton.prototype.sortIkConstraint = function (constraint) {
			var target = constraint.target;
			this.sortBone(target);
			var constrained = constraint.bones;
			var parent = constrained[0];
			this.sortBone(parent);
			if (constrained.length > 1) {
				var child = constrained[constrained.length - 1];
				if (!(this._updateCache.indexOf(child) > -1))
					this.updateCacheReset.push(child);
			}
			this._updateCache.push(constraint);
			this.sortReset(parent.children);
			constrained[constrained.length - 1].sorted = true;
		};
		Skeleton.prototype.sortPathConstraint = function (constraint) {
			var slot = constraint.target;
			var slotIndex = slot.data.index;
			var slotBone = slot.bone;
			if (this.skin != null)
				this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
			if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
				this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
			for (var i = 0, n = this.data.skins.length; i < n; i++)
				this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
			var attachment = slot.getAttachment();
			if (attachment instanceof spine.PathAttachment)
				this.sortPathConstraintAttachmentWith(attachment, slotBone);
			var constrained = constraint.bones;
			var boneCount = constrained.length;
			for (var i = 0; i < boneCount; i++)
				this.sortBone(constrained[i]);
			this._updateCache.push(constraint);
			for (var i = 0; i < boneCount; i++)
				this.sortReset(constrained[i].children);
			for (var i = 0; i < boneCount; i++)
				constrained[i].sorted = true;
		};
		Skeleton.prototype.sortTransformConstraint = function (constraint) {
			this.sortBone(constraint.target);
			var constrained = constraint.bones;
			var boneCount = constrained.length;
			if (constraint.data.local) {
				for (var i = 0; i < boneCount; i++) {
					var child = constrained[i];
					this.sortBone(child.parent);
					if (!(this._updateCache.indexOf(child) > -1))
						this.updateCacheReset.push(child);
				}
			}
			else {
				for (var i = 0; i < boneCount; i++) {
					this.sortBone(constrained[i]);
				}
			}
			this._updateCache.push(constraint);
			for (var ii = 0; ii < boneCount; ii++)
				this.sortReset(constrained[ii].children);
			for (var ii = 0; ii < boneCount; ii++)
				constrained[ii].sorted = true;
		};
		Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {
			var attachments = skin.attachments[slotIndex];
			if (!attachments)
				return;
			for (var key in attachments) {
				this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
			}
		};
		Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {
			if (!(attachment instanceof spine.PathAttachment))
				return;
			var pathBones = attachment.bones;
			if (pathBones == null)
				this.sortBone(slotBone);
			else {
				var bones = this.bones;
				var i = 0;
				while (i < pathBones.length) {
					var boneCount = pathBones[i++];
					for (var n = i + boneCount; i < n; i++) {
						var boneIndex = pathBones[i];
						this.sortBone(bones[boneIndex]);
					}
				}
			}
		};
		Skeleton.prototype.sortBone = function (bone) {
			if (bone.sorted)
				return;
			var parent = bone.parent;
			if (parent != null)
				this.sortBone(parent);
			bone.sorted = true;
			this._updateCache.push(bone);
		};
		Skeleton.prototype.sortReset = function (bones) {
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (bone.sorted)
					this.sortReset(bone.children);
				bone.sorted = false;
			}
		};
		Skeleton.prototype.updateWorldTransform = function () {
			var updateCacheReset = this.updateCacheReset;
			for (var i = 0, n = updateCacheReset.length; i < n; i++) {
				var bone = updateCacheReset[i];
				bone.ax = bone.x;
				bone.ay = bone.y;
				bone.arotation = bone.rotation;
				bone.ascaleX = bone.scaleX;
				bone.ascaleY = bone.scaleY;
				bone.ashearX = bone.shearX;
				bone.ashearY = bone.shearY;
				bone.appliedValid = true;
			}
			var updateCache = this._updateCache;
			for (var i = 0, n = updateCache.length; i < n; i++)
				updateCache[i].update();
		};
		Skeleton.prototype.setToSetupPose = function () {
			this.setBonesToSetupPose();
			this.setSlotsToSetupPose();
		};
		Skeleton.prototype.setBonesToSetupPose = function () {
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				bones[i].setToSetupPose();
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var constraint = ikConstraints[i];
				constraint.bendDirection = constraint.data.bendDirection;
				constraint.mix = constraint.data.mix;
			}
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				var data = constraint.data;
				constraint.rotateMix = data.rotateMix;
				constraint.translateMix = data.translateMix;
				constraint.scaleMix = data.scaleMix;
				constraint.shearMix = data.shearMix;
			}
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				var data = constraint.data;
				constraint.position = data.position;
				constraint.spacing = data.spacing;
				constraint.rotateMix = data.rotateMix;
				constraint.translateMix = data.translateMix;
			}
		};
		Skeleton.prototype.setSlotsToSetupPose = function () {
			var slots = this.slots;
			spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
			for (var i = 0, n = slots.length; i < n; i++)
				slots[i].setToSetupPose();
		};
		Skeleton.prototype.getRootBone = function () {
			if (this.bones.length == 0)
				return null;
			return this.bones[0];
		};
		Skeleton.prototype.findBone = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (bone.data.name == boneName)
					return bone;
			}
			return null;
		};
		Skeleton.prototype.findBoneIndex = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				if (bones[i].data.name == boneName)
					return i;
			return -1;
		};
		Skeleton.prototype.findSlot = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.data.name == slotName)
					return slot;
			}
			return null;
		};
		Skeleton.prototype.findSlotIndex = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++)
				if (slots[i].data.name == slotName)
					return i;
			return -1;
		};
		Skeleton.prototype.setSkinByName = function (skinName) {
			var skin = this.data.findSkin(skinName);
			if (skin == null)
				throw new Error("Skin not found: " + skinName);
			this.setSkin(skin);
		};
		Skeleton.prototype.setSkin = function (newSkin) {
			if (newSkin != null) {
				if (this.skin != null)
					newSkin.attachAll(this, this.skin);
				else {
					var slots = this.slots;
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var name_1 = slot.data.attachmentName;
						if (name_1 != null) {
							var attachment = newSkin.getAttachment(i, name_1);
							if (attachment != null)
								slot.setAttachment(attachment);
						}
					}
				}
			}
			this.skin = newSkin;
		};
		Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {
			return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
		};
		Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {
			if (attachmentName == null)
				throw new Error("attachmentName cannot be null.");
			if (this.skin != null) {
				var attachment = this.skin.getAttachment(slotIndex, attachmentName);
				if (attachment != null)
					return attachment;
			}
			if (this.data.defaultSkin != null)
				return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
			return null;
		};
		Skeleton.prototype.setAttachment = function (slotName, attachmentName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.data.name == slotName) {
					var attachment = null;
					if (attachmentName != null) {
						attachment = this.getAttachment(i, attachmentName);
						if (attachment == null)
							throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
					}
					slot.setAttachment(attachment);
					return;
				}
			}
			throw new Error("Slot not found: " + slotName);
		};
		Skeleton.prototype.findIkConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var ikConstraint = ikConstraints[i];
				if (ikConstraint.data.name == constraintName)
					return ikConstraint;
			}
			return null;
		};
		Skeleton.prototype.findTransformConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				if (constraint.data.name == constraintName)
					return constraint;
			}
			return null;
		};
		Skeleton.prototype.findPathConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				if (constraint.data.name == constraintName)
					return constraint;
			}
			return null;
		};
		Skeleton.prototype.getBounds = function (offset, size, temp) {
			if (offset == null)
				throw new Error("offset cannot be null.");
			if (size == null)
				throw new Error("size cannot be null.");
			var drawOrder = this.drawOrder;
			var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
			for (var i = 0, n = drawOrder.length; i < n; i++) {
				var slot = drawOrder[i];
				var verticesLength = 0;
				var vertices = null;
				var attachment = slot.getAttachment();
				if (attachment instanceof spine.RegionAttachment) {
					verticesLength = 8;
					vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
					attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
				}
				else if (attachment instanceof spine.MeshAttachment) {
					var mesh = attachment;
					verticesLength = mesh.worldVerticesLength;
					vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
					mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
				}
				if (vertices != null) {
					for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
						var x = vertices[ii], y = vertices[ii + 1];
						minX = Math.min(minX, x);
						minY = Math.min(minY, y);
						maxX = Math.max(maxX, x);
						maxY = Math.max(maxY, y);
					}
				}
			}
			offset.set(minX, minY);
			size.set(maxX - minX, maxY - minY);
		};
		Skeleton.prototype.update = function (delta) {
			this.time += delta;
		};
		return Skeleton;
	}());
	spine.Skeleton = Skeleton;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonBounds = (function () {
		function SkeletonBounds() {
			this.minX = 0;
			this.minY = 0;
			this.maxX = 0;
			this.maxY = 0;
			this.boundingBoxes = new Array();
			this.polygons = new Array();
			this.polygonPool = new spine.Pool(function () {
				return spine.Utils.newFloatArray(16);
			});
		}
		SkeletonBounds.prototype.update = function (skeleton, updateAabb) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			var boundingBoxes = this.boundingBoxes;
			var polygons = this.polygons;
			var polygonPool = this.polygonPool;
			var slots = skeleton.slots;
			var slotCount = slots.length;
			boundingBoxes.length = 0;
			polygonPool.freeAll(polygons);
			polygons.length = 0;
			for (var i = 0; i < slotCount; i++) {
				var slot = slots[i];
				var attachment = slot.getAttachment();
				if (attachment instanceof spine.BoundingBoxAttachment) {
					var boundingBox = attachment;
					boundingBoxes.push(boundingBox);
					var polygon = polygonPool.obtain();
					if (polygon.length != boundingBox.worldVerticesLength) {
						polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);
					}
					polygons.push(polygon);
					boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
				}
			}
			if (updateAabb) {
				this.aabbCompute();
			}
			else {
				this.minX = Number.POSITIVE_INFINITY;
				this.minY = Number.POSITIVE_INFINITY;
				this.maxX = Number.NEGATIVE_INFINITY;
				this.maxY = Number.NEGATIVE_INFINITY;
			}
		};
		SkeletonBounds.prototype.aabbCompute = function () {
			var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++) {
				var polygon = polygons[i];
				var vertices = polygon;
				for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
					var x = vertices[ii];
					var y = vertices[ii + 1];
					minX = Math.min(minX, x);
					minY = Math.min(minY, y);
					maxX = Math.max(maxX, x);
					maxY = Math.max(maxY, y);
				}
			}
			this.minX = minX;
			this.minY = minY;
			this.maxX = maxX;
			this.maxY = maxY;
		};
		SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {
			return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
		};
		SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {
			var minX = this.minX;
			var minY = this.minY;
			var maxX = this.maxX;
			var maxY = this.maxY;
			if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
				return false;
			var m = (y2 - y1) / (x2 - x1);
			var y = m * (minX - x1) + y1;
			if (y > minY && y < maxY)
				return true;
			y = m * (maxX - x1) + y1;
			if (y > minY && y < maxY)
				return true;
			var x = (minY - y1) / m + x1;
			if (x > minX && x < maxX)
				return true;
			x = (maxY - y1) / m + x1;
			if (x > minX && x < maxX)
				return true;
			return false;
		};
		SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {
			return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
		};
		SkeletonBounds.prototype.containsPoint = function (x, y) {
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++)
				if (this.containsPointPolygon(polygons[i], x, y))
					return this.boundingBoxes[i];
			return null;
		};
		SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {
			var vertices = polygon;
			var nn = polygon.length;
			var prevIndex = nn - 2;
			var inside = false;
			for (var ii = 0; ii < nn; ii += 2) {
				var vertexY = vertices[ii + 1];
				var prevY = vertices[prevIndex + 1];
				if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
					var vertexX = vertices[ii];
					if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
						inside = !inside;
				}
				prevIndex = ii;
			}
			return inside;
		};
		SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++)
				if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
					return this.boundingBoxes[i];
			return null;
		};
		SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {
			var vertices = polygon;
			var nn = polygon.length;
			var width12 = x1 - x2, height12 = y1 - y2;
			var det1 = x1 * y2 - y1 * x2;
			var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
			for (var ii = 0; ii < nn; ii += 2) {
				var x4 = vertices[ii], y4 = vertices[ii + 1];
				var det2 = x3 * y4 - y3 * x4;
				var width34 = x3 - x4, height34 = y3 - y4;
				var det3 = width12 * height34 - height12 * width34;
				var x = (det1 * width34 - width12 * det2) / det3;
				if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
					var y = (det1 * height34 - height12 * det2) / det3;
					if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))
						return true;
				}
				x3 = x4;
				y3 = y4;
			}
			return false;
		};
		SkeletonBounds.prototype.getPolygon = function (boundingBox) {
			if (boundingBox == null)
				throw new Error("boundingBox cannot be null.");
			var index = this.boundingBoxes.indexOf(boundingBox);
			return index == -1 ? null : this.polygons[index];
		};
		SkeletonBounds.prototype.getWidth = function () {
			return this.maxX - this.minX;
		};
		SkeletonBounds.prototype.getHeight = function () {
			return this.maxY - this.minY;
		};
		return SkeletonBounds;
	}());
	spine.SkeletonBounds = SkeletonBounds;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonClipping = (function () {
		function SkeletonClipping() {
			this.triangulator = new spine.Triangulator();
			this.clippingPolygon = new Array();
			this.clipOutput = new Array();
			this.clippedVertices = new Array();
			this.clippedTriangles = new Array();
			this.scratch = new Array();
		}
		SkeletonClipping.prototype.clipStart = function (slot, clip) {
			if (this.clipAttachment != null)
				return 0;
			this.clipAttachment = clip;
			var n = clip.worldVerticesLength;
			var vertices = spine.Utils.setArraySize(this.clippingPolygon, n);
			clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
			var clippingPolygon = this.clippingPolygon;
			SkeletonClipping.makeClockwise(clippingPolygon);
			var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));
			for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {
				var polygon = clippingPolygons[i];
				SkeletonClipping.makeClockwise(polygon);
				polygon.push(polygon[0]);
				polygon.push(polygon[1]);
			}
			return clippingPolygons.length;
		};
		SkeletonClipping.prototype.clipEndWithSlot = function (slot) {
			if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)
				this.clipEnd();
		};
		SkeletonClipping.prototype.clipEnd = function () {
			if (this.clipAttachment == null)
				return;
			this.clipAttachment = null;
			this.clippingPolygons = null;
			this.clippedVertices.length = 0;
			this.clippedTriangles.length = 0;
			this.clippingPolygon.length = 0;
		};
		SkeletonClipping.prototype.isClipping = function () {
			return this.clipAttachment != null;
		};
		SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {
			var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
			var clippedTriangles = this.clippedTriangles;
			var polygons = this.clippingPolygons;
			var polygonsCount = this.clippingPolygons.length;
			var vertexSize = twoColor ? 12 : 8;
			var index = 0;
			clippedVertices.length = 0;
			clippedTriangles.length = 0;
			outer: for (var i = 0; i < trianglesLength; i += 3) {
				var vertexOffset = triangles[i] << 1;
				var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
				var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];
				vertexOffset = triangles[i + 1] << 1;
				var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
				var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];
				vertexOffset = triangles[i + 2] << 1;
				var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
				var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];
				for (var p = 0; p < polygonsCount; p++) {
					var s = clippedVertices.length;
					if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
						var clipOutputLength = clipOutput.length;
						if (clipOutputLength == 0)
							continue;
						var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
						var d = 1 / (d0 * d2 + d1 * (y1 - y3));
						var clipOutputCount = clipOutputLength >> 1;
						var clipOutputItems = this.clipOutput;
						var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);
						for (var ii = 0; ii < clipOutputLength; ii += 2) {
							var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];
							clippedVerticesItems[s] = x;
							clippedVerticesItems[s + 1] = y;
							clippedVerticesItems[s + 2] = light.r;
							clippedVerticesItems[s + 3] = light.g;
							clippedVerticesItems[s + 4] = light.b;
							clippedVerticesItems[s + 5] = light.a;
							var c0 = x - x3, c1 = y - y3;
							var a = (d0 * c0 + d1 * c1) * d;
							var b = (d4 * c0 + d2 * c1) * d;
							var c = 1 - a - b;
							clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;
							clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;
							if (twoColor) {
								clippedVerticesItems[s + 8] = dark.r;
								clippedVerticesItems[s + 8] = dark.g;
								clippedVerticesItems[s + 10] = dark.b;
								clippedVerticesItems[s + 11] = dark.a;
							}
							s += vertexSize;
						}
						s = clippedTriangles.length;
						var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
						clipOutputCount--;
						for (var ii = 1; ii < clipOutputCount; ii++) {
							clippedTrianglesItems[s] = index;
							clippedTrianglesItems[s + 1] = (index + ii);
							clippedTrianglesItems[s + 2] = (index + ii + 1);
							s += 3;
						}
						index += clipOutputCount + 1;
					}
					else {
						var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);
						clippedVerticesItems[s] = x1;
						clippedVerticesItems[s + 1] = y1;
						clippedVerticesItems[s + 2] = light.r;
						clippedVerticesItems[s + 3] = light.g;
						clippedVerticesItems[s + 4] = light.b;
						clippedVerticesItems[s + 5] = light.a;
						if (!twoColor) {
							clippedVerticesItems[s + 6] = u1;
							clippedVerticesItems[s + 7] = v1;
							clippedVerticesItems[s + 8] = x2;
							clippedVerticesItems[s + 9] = y2;
							clippedVerticesItems[s + 10] = light.r;
							clippedVerticesItems[s + 11] = light.g;
							clippedVerticesItems[s + 12] = light.b;
							clippedVerticesItems[s + 13] = light.a;
							clippedVerticesItems[s + 14] = u2;
							clippedVerticesItems[s + 15] = v2;
							clippedVerticesItems[s + 16] = x3;
							clippedVerticesItems[s + 17] = y3;
							clippedVerticesItems[s + 18] = light.r;
							clippedVerticesItems[s + 19] = light.g;
							clippedVerticesItems[s + 20] = light.b;
							clippedVerticesItems[s + 21] = light.a;
							clippedVerticesItems[s + 22] = u3;
							clippedVerticesItems[s + 23] = v3;
						}
						else {
							clippedVerticesItems[s + 6] = u1;
							clippedVerticesItems[s + 7] = v1;
							clippedVerticesItems[s + 8] = dark.r;
							clippedVerticesItems[s + 9] = dark.g;
							clippedVerticesItems[s + 10] = dark.b;
							clippedVerticesItems[s + 11] = dark.a;
							clippedVerticesItems[s + 12] = x2;
							clippedVerticesItems[s + 13] = y2;
							clippedVerticesItems[s + 14] = light.r;
							clippedVerticesItems[s + 15] = light.g;
							clippedVerticesItems[s + 16] = light.b;
							clippedVerticesItems[s + 17] = light.a;
							clippedVerticesItems[s + 18] = u2;
							clippedVerticesItems[s + 19] = v2;
							clippedVerticesItems[s + 20] = dark.r;
							clippedVerticesItems[s + 21] = dark.g;
							clippedVerticesItems[s + 22] = dark.b;
							clippedVerticesItems[s + 23] = dark.a;
							clippedVerticesItems[s + 24] = x3;
							clippedVerticesItems[s + 25] = y3;
							clippedVerticesItems[s + 26] = light.r;
							clippedVerticesItems[s + 27] = light.g;
							clippedVerticesItems[s + 28] = light.b;
							clippedVerticesItems[s + 29] = light.a;
							clippedVerticesItems[s + 30] = u3;
							clippedVerticesItems[s + 31] = v3;
							clippedVerticesItems[s + 32] = dark.r;
							clippedVerticesItems[s + 33] = dark.g;
							clippedVerticesItems[s + 34] = dark.b;
							clippedVerticesItems[s + 35] = dark.a;
						}
						s = clippedTriangles.length;
						var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);
						clippedTrianglesItems[s] = index;
						clippedTrianglesItems[s + 1] = (index + 1);
						clippedTrianglesItems[s + 2] = (index + 2);
						index += 3;
						continue outer;
					}
				}
			}
		};
		SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
			var originalOutput = output;
			var clipped = false;
			var input = null;
			if (clippingArea.length % 4 >= 2) {
				input = output;
				output = this.scratch;
			}
			else
				input = this.scratch;
			input.length = 0;
			input.push(x1);
			input.push(y1);
			input.push(x2);
			input.push(y2);
			input.push(x3);
			input.push(y3);
			input.push(x1);
			input.push(y1);
			output.length = 0;
			var clippingVertices = clippingArea;
			var clippingVerticesLast = clippingArea.length - 4;
			for (var i = 0;; i += 2) {
				var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];
				var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];
				var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;
				var inputVertices = input;
				var inputVerticesLength = input.length - 2, outputStart = output.length;
				for (var ii = 0; ii < inputVerticesLength; ii += 2) {
					var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];
					var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];
					var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
					if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
						if (side2) {
							output.push(inputX2);
							output.push(inputY2);
							continue;
						}
						var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
						var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
						output.push(edgeX + (edgeX2 - edgeX) * ua);
						output.push(edgeY + (edgeY2 - edgeY) * ua);
					}
					else if (side2) {
						var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
						var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
						output.push(edgeX + (edgeX2 - edgeX) * ua);
						output.push(edgeY + (edgeY2 - edgeY) * ua);
						output.push(inputX2);
						output.push(inputY2);
					}
					clipped = true;
				}
				if (outputStart == output.length) {
					originalOutput.length = 0;
					return true;
				}
				output.push(output[0]);
				output.push(output[1]);
				if (i == clippingVerticesLast)
					break;
				var temp = output;
				output = input;
				output.length = 0;
				input = temp;
			}
			if (originalOutput != output) {
				originalOutput.length = 0;
				for (var i = 0, n = output.length - 2; i < n; i++)
					originalOutput[i] = output[i];
			}
			else
				originalOutput.length = originalOutput.length - 2;
			return clipped;
		};
		SkeletonClipping.makeClockwise = function (polygon) {
			var vertices = polygon;
			var verticeslength = polygon.length;
			var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;
			for (var i = 0, n = verticeslength - 3; i < n; i += 2) {
				p1x = vertices[i];
				p1y = vertices[i + 1];
				p2x = vertices[i + 2];
				p2y = vertices[i + 3];
				area += p1x * p2y - p2x * p1y;
			}
			if (area < 0)
				return;
			for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
				var x = vertices[i], y = vertices[i + 1];
				var other = lastX - i;
				vertices[i] = vertices[other];
				vertices[i + 1] = vertices[other + 1];
				vertices[other] = x;
				vertices[other + 1] = y;
			}
		};
		return SkeletonClipping;
	}());
	spine.SkeletonClipping = SkeletonClipping;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonData = (function () {
		function SkeletonData() {
			this.bones = new Array();
			this.slots = new Array();
			this.skins = new Array();
			this.events = new Array();
			this.animations = new Array();
			this.ikConstraints = new Array();
			this.transformConstraints = new Array();
			this.pathConstraints = new Array();
			this.fps = 0;
		}
		SkeletonData.prototype.findBone = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (bone.name == boneName)
					return bone;
			}
			return null;
		};
		SkeletonData.prototype.findBoneIndex = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				if (bones[i].name == boneName)
					return i;
			return -1;
		};
		SkeletonData.prototype.findSlot = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.name == slotName)
					return slot;
			}
			return null;
		};
		SkeletonData.prototype.findSlotIndex = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++)
				if (slots[i].name == slotName)
					return i;
			return -1;
		};
		SkeletonData.prototype.findSkin = function (skinName) {
			if (skinName == null)
				throw new Error("skinName cannot be null.");
			var skins = this.skins;
			for (var i = 0, n = skins.length; i < n; i++) {
				var skin = skins[i];
				if (skin.name == skinName)
					return skin;
			}
			return null;
		};
		SkeletonData.prototype.findEvent = function (eventDataName) {
			if (eventDataName == null)
				throw new Error("eventDataName cannot be null.");
			var events = this.events;
			for (var i = 0, n = events.length; i < n; i++) {
				var event_4 = events[i];
				if (event_4.name == eventDataName)
					return event_4;
			}
			return null;
		};
		SkeletonData.prototype.findAnimation = function (animationName) {
			if (animationName == null)
				throw new Error("animationName cannot be null.");
			var animations = this.animations;
			for (var i = 0, n = animations.length; i < n; i++) {
				var animation = animations[i];
				if (animation.name == animationName)
					return animation;
			}
			return null;
		};
		SkeletonData.prototype.findIkConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var constraint = ikConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findTransformConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findPathConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {
			if (pathConstraintName == null)
				throw new Error("pathConstraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++)
				if (pathConstraints[i].name == pathConstraintName)
					return i;
			return -1;
		};
		return SkeletonData;
	}());
	spine.SkeletonData = SkeletonData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonJson = (function () {
		function SkeletonJson(attachmentLoader) {
			this.scale = 1;
			this.linkedMeshes = new Array();
			this.attachmentLoader = attachmentLoader;
		}
		SkeletonJson.prototype.readSkeletonData = function (json) {
			var scale = this.scale;
			var skeletonData = new spine.SkeletonData();
			var root = typeof (json) === "string" ? JSON.parse(json) : json;
			var skeletonMap = root.skeleton;
			if (skeletonMap != null) {
				skeletonData.hash = skeletonMap.hash;
				skeletonData.version = skeletonMap.spine;
				skeletonData.width = skeletonMap.width;
				skeletonData.height = skeletonMap.height;
				skeletonData.fps = skeletonMap.fps;
				skeletonData.imagesPath = skeletonMap.images;
			}
			if (root.bones) {
				for (var i = 0; i < root.bones.length; i++) {
					var boneMap = root.bones[i];
					var parent_2 = null;
					var parentName = this.getValue(boneMap, "parent", null);
					if (parentName != null) {
						parent_2 = skeletonData.findBone(parentName);
						if (parent_2 == null)
							throw new Error("Parent bone not found: " + parentName);
					}
					var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);
					data.length = this.getValue(boneMap, "length", 0) * scale;
					data.x = this.getValue(boneMap, "x", 0) * scale;
					data.y = this.getValue(boneMap, "y", 0) * scale;
					data.rotation = this.getValue(boneMap, "rotation", 0);
					data.scaleX = this.getValue(boneMap, "scaleX", 1);
					data.scaleY = this.getValue(boneMap, "scaleY", 1);
					data.shearX = this.getValue(boneMap, "shearX", 0);
					data.shearY = this.getValue(boneMap, "shearY", 0);
					data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
					skeletonData.bones.push(data);
				}
			}
			if (root.slots) {
				for (var i = 0; i < root.slots.length; i++) {
					var slotMap = root.slots[i];
					var slotName = slotMap.name;
					var boneName = slotMap.bone;
					var boneData = skeletonData.findBone(boneName);
					if (boneData == null)
						throw new Error("Slot bone not found: " + boneName);
					var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);
					var color = this.getValue(slotMap, "color", null);
					if (color != null)
						data.color.setFromString(color);
					var dark = this.getValue(slotMap, "dark", null);
					if (dark != null) {
						data.darkColor = new spine.Color(1, 1, 1, 1);
						data.darkColor.setFromString(dark);
					}
					data.attachmentName = this.getValue(slotMap, "attachment", null);
					data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
					skeletonData.slots.push(data);
				}
			}
			if (root.ik) {
				for (var i = 0; i < root.ik.length; i++) {
					var constraintMap = root.ik[i];
					var data = new spine.IkConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("IK bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findBone(targetName);
					if (data.target == null)
						throw new Error("IK target bone not found: " + targetName);
					data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
					data.mix = this.getValue(constraintMap, "mix", 1);
					skeletonData.ikConstraints.push(data);
				}
			}
			if (root.transform) {
				for (var i = 0; i < root.transform.length; i++) {
					var constraintMap = root.transform[i];
					var data = new spine.TransformConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("Transform constraint bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findBone(targetName);
					if (data.target == null)
						throw new Error("Transform constraint target bone not found: " + targetName);
					data.local = this.getValue(constraintMap, "local", false);
					data.relative = this.getValue(constraintMap, "relative", false);
					data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
					data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
					data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
					data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
					data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
					data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
					data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
					data.translateMix = this.getValue(constraintMap, "translateMix", 1);
					data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
					data.shearMix = this.getValue(constraintMap, "shearMix", 1);
					skeletonData.transformConstraints.push(data);
				}
			}
			if (root.path) {
				for (var i = 0; i < root.path.length; i++) {
					var constraintMap = root.path[i];
					var data = new spine.PathConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("Transform constraint bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findSlot(targetName);
					if (data.target == null)
						throw new Error("Path target slot not found: " + targetName);
					data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
					data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
					data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
					data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
					data.position = this.getValue(constraintMap, "position", 0);
					if (data.positionMode == spine.PositionMode.Fixed)
						data.position *= scale;
					data.spacing = this.getValue(constraintMap, "spacing", 0);
					if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
						data.spacing *= scale;
					data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
					data.translateMix = this.getValue(constraintMap, "translateMix", 1);
					skeletonData.pathConstraints.push(data);
				}
			}
			if (root.skins) {
				for (var skinName in root.skins) {
					var skinMap = root.skins[skinName];
					var skin = new spine.Skin(skinName);
					for (var slotName in skinMap) {
						var slotIndex = skeletonData.findSlotIndex(slotName);
						if (slotIndex == -1)
							throw new Error("Slot not found: " + slotName);
						var slotMap = skinMap[slotName];
						for (var entryName in slotMap) {
							var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
							if (attachment != null)
								skin.addAttachment(slotIndex, entryName, attachment);
						}
					}
					skeletonData.skins.push(skin);
					if (skin.name == "default")
						skeletonData.defaultSkin = skin;
				}
			}
			for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
				var linkedMesh = this.linkedMeshes[i];
				var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
				if (skin == null)
					throw new Error("Skin not found: " + linkedMesh.skin);
				var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
				if (parent_3 == null)
					throw new Error("Parent mesh not found: " + linkedMesh.parent);
				linkedMesh.mesh.setParentMesh(parent_3);
				linkedMesh.mesh.updateUVs();
			}
			this.linkedMeshes.length = 0;
			if (root.events) {
				for (var eventName in root.events) {
					var eventMap = root.events[eventName];
					var data = new spine.EventData(eventName);
					data.intValue = this.getValue(eventMap, "int", 0);
					data.floatValue = this.getValue(eventMap, "float", 0);
					data.stringValue = this.getValue(eventMap, "string", "");
					skeletonData.events.push(data);
				}
			}
			if (root.animations) {
				for (var animationName in root.animations) {
					var animationMap = root.animations[animationName];
					this.readAnimation(animationMap, animationName, skeletonData);
				}
			}
			return skeletonData;
		};
		SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {
			var scale = this.scale;
			name = this.getValue(map, "name", name);
			var type = this.getValue(map, "type", "region");
			switch (type) {
				case "region": {
					var path = this.getValue(map, "path", name);
					var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
					if (region == null)
						return null;
					region.path = path;
					region.x = this.getValue(map, "x", 0) * scale;
					region.y = this.getValue(map, "y", 0) * scale;
					region.scaleX = this.getValue(map, "scaleX", 1);
					region.scaleY = this.getValue(map, "scaleY", 1);
					region.rotation = this.getValue(map, "rotation", 0);
					region.width = map.width * scale;
					region.height = map.height * scale;
					var color = this.getValue(map, "color", null);
					if (color != null)
						region.color.setFromString(color);
					region.updateOffset();
					return region;
				}
				case "boundingbox": {
					var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
					if (box == null)
						return null;
					this.readVertices(map, box, map.vertexCount << 1);
					var color = this.getValue(map, "color", null);
					if (color != null)
						box.color.setFromString(color);
					return box;
				}
				case "mesh":
				case "linkedmesh": {
					var path = this.getValue(map, "path", name);
					var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
					if (mesh == null)
						return null;
					mesh.path = path;
					var color = this.getValue(map, "color", null);
					if (color != null)
						mesh.color.setFromString(color);
					var parent_4 = this.getValue(map, "parent", null);
					if (parent_4 != null) {
						mesh.inheritDeform = this.getValue(map, "deform", true);
						this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_4));
						return mesh;
					}
					var uvs = map.uvs;
					this.readVertices(map, mesh, uvs.length);
					mesh.triangles = map.triangles;
					mesh.regionUVs = uvs;
					mesh.updateUVs();
					mesh.hullLength = this.getValue(map, "hull", 0) * 2;
					return mesh;
				}
				case "path": {
					var path = this.attachmentLoader.newPathAttachment(skin, name);
					if (path == null)
						return null;
					path.closed = this.getValue(map, "closed", false);
					path.constantSpeed = this.getValue(map, "constantSpeed", true);
					var vertexCount = map.vertexCount;
					this.readVertices(map, path, vertexCount << 1);
					var lengths = spine.Utils.newArray(vertexCount / 3, 0);
					for (var i = 0; i < map.lengths.length; i++)
						lengths[i] = map.lengths[i] * scale;
					path.lengths = lengths;
					var color = this.getValue(map, "color", null);
					if (color != null)
						path.color.setFromString(color);
					return path;
				}
				case "point": {
					var point = this.attachmentLoader.newPointAttachment(skin, name);
					if (point == null)
						return null;
					point.x = this.getValue(map, "x", 0) * scale;
					point.y = this.getValue(map, "y", 0) * scale;
					point.rotation = this.getValue(map, "rotation", 0);
					var color = this.getValue(map, "color", null);
					if (color != null)
						point.color.setFromString(color);
					return point;
				}
				case "clipping": {
					var clip = this.attachmentLoader.newClippingAttachment(skin, name);
					if (clip == null)
						return null;
					var end = this.getValue(map, "end", null);
					if (end != null) {
						var slot = skeletonData.findSlot(end);
						if (slot == null)
							throw new Error("Clipping end slot not found: " + end);
						clip.endSlot = slot;
					}
					var vertexCount = map.vertexCount;
					this.readVertices(map, clip, vertexCount << 1);
					var color = this.getValue(map, "color", null);
					if (color != null)
						clip.color.setFromString(color);
					return clip;
				}
			}
			return null;
		};
		SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {
			var scale = this.scale;
			attachment.worldVerticesLength = verticesLength;
			var vertices = map.vertices;
			if (verticesLength == vertices.length) {
				var scaledVertices = spine.Utils.toFloatArray(vertices);
				if (scale != 1) {
					for (var i = 0, n = vertices.length; i < n; i++)
						scaledVertices[i] *= scale;
				}
				attachment.vertices = scaledVertices;
				return;
			}
			var weights = new Array();
			var bones = new Array();
			for (var i = 0, n = vertices.length; i < n;) {
				var boneCount = vertices[i++];
				bones.push(boneCount);
				for (var nn = i + boneCount * 4; i < nn; i += 4) {
					bones.push(vertices[i]);
					weights.push(vertices[i + 1] * scale);
					weights.push(vertices[i + 2] * scale);
					weights.push(vertices[i + 3]);
				}
			}
			attachment.bones = bones;
			attachment.vertices = spine.Utils.toFloatArray(weights);
		};
		SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {
			var scale = this.scale;
			var timelines = new Array();
			var duration = 0;
			if (map.slots) {
				for (var slotName in map.slots) {
					var slotMap = map.slots[slotName];
					var slotIndex = skeletonData.findSlotIndex(slotName);
					if (slotIndex == -1)
						throw new Error("Slot not found: " + slotName);
					for (var timelineName in slotMap) {
						var timelineMap = slotMap[timelineName];
						if (timelineName == "attachment") {
							var timeline = new spine.AttachmentTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
						}
						else if (timelineName == "color") {
							var timeline = new spine.ColorTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var color = new spine.Color();
								color.setFromString(valueMap.color);
								timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);
						}
						else if (timelineName == "twoColor") {
							var timeline = new spine.TwoColorTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var light = new spine.Color();
								var dark = new spine.Color();
								light.setFromString(valueMap.light);
								dark.setFromString(valueMap.dark);
								timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);
						}
						else
							throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
					}
				}
			}
			if (map.bones) {
				for (var boneName in map.bones) {
					var boneMap = map.bones[boneName];
					var boneIndex = skeletonData.findBoneIndex(boneName);
					if (boneIndex == -1)
						throw new Error("Bone not found: " + boneName);
					for (var timelineName in boneMap) {
						var timelineMap = boneMap[timelineName];
						if (timelineName === "rotate") {
							var timeline = new spine.RotateTimeline(timelineMap.length);
							timeline.boneIndex = boneIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);
						}
						else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
							var timeline = null;
							var timelineScale = 1;
							if (timelineName === "scale")
								timeline = new spine.ScaleTimeline(timelineMap.length);
							else if (timelineName === "shear")
								timeline = new spine.ShearTimeline(timelineMap.length);
							else {
								timeline = new spine.TranslateTimeline(timelineMap.length);
								timelineScale = scale;
							}
							timeline.boneIndex = boneIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var x = this.getValue(valueMap, "x", 0), y = this.getValue(valueMap, "y", 0);
								timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);
						}
						else
							throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
					}
				}
			}
			if (map.ik) {
				for (var constraintName in map.ik) {
					var constraintMap = map.ik[constraintName];
					var constraint = skeletonData.findIkConstraint(constraintName);
					var timeline = new spine.IkConstraintTimeline(constraintMap.length);
					timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
					var frameIndex = 0;
					for (var i = 0; i < constraintMap.length; i++) {
						var valueMap = constraintMap[i];
						timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1);
						this.readCurve(valueMap, timeline, frameIndex);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);
				}
			}
			if (map.transform) {
				for (var constraintName in map.transform) {
					var constraintMap = map.transform[constraintName];
					var constraint = skeletonData.findTransformConstraint(constraintName);
					var timeline = new spine.TransformConstraintTimeline(constraintMap.length);
					timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
					var frameIndex = 0;
					for (var i = 0; i < constraintMap.length; i++) {
						var valueMap = constraintMap[i];
						timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
						this.readCurve(valueMap, timeline, frameIndex);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);
				}
			}
			if (map.paths) {
				for (var constraintName in map.paths) {
					var constraintMap = map.paths[constraintName];
					var index = skeletonData.findPathConstraintIndex(constraintName);
					if (index == -1)
						throw new Error("Path constraint not found: " + constraintName);
					var data = skeletonData.pathConstraints[index];
					for (var timelineName in constraintMap) {
						var timelineMap = constraintMap[timelineName];
						if (timelineName === "position" || timelineName === "spacing") {
							var timeline = null;
							var timelineScale = 1;
							if (timelineName === "spacing") {
								timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);
								if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
									timelineScale = scale;
							}
							else {
								timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);
								if (data.positionMode == spine.PositionMode.Fixed)
									timelineScale = scale;
							}
							timeline.pathConstraintIndex = index;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
						}
						else if (timelineName === "mix") {
							var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);
							timeline.pathConstraintIndex = index;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
						}
					}
				}
			}
			if (map.deform) {
				for (var deformName in map.deform) {
					var deformMap = map.deform[deformName];
					var skin = skeletonData.findSkin(deformName);
					if (skin == null)
						throw new Error("Skin not found: " + deformName);
					for (var slotName in deformMap) {
						var slotMap = deformMap[slotName];
						var slotIndex = skeletonData.findSlotIndex(slotName);
						if (slotIndex == -1)
							throw new Error("Slot not found: " + slotMap.name);
						for (var timelineName in slotMap) {
							var timelineMap = slotMap[timelineName];
							var attachment = skin.getAttachment(slotIndex, timelineName);
							if (attachment == null)
								throw new Error("Deform attachment not found: " + timelineMap.name);
							var weighted = attachment.bones != null;
							var vertices = attachment.vertices;
							var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
							var timeline = new spine.DeformTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							timeline.attachment = attachment;
							var frameIndex = 0;
							for (var j = 0; j < timelineMap.length; j++) {
								var valueMap = timelineMap[j];
								var deform = void 0;
								var verticesValue = this.getValue(valueMap, "vertices", null);
								if (verticesValue == null)
									deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;
								else {
									deform = spine.Utils.newFloatArray(deformLength);
									var start = this.getValue(valueMap, "offset", 0);
									spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
									if (scale != 1) {
										for (var i = start, n = i + verticesValue.length; i < n; i++)
											deform[i] *= scale;
									}
									if (!weighted) {
										for (var i = 0; i < deformLength; i++)
											deform[i] += vertices[i];
									}
								}
								timeline.setFrame(frameIndex, valueMap.time, deform);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
						}
					}
				}
			}
			var drawOrderNode = map.drawOrder;
			if (drawOrderNode == null)
				drawOrderNode = map.draworder;
			if (drawOrderNode != null) {
				var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);
				var slotCount = skeletonData.slots.length;
				var frameIndex = 0;
				for (var j = 0; j < drawOrderNode.length; j++) {
					var drawOrderMap = drawOrderNode[j];
					var drawOrder = null;
					var offsets = this.getValue(drawOrderMap, "offsets", null);
					if (offsets != null) {
						drawOrder = spine.Utils.newArray(slotCount, -1);
						var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);
						var originalIndex = 0, unchangedIndex = 0;
						for (var i = 0; i < offsets.length; i++) {
							var offsetMap = offsets[i];
							var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
							if (slotIndex == -1)
								throw new Error("Slot not found: " + offsetMap.slot);
							while (originalIndex != slotIndex)
								unchanged[unchangedIndex++] = originalIndex++;
							drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
						}
						while (originalIndex < slotCount)
							unchanged[unchangedIndex++] = originalIndex++;
						for (var i = slotCount - 1; i >= 0; i--)
							if (drawOrder[i] == -1)
								drawOrder[i] = unchanged[--unchangedIndex];
					}
					timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
			}
			if (map.events) {
				var timeline = new spine.EventTimeline(map.events.length);
				var frameIndex = 0;
				for (var i = 0; i < map.events.length; i++) {
					var eventMap = map.events[i];
					var eventData = skeletonData.findEvent(eventMap.name);
					if (eventData == null)
						throw new Error("Event not found: " + eventMap.name);
					var event_5 = new spine.Event(eventMap.time, eventData);
					event_5.intValue = this.getValue(eventMap, "int", eventData.intValue);
					event_5.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
					event_5.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
					timeline.setFrame(frameIndex++, event_5);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
			}
			if (isNaN(duration)) {
				throw new Error("Error while parsing animation, duration is NaN");
			}
			skeletonData.animations.push(new spine.Animation(name, timelines, duration));
		};
		SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {
			if (!map.curve)
				return;
			if (map.curve === "stepped")
				timeline.setStepped(frameIndex);
			else if (Object.prototype.toString.call(map.curve) === '[object Array]') {
				var curve = map.curve;
				timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
			}
		};
		SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {
			return map[prop] !== undefined ? map[prop] : defaultValue;
		};
		SkeletonJson.blendModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "normal")
				return spine.BlendMode.Normal;
			if (str == "additive")
				return spine.BlendMode.Additive;
			if (str == "multiply")
				return spine.BlendMode.Multiply;
			if (str == "screen")
				return spine.BlendMode.Screen;
			throw new Error("Unknown blend mode: " + str);
		};
		SkeletonJson.positionModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "fixed")
				return spine.PositionMode.Fixed;
			if (str == "percent")
				return spine.PositionMode.Percent;
			throw new Error("Unknown position mode: " + str);
		};
		SkeletonJson.spacingModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "length")
				return spine.SpacingMode.Length;
			if (str == "fixed")
				return spine.SpacingMode.Fixed;
			if (str == "percent")
				return spine.SpacingMode.Percent;
			throw new Error("Unknown position mode: " + str);
		};
		SkeletonJson.rotateModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "tangent")
				return spine.RotateMode.Tangent;
			if (str == "chain")
				return spine.RotateMode.Chain;
			if (str == "chainscale")
				return spine.RotateMode.ChainScale;
			throw new Error("Unknown rotate mode: " + str);
		};
		SkeletonJson.transformModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "normal")
				return spine.TransformMode.Normal;
			if (str == "onlytranslation")
				return spine.TransformMode.OnlyTranslation;
			if (str == "norotationorreflection")
				return spine.TransformMode.NoRotationOrReflection;
			if (str == "noscale")
				return spine.TransformMode.NoScale;
			if (str == "noscaleorreflection")
				return spine.TransformMode.NoScaleOrReflection;
			throw new Error("Unknown transform mode: " + str);
		};
		return SkeletonJson;
	}());
	spine.SkeletonJson = SkeletonJson;
	var LinkedMesh = (function () {
		function LinkedMesh(mesh, skin, slotIndex, parent) {
			this.mesh = mesh;
			this.skin = skin;
			this.slotIndex = slotIndex;
			this.parent = parent;
		}
		return LinkedMesh;
	}());
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Skin = (function () {
		function Skin(name) {
			this.attachments = new Array();
			if (name == null)
				throw new Error("name cannot be null.");
			this.name = name;
		}
		Skin.prototype.addAttachment = function (slotIndex, name, attachment) {
			if (attachment == null)
				throw new Error("attachment cannot be null.");
			var attachments = this.attachments;
			if (slotIndex >= attachments.length)
				attachments.length = slotIndex + 1;
			if (!attachments[slotIndex])
				attachments[slotIndex] = {};
			attachments[slotIndex][name] = attachment;
		};
		Skin.prototype.getAttachment = function (slotIndex, name) {
			var dictionary = this.attachments[slotIndex];
			return dictionary ? dictionary[name] : null;
		};
		Skin.prototype.attachAll = function (skeleton, oldSkin) {
			var slotIndex = 0;
			for (var i = 0; i < skeleton.slots.length; i++) {
				var slot = skeleton.slots[i];
				var slotAttachment = slot.getAttachment();
				if (slotAttachment && slotIndex < oldSkin.attachments.length) {
					var dictionary = oldSkin.attachments[slotIndex];
					for (var key in dictionary) {
						var skinAttachment = dictionary[key];
						if (slotAttachment == skinAttachment) {
							var attachment = this.getAttachment(slotIndex, key);
							if (attachment != null)
								slot.setAttachment(attachment);
							break;
						}
					}
				}
				slotIndex++;
			}
		};
		return Skin;
	}());
	spine.Skin = Skin;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Slot = (function () {
		function Slot(data, bone) {
			this.attachmentVertices = new Array();
			if (data == null)
				throw new Error("data cannot be null.");
			if (bone == null)
				throw new Error("bone cannot be null.");
			this.data = data;
			this.bone = bone;
			this.color = new spine.Color();
			this.darkColor = data.darkColor == null ? null : new spine.Color();
			this.setToSetupPose();
		}
		Slot.prototype.getAttachment = function () {
			return this.attachment;
		};
		Slot.prototype.setAttachment = function (attachment) {
			if (this.attachment == attachment)
				return;
			this.attachment = attachment;
			this.attachmentTime = this.bone.skeleton.time;
			this.attachmentVertices.length = 0;
		};
		Slot.prototype.setAttachmentTime = function (time) {
			this.attachmentTime = this.bone.skeleton.time - time;
		};
		Slot.prototype.getAttachmentTime = function () {
			return this.bone.skeleton.time - this.attachmentTime;
		};
		Slot.prototype.setToSetupPose = function () {
			this.color.setFromColor(this.data.color);
			if (this.darkColor != null)
				this.darkColor.setFromColor(this.data.darkColor);
			if (this.data.attachmentName == null)
				this.attachment = null;
			else {
				this.attachment = null;
				this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
			}
		};
		return Slot;
	}());
	spine.Slot = Slot;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SlotData = (function () {
		function SlotData(index, name, boneData) {
			this.color = new spine.Color(1, 1, 1, 1);
			if (index < 0)
				throw new Error("index must be >= 0.");
			if (name == null)
				throw new Error("name cannot be null.");
			if (boneData == null)
				throw new Error("boneData cannot be null.");
			this.index = index;
			this.name = name;
			this.boneData = boneData;
		}
		return SlotData;
	}());
	spine.SlotData = SlotData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Texture = (function () {
		function Texture(image) {
			this._image = image;
		}
		Texture.prototype.getImage = function () {
			return this._image;
		};
		Texture.filterFromString = function (text) {
			switch (text.toLowerCase()) {
				case "nearest": return TextureFilter.Nearest;
				case "linear": return TextureFilter.Linear;
				case "mipmap": return TextureFilter.MipMap;
				case "mipmapnearestnearest": return TextureFilter.MipMapNearestNearest;
				case "mipmaplinearnearest": return TextureFilter.MipMapLinearNearest;
				case "mipmapnearestlinear": return TextureFilter.MipMapNearestLinear;
				case "mipmaplinearlinear": return TextureFilter.MipMapLinearLinear;
				default: throw new Error("Unknown texture filter " + text);
			}
		};
		Texture.wrapFromString = function (text) {
			switch (text.toLowerCase()) {
				case "mirroredtepeat": return TextureWrap.MirroredRepeat;
				case "clamptoedge": return TextureWrap.ClampToEdge;
				case "repeat": return TextureWrap.Repeat;
				default: throw new Error("Unknown texture wrap " + text);
			}
		};
		return Texture;
	}());
	spine.Texture = Texture;
	(function (TextureFilter) {
		TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
		TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
		TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
		TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
		TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
		TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
		TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
	})(spine.TextureFilter || (spine.TextureFilter = {}));
	var TextureFilter = spine.TextureFilter;
	(function (TextureWrap) {
		TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
		TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
		TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
	})(spine.TextureWrap || (spine.TextureWrap = {}));
	var TextureWrap = spine.TextureWrap;
	var TextureRegion = (function () {
		function TextureRegion() {
			this.u = 0;
			this.v = 0;
			this.u2 = 0;
			this.v2 = 0;
			this.width = 0;
			this.height = 0;
			this.rotate = false;
			this.offsetX = 0;
			this.offsetY = 0;
			this.originalWidth = 0;
			this.originalHeight = 0;
		}
		return TextureRegion;
	}());
	spine.TextureRegion = TextureRegion;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TextureAtlas = (function () {
		function TextureAtlas(atlasText, textureLoader) {
			this.pages = new Array();
			this.regions = new Array();
			this.load(atlasText, textureLoader);
		}
		TextureAtlas.prototype.load = function (atlasText, textureLoader) {
			if (textureLoader == null)
				throw new Error("textureLoader cannot be null.");
			var reader = new TextureAtlasReader(atlasText);
			var tuple = new Array(4);
			var page = null;
			while (true) {
				var line = reader.readLine();
				if (line == null)
					break;
				line = line.trim();
				if (line.length == 0)
					page = null;
				else if (!page) {
					page = new TextureAtlasPage();
					page.name = line;
					if (reader.readTuple(tuple) == 2) {
						page.width = parseInt(tuple[0]);
						page.height = parseInt(tuple[1]);
						reader.readTuple(tuple);
					}
					reader.readTuple(tuple);
					page.minFilter = spine.Texture.filterFromString(tuple[0]);
					page.magFilter = spine.Texture.filterFromString(tuple[1]);
					var direction = reader.readValue();
					page.uWrap = spine.TextureWrap.ClampToEdge;
					page.vWrap = spine.TextureWrap.ClampToEdge;
					if (direction == "x")
						page.uWrap = spine.TextureWrap.Repeat;
					else if (direction == "y")
						page.vWrap = spine.TextureWrap.Repeat;
					else if (direction == "xy")
						page.uWrap = page.vWrap = spine.TextureWrap.Repeat;
					page.texture = textureLoader(line);
					page.texture.setFilters(page.minFilter, page.magFilter);
					page.texture.setWraps(page.uWrap, page.vWrap);
					page.width = page.texture.getImage().width;
					page.height = page.texture.getImage().height;
					this.pages.push(page);
				}
				else {
					var region = new TextureAtlasRegion();
					region.name = line;
					region.page = page;
					region.rotate = reader.readValue() == "true";
					reader.readTuple(tuple);
					var x = parseInt(tuple[0]);
					var y = parseInt(tuple[1]);
					reader.readTuple(tuple);
					var width = parseInt(tuple[0]);
					var height = parseInt(tuple[1]);
					region.u = x / page.width;
					region.v = y / page.height;
					if (region.rotate) {
						region.u2 = (x + height) / page.width;
						region.v2 = (y + width) / page.height;
					}
					else {
						region.u2 = (x + width) / page.width;
						region.v2 = (y + height) / page.height;
					}
					region.x = x;
					region.y = y;
					region.width = Math.abs(width);
					region.height = Math.abs(height);
					if (reader.readTuple(tuple) == 4) {
						if (reader.readTuple(tuple) == 4) {
							reader.readTuple(tuple);
						}
					}
					region.originalWidth = parseInt(tuple[0]);
					region.originalHeight = parseInt(tuple[1]);
					reader.readTuple(tuple);
					region.offsetX = parseInt(tuple[0]);
					region.offsetY = parseInt(tuple[1]);
					region.index = parseInt(reader.readValue());
					region.texture = page.texture;
					this.regions.push(region);
				}
			}
		};
		TextureAtlas.prototype.findRegion = function (name) {
			for (var i = 0; i < this.regions.length; i++) {
				if (this.regions[i].name == name) {
					return this.regions[i];
				}
			}
			return null;
		};
		TextureAtlas.prototype.dispose = function () {
			for (var i = 0; i < this.pages.length; i++) {
				this.pages[i].texture.dispose();
			}
		};
		return TextureAtlas;
	}());
	spine.TextureAtlas = TextureAtlas;
	var TextureAtlasReader = (function () {
		function TextureAtlasReader(text) {
			this.index = 0;
			this.lines = text.split(/\r\n|\r|\n/);
		}
		TextureAtlasReader.prototype.readLine = function () {
			if (this.index >= this.lines.length)
				return null;
			return this.lines[this.index++];
		};
		TextureAtlasReader.prototype.readValue = function () {
			var line = this.readLine();
			var colon = line.indexOf(":");
			if (colon == -1)
				throw new Error("Invalid line: " + line);
			return line.substring(colon + 1).trim();
		};
		TextureAtlasReader.prototype.readTuple = function (tuple) {
			var line = this.readLine();
			var colon = line.indexOf(":");
			if (colon == -1)
				throw new Error("Invalid line: " + line);
			var i = 0, lastMatch = colon + 1;
			for (; i < 3; i++) {
				var comma = line.indexOf(",", lastMatch);
				if (comma == -1)
					break;
				tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
				lastMatch = comma + 1;
			}
			tuple[i] = line.substring(lastMatch).trim();
			return i + 1;
		};
		return TextureAtlasReader;
	}());
	var TextureAtlasPage = (function () {
		function TextureAtlasPage() {
		}
		return TextureAtlasPage;
	}());
	spine.TextureAtlasPage = TextureAtlasPage;
	var TextureAtlasRegion = (function (_super) {
		__extends(TextureAtlasRegion, _super);
		function TextureAtlasRegion() {
			_super.apply(this, arguments);
		}
		return TextureAtlasRegion;
	}(spine.TextureRegion));
	spine.TextureAtlasRegion = TextureAtlasRegion;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TransformConstraint = (function () {
		function TransformConstraint(data, skeleton) {
			this.rotateMix = 0;
			this.translateMix = 0;
			this.scaleMix = 0;
			this.shearMix = 0;
			this.temp = new spine.Vector2();
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
			this.scaleMix = data.scaleMix;
			this.shearMix = data.shearMix;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findBone(data.target.name);
		}
		TransformConstraint.prototype.apply = function () {
			this.update();
		};
		TransformConstraint.prototype.update = function () {
			if (this.data.local) {
				if (this.data.relative)
					this.applyRelativeLocal();
				else
					this.applyAbsoluteLocal();
			}
			else {
				if (this.data.relative)
					this.applyRelativeWorld();
				else
					this.applyAbsoluteWorld();
			}
		};
		TransformConstraint.prototype.applyAbsoluteWorld = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			var ta = target.a, tb = target.b, tc = target.c, td = target.d;
			var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			var offsetRotation = this.data.offsetRotation * degRadReflect;
			var offsetShearY = this.data.offsetShearY * degRadReflect;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				var modified = false;
				if (rotateMix != 0) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
					var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					var cos = Math.cos(r), sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
					modified = true;
				}
				if (translateMix != 0) {
					var temp = this.temp;
					target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
					bone.worldX += (temp.x - bone.worldX) * translateMix;
					bone.worldY += (temp.y - bone.worldY) * translateMix;
					modified = true;
				}
				if (scaleMix > 0) {
					var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
					var ts = Math.sqrt(ta * ta + tc * tc);
					if (s > 0.00001)
						s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
					bone.a *= s;
					bone.c *= s;
					s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
					ts = Math.sqrt(tb * tb + td * td);
					if (s > 0.00001)
						s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
					bone.b *= s;
					bone.d *= s;
					modified = true;
				}
				if (shearMix > 0) {
					var b = bone.b, d = bone.d;
					var by = Math.atan2(d, b);
					var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r = by + (r + offsetShearY) * shearMix;
					var s = Math.sqrt(b * b + d * d);
					bone.b = Math.cos(r) * s;
					bone.d = Math.sin(r) * s;
					modified = true;
				}
				if (modified)
					bone.appliedValid = false;
			}
		};
		TransformConstraint.prototype.applyRelativeWorld = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			var ta = target.a, tb = target.b, tc = target.c, td = target.d;
			var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				var modified = false;
				if (rotateMix != 0) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
					var r = Math.atan2(tc, ta) + offsetRotation;
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					var cos = Math.cos(r), sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
					modified = true;
				}
				if (translateMix != 0) {
					var temp = this.temp;
					target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
					bone.worldX += temp.x * translateMix;
					bone.worldY += temp.y * translateMix;
					modified = true;
				}
				if (scaleMix > 0) {
					var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
					bone.a *= s;
					bone.c *= s;
					s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
					bone.b *= s;
					bone.d *= s;
					modified = true;
				}
				if (shearMix > 0) {
					var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					var b = bone.b, d = bone.d;
					r = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;
					var s = Math.sqrt(b * b + d * d);
					bone.b = Math.cos(r) * s;
					bone.d = Math.sin(r) * s;
					modified = true;
				}
				if (modified)
					bone.appliedValid = false;
			}
		};
		TransformConstraint.prototype.applyAbsoluteLocal = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			if (!target.appliedValid)
				target.updateAppliedTransform();
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (!bone.appliedValid)
					bone.updateAppliedTransform();
				var rotation = bone.arotation;
				if (rotateMix != 0) {
					var r = target.arotation - rotation + this.data.offsetRotation;
					r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
					rotation += r * rotateMix;
				}
				var x = bone.ax, y = bone.ay;
				if (translateMix != 0) {
					x += (target.ax - x + this.data.offsetX) * translateMix;
					y += (target.ay - y + this.data.offsetY) * translateMix;
				}
				var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
				if (scaleMix > 0) {
					if (scaleX > 0.00001)
						scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
					if (scaleY > 0.00001)
						scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
				}
				var shearY = bone.ashearY;
				if (shearMix > 0) {
					var r = target.ashearY - shearY + this.data.offsetShearY;
					r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
					bone.shearY += r * shearMix;
				}
				bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
			}
		};
		TransformConstraint.prototype.applyRelativeLocal = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			if (!target.appliedValid)
				target.updateAppliedTransform();
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (!bone.appliedValid)
					bone.updateAppliedTransform();
				var rotation = bone.arotation;
				if (rotateMix != 0)
					rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
				var x = bone.ax, y = bone.ay;
				if (translateMix != 0) {
					x += (target.ax + this.data.offsetX) * translateMix;
					y += (target.ay + this.data.offsetY) * translateMix;
				}
				var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
				if (scaleMix > 0) {
					if (scaleX > 0.00001)
						scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;
					if (scaleY > 0.00001)
						scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;
				}
				var shearY = bone.ashearY;
				if (shearMix > 0)
					shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
				bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
			}
		};
		TransformConstraint.prototype.getOrder = function () {
			return this.data.order;
		};
		return TransformConstraint;
	}());
	spine.TransformConstraint = TransformConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TransformConstraintData = (function () {
		function TransformConstraintData(name) {
			this.order = 0;
			this.bones = new Array();
			this.rotateMix = 0;
			this.translateMix = 0;
			this.scaleMix = 0;
			this.shearMix = 0;
			this.offsetRotation = 0;
			this.offsetX = 0;
			this.offsetY = 0;
			this.offsetScaleX = 0;
			this.offsetScaleY = 0;
			this.offsetShearY = 0;
			this.relative = false;
			this.local = false;
			if (name == null)
				throw new Error("name cannot be null.");
			this.name = name;
		}
		return TransformConstraintData;
	}());
	spine.TransformConstraintData = TransformConstraintData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Triangulator = (function () {
		function Triangulator() {
			this.convexPolygons = new Array();
			this.convexPolygonsIndices = new Array();
			this.indicesArray = new Array();
			this.isConcaveArray = new Array();
			this.triangles = new Array();
			this.polygonPool = new spine.Pool(function () {
				return new Array();
			});
			this.polygonIndicesPool = new spine.Pool(function () {
				return new Array();
			});
		}
		Triangulator.prototype.triangulate = function (verticesArray) {
			var vertices = verticesArray;
			var vertexCount = verticesArray.length >> 1;
			var indices = this.indicesArray;
			indices.length = 0;
			for (var i = 0; i < vertexCount; i++)
				indices[i] = i;
			var isConcave = this.isConcaveArray;
			isConcave.length = 0;
			for (var i = 0, n = vertexCount; i < n; ++i)
				isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);
			var triangles = this.triangles;
			triangles.length = 0;
			while (vertexCount > 3) {
				var previous = vertexCount - 1, i = 0, next = 1;
				while (true) {
					outer: if (!isConcave[i]) {
						var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;
						var p1x = vertices[p1], p1y = vertices[p1 + 1];
						var p2x = vertices[p2], p2y = vertices[p2 + 1];
						var p3x = vertices[p3], p3y = vertices[p3 + 1];
						for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
							if (!isConcave[ii])
								continue;
							var v = indices[ii] << 1;
							var vx = vertices[v], vy = vertices[v + 1];
							if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
								if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
									if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))
										break outer;
								}
							}
						}
						break;
					}
					if (next == 0) {
						do {
							if (!isConcave[i])
								break;
							i--;
						} while (i > 0);
						break;
					}
					previous = i;
					i = next;
					next = (next + 1) % vertexCount;
				}
				triangles.push(indices[(vertexCount + i - 1) % vertexCount]);
				triangles.push(indices[i]);
				triangles.push(indices[(i + 1) % vertexCount]);
				indices.splice(i, 1);
				isConcave.splice(i, 1);
				vertexCount--;
				var previousIndex = (vertexCount + i - 1) % vertexCount;
				var nextIndex = i == vertexCount ? 0 : i;
				isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
				isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);
			}
			if (vertexCount == 3) {
				triangles.push(indices[2]);
				triangles.push(indices[0]);
				triangles.push(indices[1]);
			}
			return triangles;
		};
		Triangulator.prototype.decompose = function (verticesArray, triangles) {
			var vertices = verticesArray;
			var convexPolygons = this.convexPolygons;
			this.polygonPool.freeAll(convexPolygons);
			convexPolygons.length = 0;
			var convexPolygonsIndices = this.convexPolygonsIndices;
			this.polygonIndicesPool.freeAll(convexPolygonsIndices);
			convexPolygonsIndices.length = 0;
			var polygonIndices = this.polygonIndicesPool.obtain();
			polygonIndices.length = 0;
			var polygon = this.polygonPool.obtain();
			polygon.length = 0;
			var fanBaseIndex = -1, lastWinding = 0;
			for (var i = 0, n = triangles.length; i < n; i += 3) {
				var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;
				var x1 = vertices[t1], y1 = vertices[t1 + 1];
				var x2 = vertices[t2], y2 = vertices[t2 + 1];
				var x3 = vertices[t3], y3 = vertices[t3 + 1];
				var merged = false;
				if (fanBaseIndex == t1) {
					var o = polygon.length - 4;
					var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);
					var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
					if (winding1 == lastWinding && winding2 == lastWinding) {
						polygon.push(x3);
						polygon.push(y3);
						polygonIndices.push(t3);
						merged = true;
					}
				}
				if (!merged) {
					if (polygon.length > 0) {
						convexPolygons.push(polygon);
						convexPolygonsIndices.push(polygonIndices);
					}
					else {
						this.polygonPool.free(polygon);
						this.polygonIndicesPool.free(polygonIndices);
					}
					polygon = this.polygonPool.obtain();
					polygon.length = 0;
					polygon.push(x1);
					polygon.push(y1);
					polygon.push(x2);
					polygon.push(y2);
					polygon.push(x3);
					polygon.push(y3);
					polygonIndices = this.polygonIndicesPool.obtain();
					polygonIndices.length = 0;
					polygonIndices.push(t1);
					polygonIndices.push(t2);
					polygonIndices.push(t3);
					lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);
					fanBaseIndex = t1;
				}
			}
			if (polygon.length > 0) {
				convexPolygons.push(polygon);
				convexPolygonsIndices.push(polygonIndices);
			}
			for (var i = 0, n = convexPolygons.length; i < n; i++) {
				polygonIndices = convexPolygonsIndices[i];
				if (polygonIndices.length == 0)
					continue;
				var firstIndex = polygonIndices[0];
				var lastIndex = polygonIndices[polygonIndices.length - 1];
				polygon = convexPolygons[i];
				var o = polygon.length - 4;
				var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];
				var prevX = polygon[o + 2], prevY = polygon[o + 3];
				var firstX = polygon[0], firstY = polygon[1];
				var secondX = polygon[2], secondY = polygon[3];
				var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
				for (var ii = 0; ii < n; ii++) {
					if (ii == i)
						continue;
					var otherIndices = convexPolygonsIndices[ii];
					if (otherIndices.length != 3)
						continue;
					var otherFirstIndex = otherIndices[0];
					var otherSecondIndex = otherIndices[1];
					var otherLastIndex = otherIndices[2];
					var otherPoly = convexPolygons[ii];
					var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];
					if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)
						continue;
					var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
					var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);
					if (winding1 == winding && winding2 == winding) {
						otherPoly.length = 0;
						otherIndices.length = 0;
						polygon.push(x3);
						polygon.push(y3);
						polygonIndices.push(otherLastIndex);
						prevPrevX = prevX;
						prevPrevY = prevY;
						prevX = x3;
						prevY = y3;
						ii = 0;
					}
				}
			}
			for (var i = convexPolygons.length - 1; i >= 0; i--) {
				polygon = convexPolygons[i];
				if (polygon.length == 0) {
					convexPolygons.splice(i, 1);
					this.polygonPool.free(polygon);
					polygonIndices = convexPolygonsIndices[i];
					convexPolygonsIndices.splice(i, 1);
					this.polygonIndicesPool.free(polygonIndices);
				}
			}
			return convexPolygons;
		};
		Triangulator.isConcave = function (index, vertexCount, vertices, indices) {
			var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
			var current = indices[index] << 1;
			var next = indices[(index + 1) % vertexCount] << 1;
			return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
		};
		Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {
			return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
		};
		Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {
			var px = p2x - p1x, py = p2y - p1y;
			return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
		};
		return Triangulator;
	}());
	spine.Triangulator = Triangulator;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IntSet = (function () {
		function IntSet() {
			this.array = new Array();
		}
		IntSet.prototype.add = function (value) {
			var contains = this.contains(value);
			this.array[value | 0] = value | 0;
			return !contains;
		};
		IntSet.prototype.contains = function (value) {
			return this.array[value | 0] != undefined;
		};
		IntSet.prototype.remove = function (value) {
			this.array[value | 0] = undefined;
		};
		IntSet.prototype.clear = function () {
			this.array.length = 0;
		};
		return IntSet;
	}());
	spine.IntSet = IntSet;
	var Color = (function () {
		function Color(r, g, b, a) {
			if (r === void 0) { r = 0; }
			if (g === void 0) { g = 0; }
			if (b === void 0) { b = 0; }
			if (a === void 0) { a = 0; }
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
		}
		Color.prototype.set = function (r, g, b, a) {
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
			this.clamp();
			return this;
		};
		Color.prototype.setFromColor = function (c) {
			this.r = c.r;
			this.g = c.g;
			this.b = c.b;
			this.a = c.a;
			return this;
		};
		Color.prototype.setFromString = function (hex) {
			hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;
			this.r = parseInt(hex.substr(0, 2), 16) / 255.0;
			this.g = parseInt(hex.substr(2, 2), 16) / 255.0;
			this.b = parseInt(hex.substr(4, 2), 16) / 255.0;
			this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;
			return this;
		};
		Color.prototype.add = function (r, g, b, a) {
			this.r += r;
			this.g += g;
			this.b += b;
			this.a += a;
			this.clamp();
			return this;
		};
		Color.prototype.clamp = function () {
			if (this.r < 0)
				this.r = 0;
			else if (this.r > 1)
				this.r = 1;
			if (this.g < 0)
				this.g = 0;
			else if (this.g > 1)
				this.g = 1;
			if (this.b < 0)
				this.b = 0;
			else if (this.b > 1)
				this.b = 1;
			if (this.a < 0)
				this.a = 0;
			else if (this.a > 1)
				this.a = 1;
			return this;
		};
		Color.WHITE = new Color(1, 1, 1, 1);
		Color.RED = new Color(1, 0, 0, 1);
		Color.GREEN = new Color(0, 1, 0, 1);
		Color.BLUE = new Color(0, 0, 1, 1);
		Color.MAGENTA = new Color(1, 0, 1, 1);
		return Color;
	}());
	spine.Color = Color;
	var MathUtils = (function () {
		function MathUtils() {
		}
		MathUtils.clamp = function (value, min, max) {
			if (value < min)
				return min;
			if (value > max)
				return max;
			return value;
		};
		MathUtils.cosDeg = function (degrees) {
			return Math.cos(degrees * MathUtils.degRad);
		};
		MathUtils.sinDeg = function (degrees) {
			return Math.sin(degrees * MathUtils.degRad);
		};
		MathUtils.signum = function (value) {
			return value > 0 ? 1 : value < 0 ? -1 : 0;
		};
		MathUtils.toInt = function (x) {
			return x > 0 ? Math.floor(x) : Math.ceil(x);
		};
		MathUtils.cbrt = function (x) {
			var y = Math.pow(Math.abs(x), 1 / 3);
			return x < 0 ? -y : y;
		};
		MathUtils.PI = 3.1415927;
		MathUtils.PI2 = MathUtils.PI * 2;
		MathUtils.radiansToDegrees = 180 / MathUtils.PI;
		MathUtils.radDeg = MathUtils.radiansToDegrees;
		MathUtils.degreesToRadians = MathUtils.PI / 180;
		MathUtils.degRad = MathUtils.degreesToRadians;
		return MathUtils;
	}());
	spine.MathUtils = MathUtils;
	var Utils = (function () {
		function Utils() {
		}
		Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {
			for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
				dest[j] = source[i];
			}
		};
		Utils.setArraySize = function (array, size, value) {
			if (value === void 0) { value = 0; }
			var oldSize = array.length;
			if (oldSize == size)
				return array;
			array.length = size;
			if (oldSize < size) {
				for (var i = oldSize; i < size; i++)
					array[i] = value;
			}
			return array;
		};
		Utils.ensureArrayCapacity = function (array, size, value) {
			if (value === void 0) { value = 0; }
			if (array.length >= size)
				return array;
			return Utils.setArraySize(array, size, value);
		};
		Utils.newArray = function (size, defaultValue) {
			var array = new Array(size);
			for (var i = 0; i < size; i++)
				array[i] = defaultValue;
			return array;
		};
		Utils.newFloatArray = function (size) {
			if (Utils.SUPPORTS_TYPED_ARRAYS) {
				return new Float32Array(size);
			}
			else {
				var array = new Array(size);
				for (var i = 0; i < array.length; i++)
					array[i] = 0;
				return array;
			}
		};
		Utils.newShortArray = function (size) {
			if (Utils.SUPPORTS_TYPED_ARRAYS) {
				return new Int16Array(size);
			}
			else {
				var array = new Array(size);
				for (var i = 0; i < array.length; i++)
					array[i] = 0;
				return array;
			}
		};
		Utils.toFloatArray = function (array) {
			return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
		};
		Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== "undefined";
		return Utils;
	}());
	spine.Utils = Utils;
	var DebugUtils = (function () {
		function DebugUtils() {
		}
		DebugUtils.logBones = function (skeleton) {
			for (var i = 0; i < skeleton.bones.length; i++) {
				var bone = skeleton.bones[i];
				console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
			}
		};
		return DebugUtils;
	}());
	spine.DebugUtils = DebugUtils;
	var Pool = (function () {
		function Pool(instantiator) {
			this.items = new Array();
			this.instantiator = instantiator;
		}
		Pool.prototype.obtain = function () {
			return this.items.length > 0 ? this.items.pop() : this.instantiator();
		};
		Pool.prototype.free = function (item) {
			if (item.reset)
				item.reset();
			this.items.push(item);
		};
		Pool.prototype.freeAll = function (items) {
			for (var i = 0; i < items.length; i++) {
				if (items[i].reset)
					items[i].reset();
				this.items[i] = items[i];
			}
		};
		Pool.prototype.clear = function () {
			this.items.length = 0;
		};
		return Pool;
	}());
	spine.Pool = Pool;
	var Vector2 = (function () {
		function Vector2(x, y) {
			if (x === void 0) { x = 0; }
			if (y === void 0) { y = 0; }
			this.x = x;
			this.y = y;
		}
		Vector2.prototype.set = function (x, y) {
			this.x = x;
			this.y = y;
			return this;
		};
		Vector2.prototype.length = function () {
			var x = this.x;
			var y = this.y;
			return Math.sqrt(x * x + y * y);
		};
		Vector2.prototype.normalize = function () {
			var len = this.length();
			if (len != 0) {
				this.x /= len;
				this.y /= len;
			}
			return this;
		};
		return Vector2;
	}());
	spine.Vector2 = Vector2;
	var TimeKeeper = (function () {
		function TimeKeeper() {
			this.maxDelta = 0.064;
			this.framesPerSecond = 0;
			this.delta = 0;
			this.totalTime = 0;
			this.lastTime = Date.now() / 1000;
			this.frameCount = 0;
			this.frameTime = 0;
		}
		TimeKeeper.prototype.update = function () {
			var now = Date.now() / 1000;
			this.delta = now - this.lastTime;
			this.frameTime += this.delta;
			this.totalTime += this.delta;
			if (this.delta > this.maxDelta)
				this.delta = this.maxDelta;
			this.lastTime = now;
			this.frameCount++;
			if (this.frameTime > 1) {
				this.framesPerSecond = this.frameCount / this.frameTime;
				this.frameTime = 0;
				this.frameCount = 0;
			}
		};
		return TimeKeeper;
	}());
	spine.TimeKeeper = TimeKeeper;
	var WindowedMean = (function () {
		function WindowedMean(windowSize) {
			if (windowSize === void 0) { windowSize = 32; }
			this.addedValues = 0;
			this.lastValue = 0;
			this.mean = 0;
			this.dirty = true;
			this.values = new Array(windowSize);
		}
		WindowedMean.prototype.hasEnoughData = function () {
			return this.addedValues >= this.values.length;
		};
		WindowedMean.prototype.addValue = function (value) {
			if (this.addedValues < this.values.length)
				this.addedValues++;
			this.values[this.lastValue++] = value;
			if (this.lastValue > this.values.length - 1)
				this.lastValue = 0;
			this.dirty = true;
		};
		WindowedMean.prototype.getMean = function () {
			if (this.hasEnoughData()) {
				if (this.dirty) {
					var mean = 0;
					for (var i = 0; i < this.values.length; i++) {
						mean += this.values[i];
					}
					this.mean = mean / this.values.length;
					this.dirty = false;
				}
				return this.mean;
			}
			else {
				return 0;
			}
		};
		return WindowedMean;
	}());
	spine.WindowedMean = WindowedMean;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var AssetManager = (function (_super) {
			__extends(AssetManager, _super);
			function AssetManager(context, pathPrefix) {
				if (pathPrefix === void 0) { pathPrefix = ""; }
				_super.call(this, function (image) {
					return new spine.webgl.GLTexture(context, image);
				}, pathPrefix);
			}
			return AssetManager;
		}(spine.AssetManager));
		webgl.AssetManager = AssetManager;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var OrthoCamera = (function () {
			function OrthoCamera(viewportWidth, viewportHeight) {
				this.position = new webgl.Vector3(0, 0, 0);
				this.direction = new webgl.Vector3(0, 0, -1);
				this.up = new webgl.Vector3(0, 1, 0);
				this.near = 0;
				this.far = 100;
				this.zoom = 1;
				this.viewportWidth = 0;
				this.viewportHeight = 0;
				this.projectionView = new webgl.Matrix4();
				this.inverseProjectionView = new webgl.Matrix4();
				this.projection = new webgl.Matrix4();
				this.view = new webgl.Matrix4();
				this.tmp = new webgl.Vector3();
				this.viewportWidth = viewportWidth;
				this.viewportHeight = viewportHeight;
				this.update();
			}
			OrthoCamera.prototype.update = function () {
				var projection = this.projection;
				var view = this.view;
				var projectionView = this.projectionView;
				var inverseProjectionView = this.inverseProjectionView;
				var zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;
				projection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);
				view.lookAt(this.position, this.direction, this.up);
				projectionView.set(projection.values);
				projectionView.multiply(view);
				inverseProjectionView.set(projectionView.values).invert();
			};
			OrthoCamera.prototype.screenToWorld = function (screenCoords, screenWidth, screenHeight) {
				var x = screenCoords.x, y = screenHeight - screenCoords.y - 1;
				var tmp = this.tmp;
				tmp.x = (2 * x) / screenWidth - 1;
				tmp.y = (2 * y) / screenHeight - 1;
				tmp.z = (2 * screenCoords.z) - 1;
				tmp.project(this.inverseProjectionView);
				screenCoords.set(tmp.x, tmp.y, tmp.z);
				return screenCoords;
			};
			OrthoCamera.prototype.setViewport = function (viewportWidth, viewportHeight) {
				this.viewportWidth = viewportWidth;
				this.viewportHeight = viewportHeight;
			};
			return OrthoCamera;
		}());
		webgl.OrthoCamera = OrthoCamera;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var GLTexture = (function (_super) {
			__extends(GLTexture, _super);
			function GLTexture(context, image, useMipMaps) {
				if (useMipMaps === void 0) { useMipMaps = false; }
				_super.call(this, image);
				this.texture = null;
				this.boundUnit = 0;
				this.useMipMaps = false;
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				this.useMipMaps = useMipMaps;
				this.restore();
				this.context.addRestorable(this);
			}
			GLTexture.prototype.setFilters = function (minFilter, magFilter) {
				var gl = this.context.gl;
				this.bind();
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			};
			GLTexture.prototype.setWraps = function (uWrap, vWrap) {
				var gl = this.context.gl;
				this.bind();
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);
			};
			GLTexture.prototype.update = function (useMipMaps) {
				var gl = this.context.gl;
				if (!this.texture) {
					this.texture = this.context.gl.createTexture();
				}
				this.bind();
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				if (useMipMaps)
					gl.generateMipmap(gl.TEXTURE_2D);
			};
			GLTexture.prototype.restore = function () {
				this.texture = null;
				this.update(this.useMipMaps);
			};
			GLTexture.prototype.bind = function (unit) {
				if (unit === void 0) { unit = 0; }
				var gl = this.context.gl;
				this.boundUnit = unit;
				gl.activeTexture(gl.TEXTURE0 + unit);
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
			};
			GLTexture.prototype.unbind = function () {
				var gl = this.context.gl;
				gl.activeTexture(gl.TEXTURE0 + this.boundUnit);
				gl.bindTexture(gl.TEXTURE_2D, null);
			};
			GLTexture.prototype.dispose = function () {
				this.context.removeRestorable(this);
				var gl = this.context.gl;
				gl.deleteTexture(this.texture);
			};
			return GLTexture;
		}(spine.Texture));
		webgl.GLTexture = GLTexture;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var Input = (function () {
			function Input(element) {
				this.lastX = 0;
				this.lastY = 0;
				this.buttonDown = false;
				this.currTouch = null;
				this.touchesPool = new spine.Pool(function () {
					return new spine.webgl.Touch(0, 0, 0);
				});
				this.listeners = new Array();
				this.element = element;
				this.setupCallbacks(element);
			}
			Input.prototype.setupCallbacks = function (element) {
				var _this = this;
				element.addEventListener("mousedown", function (ev) {
					if (ev instanceof MouseEvent) {
						var rect = element.getBoundingClientRect();
						var x = ev.clientX - rect.left;
						var y = ev.clientY - rect.top;
						var listeners = _this.listeners;
						for (var i = 0; i < listeners.length; i++) {
							listeners[i].down(x, y);
						}
						_this.lastX = x;
						_this.lastY = y;
						_this.buttonDown = true;
					}
				}, true);
				element.addEventListener("mousemove", function (ev) {
					if (ev instanceof MouseEvent) {
						var rect = element.getBoundingClientRect();
						var x = ev.clientX - rect.left;
						var y = ev.clientY - rect.top;
						var listeners = _this.listeners;
						for (var i = 0; i < listeners.length; i++) {
							if (_this.buttonDown) {
								listeners[i].dragged(x, y);
							}
							else {
								listeners[i].moved(x, y);
							}
						}
						_this.lastX = x;
						_this.lastY = y;
					}
				}, true);
				element.addEventListener("mouseup", function (ev) {
					if (ev instanceof MouseEvent) {
						var rect = element.getBoundingClientRect();
						var x = ev.clientX - rect.left;
						var y = ev.clientY - rect.top;
						var listeners = _this.listeners;
						for (var i = 0; i < listeners.length; i++) {
							listeners[i].up(x, y);
						}
						_this.lastX = x;
						_this.lastY = y;
						_this.buttonDown = false;
					}
				}, true);
				element.addEventListener("touchstart", function (ev) {
					if (_this.currTouch != null)
						return;
					var touches = ev.changedTouches;
					for (var i = 0; i < touches.length; i++) {
						var touch = touches[i];
						var rect = element.getBoundingClientRect();
						var x = touch.clientX - rect.left;
						var y = touch.clientY - rect.top;
						_this.currTouch = _this.touchesPool.obtain();
						_this.currTouch.identifier = touch.identifier;
						_this.currTouch.x = x;
						_this.currTouch.y = y;
						break;
					}
					var listeners = _this.listeners;
					for (var i_1 = 0; i_1 < listeners.length; i_1++) {
						listeners[i_1].down(_this.currTouch.x, _this.currTouch.y);
					}
					console.log("Start " + _this.currTouch.x + ", " + _this.currTouch.y);
					_this.lastX = _this.currTouch.x;
					_this.lastY = _this.currTouch.y;
					_this.buttonDown = true;
					ev.preventDefault();
				}, false);
				element.addEventListener("touchend", function (ev) {
					var touches = ev.changedTouches;
					for (var i = 0; i < touches.length; i++) {
						var touch = touches[i];
						if (_this.currTouch.identifier === touch.identifier) {
							var rect = element.getBoundingClientRect();
							var x = _this.currTouch.x = touch.clientX - rect.left;
							var y = _this.currTouch.y = touch.clientY - rect.top;
							_this.touchesPool.free(_this.currTouch);
							var listeners = _this.listeners;
							for (var i_2 = 0; i_2 < listeners.length; i_2++) {
								listeners[i_2].up(x, y);
							}
							console.log("End " + x + ", " + y);
							_this.lastX = x;
							_this.lastY = y;
							_this.buttonDown = false;
							_this.currTouch = null;
							break;
						}
					}
					ev.preventDefault();
				}, false);
				element.addEventListener("touchcancel", function (ev) {
					var touches = ev.changedTouches;
					for (var i = 0; i < touches.length; i++) {
						var touch = touches[i];
						if (_this.currTouch.identifier === touch.identifier) {
							var rect = element.getBoundingClientRect();
							var x = _this.currTouch.x = touch.clientX - rect.left;
							var y = _this.currTouch.y = touch.clientY - rect.top;
							_this.touchesPool.free(_this.currTouch);
							var listeners = _this.listeners;
							for (var i_3 = 0; i_3 < listeners.length; i_3++) {
								listeners[i_3].up(x, y);
							}
							console.log("End " + x + ", " + y);
							_this.lastX = x;
							_this.lastY = y;
							_this.buttonDown = false;
							_this.currTouch = null;
							break;
						}
					}
					ev.preventDefault();
				}, false);
				element.addEventListener("touchmove", function (ev) {
					if (_this.currTouch == null)
						return;
					var touches = ev.changedTouches;
					for (var i = 0; i < touches.length; i++) {
						var touch = touches[i];
						if (_this.currTouch.identifier === touch.identifier) {
							var rect = element.getBoundingClientRect();
							var x = touch.clientX - rect.left;
							var y = touch.clientY - rect.top;
							var listeners = _this.listeners;
							for (var i_4 = 0; i_4 < listeners.length; i_4++) {
								listeners[i_4].dragged(x, y);
							}
							console.log("Drag " + x + ", " + y);
							_this.lastX = _this.currTouch.x = x;
							_this.lastY = _this.currTouch.y = y;
							break;
						}
					}
					ev.preventDefault();
				}, false);
			};
			Input.prototype.addListener = function (listener) {
				this.listeners.push(listener);
			};
			Input.prototype.removeListener = function (listener) {
				var idx = this.listeners.indexOf(listener);
				if (idx > -1) {
					this.listeners.splice(idx, 1);
				}
			};
			return Input;
		}());
		webgl.Input = Input;
		var Touch = (function () {
			function Touch(identifier, x, y) {
				this.identifier = identifier;
				this.x = x;
				this.y = y;
			}
			return Touch;
		}());
		webgl.Touch = Touch;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var LoadingScreen = (function () {
			function LoadingScreen(renderer) {
				this.logo = null;
				this.spinner = null;
				this.angle = 0;
				this.fadeOut = 0;
				this.timeKeeper = new spine.TimeKeeper();
				this.backgroundColor = new spine.Color(0.135, 0.135, 0.135, 1);
				this.tempColor = new spine.Color();
				this.firstDraw = 0;
				this.renderer = renderer;
				this.timeKeeper.maxDelta = 9;
				if (LoadingScreen.logoImg === null) {
					var isSafari = navigator.userAgent.indexOf("Safari") > -1;
					LoadingScreen.logoImg = new Image();
					LoadingScreen.logoImg.src = LoadingScreen.SPINE_LOGO_DATA;
					if (!isSafari)
						LoadingScreen.logoImg.crossOrigin = "anonymous";
					LoadingScreen.logoImg.onload = function (ev) {
						LoadingScreen.loaded++;
					};
					LoadingScreen.spinnerImg = new Image();
					LoadingScreen.spinnerImg.src = LoadingScreen.SPINNER_DATA;
					if (!isSafari)
						LoadingScreen.spinnerImg.crossOrigin = "anonymous";
					LoadingScreen.spinnerImg.onload = function (ev) {
						LoadingScreen.loaded++;
					};
				}
			}
			LoadingScreen.prototype.draw = function (complete) {
				if (complete === void 0) { complete = false; }
				if (complete && this.fadeOut > LoadingScreen.FADE_SECONDS)
					return;
				this.timeKeeper.update();
				var a = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.75));
				this.angle -= this.timeKeeper.delta * 360 * (1 + 1.5 * Math.pow(a, 5));
				var renderer = this.renderer;
				var canvas = renderer.canvas;
				var gl = renderer.context.gl;
				var oldX = renderer.camera.position.x, oldY = renderer.camera.position.y;
				renderer.camera.position.set(canvas.width / 2, canvas.height / 2, 0);
				renderer.camera.viewportWidth = canvas.width;
				renderer.camera.viewportHeight = canvas.height;
				renderer.resize(webgl.ResizeMode.Stretch);
				if (!complete) {
					gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
					gl.clear(gl.COLOR_BUFFER_BIT);
					this.tempColor.a = 1;
				}
				else {
					this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1);
					if (this.fadeOut > LoadingScreen.FADE_SECONDS) {
						renderer.camera.position.set(oldX, oldY, 0);
						return;
					}
					a = 1 - this.fadeOut / LoadingScreen.FADE_SECONDS;
					this.tempColor.setFromColor(this.backgroundColor);
					this.tempColor.a = 1 - (a - 1) * (a - 1);
					renderer.begin();
					renderer.quad(true, 0, 0, canvas.width, 0, canvas.width, canvas.height, 0, canvas.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor);
					renderer.end();
				}
				this.tempColor.set(1, 1, 1, this.tempColor.a);
				if (LoadingScreen.loaded != 2)
					return;
				if (this.logo === null) {
					this.logo = new webgl.GLTexture(renderer.context, LoadingScreen.logoImg);
					this.spinner = new webgl.GLTexture(renderer.context, LoadingScreen.spinnerImg);
				}
				this.logo.update(false);
				this.spinner.update(false);
				var logoWidth = this.logo.getImage().width;
				var logoHeight = this.logo.getImage().height;
				var spinnerWidth = this.spinner.getImage().width;
				var spinnerHeight = this.spinner.getImage().height;
				renderer.batcher.setBlendMode(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
				renderer.begin();
				renderer.drawTexture(this.logo, (canvas.width - logoWidth) / 2, (canvas.height - logoHeight) / 2, logoWidth, logoHeight, this.tempColor);
				renderer.drawTextureRotated(this.spinner, (canvas.width - spinnerWidth) / 2, (canvas.height - spinnerHeight) / 2, spinnerWidth, spinnerHeight, spinnerWidth / 2, spinnerHeight / 2, this.angle, this.tempColor);
				renderer.end();
				renderer.camera.position.set(oldX, oldY, 0);
			};
			LoadingScreen.FADE_SECONDS = 1;
			LoadingScreen.loaded = 0;
			LoadingScreen.spinnerImg = null;
			LoadingScreen.logoImg = null;
			LoadingScreen.SPINNER_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAChCAMAAAB3TUS6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAYNQTFRFAAAA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AAkTDRyAAAAIB0Uk5TAAABAgMEBQYHCAkKCwwODxAREhMUFRYXGBkaHB0eICEiIyQlJicoKSorLC0uLzAxMjM0Nzg5Ojs8PT4/QEFDRUlKS0xNTk9QUlRWWFlbXF1eYWJjZmhscHF0d3h5e3x+f4CIiYuMj5GSlJWXm56io6arr7rAxcjO0dXe6Onr8fmb5sOOAAADuElEQVQYGe3B+3vTVBwH4M/3nCRt13br2Lozhug2q25gYQubcxqVKYoMCYoKjEsUdSpeiBc0Kl7yp9t2za39pely7PF5zvuiQKc+/e2f8K+f9g2oyQ77Ag4VGX+HketQ0XYYe0JQ0CdhogwF+WFiBgr6JkxUoKCDMMGgoP0w9gdUtB3GfoCKVsPYAVQ0H8YuQUWVMHYGKuJhrAklPQkjJpT0bdj3O9S0FfZ9ADXxP8MjVSiqFfa8B2VVV8+df14QtB4iwn+BpuZEgyM38WMQHDYhnbkgukrIh5ygZ48glyn6KshlL+jbhVRcxCzk0ApiC5CI5kVsgTAy9jiI/WxBGmqIFBMjqwYphwRZaiLNwsjqQdoVSFISGRwjM4OMFUjBRcYCYWT0XZD2SwUS0LzIKCGH2SDja0LxKiJjCrm0gowVFI6aIs1CTouPg5QvUTgSKXMMuVUeBSmEopFITBPGwO8HCYbCTYtImTAWejuI3CMUjmZFT5NjbM/9GvQcMkhADdFRIxxD7aug4wGDFGSVTcLx0MzutQ2CpmmapmmapmmapmmapmmaphWBmGFV6rNNcaLC0GUuv3LROftUo8wJk0a10207sVED6IIf+9673LIwQeW2PaCEJX/A+xYmhTbtQUu46g96SJgQZg9Zwxf+EAMTwuwhm3jkD7EwIdweBn+YhQlh9pA2HvpDTEwIs4es4GN/CMekNOxBJ9D2B10nTAyfW7fT1hjYgZ/xYIUwUcycaiwuv2h3tOcZADr7ud/12c0ru2cWSwQ1UAcixIgImqZpmqZpmqZpmqZpmqZp2v8HMSIcF186t8oghbnlOJt1wnHwl7yOGxwSlHacrjWG8dVuej03OApn7jhHtiyMiZa9yD6haLYTebWOsbDXvQRHwchJWSTkV/rQS+EoWttJaTHkJe56KXcJRZt20jY48nnBy9hE4WjLSbvAkIfwMm5zFG/KyWgRRke3vYwGZDjpZHCMruJltCAFrTtpVYxu1ktzCHKwbSdlGqOreynXGGQpOylljI5uebFbBuSZc2IbhBxmvcj9GiSiZ52+HQO5nPb6TkIqajs9L5eQk7jnddxZgGT0jNOxYSI36+Kdj9oG5OPV6QpB6yJuGAYnqIrecLveYlDUKffIOtREl90+BiWV3cgMlNR0I09DSS030oaSttzILpT0phu5BBWRmyAoiLkJgoIMN8GgoJKb4FBQzU0YUFDdTRhQUNVNcCjIdBMEBdE7buQ8lFRz+97lUFN5fe+qu//aMkeB/gU2ae9y2HgbngAAAABJRU5ErkJggg==";
			LoadingScreen.SPINE_LOGO_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAAZCAYAAACis3k0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAtNJREFUaN7tmT2I1EAUxwN+oWgRT0HFKo0WCkJ6ObmAWFwZbCxsXGysLNJaiCyIoDaSwk4ETzvhmnBaCRbBWoQ01ho4PwotjP8cE337mMy8TLK757mBH3fLTWbe/PbN53neNniqZW8FvAVvQAqugwvgDDgO9niLRyTyJagM/ACPF6bsIl9ZRDac/Cc6tLn5xQdRQ496QlKPLxD5QCDxO9jtGM8QfYoIgUlgCipGCRJL5VvlyOdCU09iEXkCfLSIfCrs7Fab6nOsiafu06iDwES9w/uU1QnDC+ekkVS9vEaDsgVeB0d+z1VDtOGxRaYPboP3Gokb4GgXkZp4chZPJKgvZ3U0XkriK/TIt9YUDllFgTAjGwoaoHqfBhMI58yD4BQ4V6/aHYdfxToftvw9F2SiVroawU2/Cv5C4Thv0KB9S5nxlOd4STxjwUjzSdYlgrYijw2BsEfgsaFcM09lhiys94xXQQwugcvgJrgFLjrEE7WUiTuWCQzt/ZXN7FfqGwuGClyVy2xZAFmfDQvNtwFFSspMDGsD+UTWqu1KoVmVooFEJgKRXw0if85RpISEzwsjzeqWzkjkC4PIJ3MUmQgITAHlQwTFhnZhELkEntfZRwR+AvfAgXmJHOqU02XligWT8ppg67NXbdCXeq7afUQ6L8C2DalEZNt2YyQ94Qy8/ekjMpBMbfyl5iTjG7YAI8cNecROAb4kJmTjaXAF3AGvwQewOiuRxEtlSaT4j2h2lMsUueQEoMlIKpTvAmKhxPMtC876jEX6rE8l8TNx/KVbn6xlWU9NWcSDUsO4NGWpQOTZFpHPOooMXcswmW2XFk3ixb2v0Nq+XVKP00QNaffBLyWwBI/AkTlfMYZDXMf12kc6yjwEjoFdO/5me5oi/6tnyhlZX6OtgmX1c2Uh0k3khmbB2b9TRfpd/jfTUeRDJvHdYg5wE7kPXAN3wQ1weDvH+xufEgpi5qIl3QAAAABJRU5ErkJggg==";
			return LoadingScreen;
		}());
		webgl.LoadingScreen = LoadingScreen;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		webgl.M00 = 0;
		webgl.M01 = 4;
		webgl.M02 = 8;
		webgl.M03 = 12;
		webgl.M10 = 1;
		webgl.M11 = 5;
		webgl.M12 = 9;
		webgl.M13 = 13;
		webgl.M20 = 2;
		webgl.M21 = 6;
		webgl.M22 = 10;
		webgl.M23 = 14;
		webgl.M30 = 3;
		webgl.M31 = 7;
		webgl.M32 = 11;
		webgl.M33 = 15;
		var Matrix4 = (function () {
			function Matrix4() {
				this.temp = new Float32Array(16);
				this.values = new Float32Array(16);
				var v = this.values;
				v[webgl.M00] = 1;
				v[webgl.M11] = 1;
				v[webgl.M22] = 1;
				v[webgl.M33] = 1;
			}
			Matrix4.prototype.set = function (values) {
				this.values.set(values);
				return this;
			};
			Matrix4.prototype.transpose = function () {
				var t = this.temp;
				var v = this.values;
				t[webgl.M00] = v[webgl.M00];
				t[webgl.M01] = v[webgl.M10];
				t[webgl.M02] = v[webgl.M20];
				t[webgl.M03] = v[webgl.M30];
				t[webgl.M10] = v[webgl.M01];
				t[webgl.M11] = v[webgl.M11];
				t[webgl.M12] = v[webgl.M21];
				t[webgl.M13] = v[webgl.M31];
				t[webgl.M20] = v[webgl.M02];
				t[webgl.M21] = v[webgl.M12];
				t[webgl.M22] = v[webgl.M22];
				t[webgl.M23] = v[webgl.M32];
				t[webgl.M30] = v[webgl.M03];
				t[webgl.M31] = v[webgl.M13];
				t[webgl.M32] = v[webgl.M23];
				t[webgl.M33] = v[webgl.M33];
				return this.set(t);
			};
			Matrix4.prototype.identity = function () {
				var v = this.values;
				v[webgl.M00] = 1;
				v[webgl.M01] = 0;
				v[webgl.M02] = 0;
				v[webgl.M03] = 0;
				v[webgl.M10] = 0;
				v[webgl.M11] = 1;
				v[webgl.M12] = 0;
				v[webgl.M13] = 0;
				v[webgl.M20] = 0;
				v[webgl.M21] = 0;
				v[webgl.M22] = 1;
				v[webgl.M23] = 0;
				v[webgl.M30] = 0;
				v[webgl.M31] = 0;
				v[webgl.M32] = 0;
				v[webgl.M33] = 1;
				return this;
			};
			Matrix4.prototype.invert = function () {
				var v = this.values;
				var t = this.temp;
				var l_det = v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]
					+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]
					- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]
					- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]
					+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]
					+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]
					- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]
					- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];
				if (l_det == 0)
					throw new Error("non-invertible matrix");
				var inv_det = 1.0 / l_det;
				t[webgl.M00] = v[webgl.M12] * v[webgl.M23] * v[webgl.M31] - v[webgl.M13] * v[webgl.M22] * v[webgl.M31] + v[webgl.M13] * v[webgl.M21] * v[webgl.M32]
					- v[webgl.M11] * v[webgl.M23] * v[webgl.M32] - v[webgl.M12] * v[webgl.M21] * v[webgl.M33] + v[webgl.M11] * v[webgl.M22] * v[webgl.M33];
				t[webgl.M01] = v[webgl.M03] * v[webgl.M22] * v[webgl.M31] - v[webgl.M02] * v[webgl.M23] * v[webgl.M31] - v[webgl.M03] * v[webgl.M21] * v[webgl.M32]
					+ v[webgl.M01] * v[webgl.M23] * v[webgl.M32] + v[webgl.M02] * v[webgl.M21] * v[webgl.M33] - v[webgl.M01] * v[webgl.M22] * v[webgl.M33];
				t[webgl.M02] = v[webgl.M02] * v[webgl.M13] * v[webgl.M31] - v[webgl.M03] * v[webgl.M12] * v[webgl.M31] + v[webgl.M03] * v[webgl.M11] * v[webgl.M32]
					- v[webgl.M01] * v[webgl.M13] * v[webgl.M32] - v[webgl.M02] * v[webgl.M11] * v[webgl.M33] + v[webgl.M01] * v[webgl.M12] * v[webgl.M33];
				t[webgl.M03] = v[webgl.M03] * v[webgl.M12] * v[webgl.M21] - v[webgl.M02] * v[webgl.M13] * v[webgl.M21] - v[webgl.M03] * v[webgl.M11] * v[webgl.M22]
					+ v[webgl.M01] * v[webgl.M13] * v[webgl.M22] + v[webgl.M02] * v[webgl.M11] * v[webgl.M23] - v[webgl.M01] * v[webgl.M12] * v[webgl.M23];
				t[webgl.M10] = v[webgl.M13] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M20] * v[webgl.M32]
					+ v[webgl.M10] * v[webgl.M23] * v[webgl.M32] + v[webgl.M12] * v[webgl.M20] * v[webgl.M33] - v[webgl.M10] * v[webgl.M22] * v[webgl.M33];
				t[webgl.M11] = v[webgl.M02] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M22] * v[webgl.M30] + v[webgl.M03] * v[webgl.M20] * v[webgl.M32]
					- v[webgl.M00] * v[webgl.M23] * v[webgl.M32] - v[webgl.M02] * v[webgl.M20] * v[webgl.M33] + v[webgl.M00] * v[webgl.M22] * v[webgl.M33];
				t[webgl.M12] = v[webgl.M03] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M10] * v[webgl.M32]
					+ v[webgl.M00] * v[webgl.M13] * v[webgl.M32] + v[webgl.M02] * v[webgl.M10] * v[webgl.M33] - v[webgl.M00] * v[webgl.M12] * v[webgl.M33];
				t[webgl.M13] = v[webgl.M02] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M12] * v[webgl.M20] + v[webgl.M03] * v[webgl.M10] * v[webgl.M22]
					- v[webgl.M00] * v[webgl.M13] * v[webgl.M22] - v[webgl.M02] * v[webgl.M10] * v[webgl.M23] + v[webgl.M00] * v[webgl.M12] * v[webgl.M23];
				t[webgl.M20] = v[webgl.M11] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M21] * v[webgl.M30] + v[webgl.M13] * v[webgl.M20] * v[webgl.M31]
					- v[webgl.M10] * v[webgl.M23] * v[webgl.M31] - v[webgl.M11] * v[webgl.M20] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M33];
				t[webgl.M21] = v[webgl.M03] * v[webgl.M21] * v[webgl.M30] - v[webgl.M01] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M20] * v[webgl.M31]
					+ v[webgl.M00] * v[webgl.M23] * v[webgl.M31] + v[webgl.M01] * v[webgl.M20] * v[webgl.M33] - v[webgl.M00] * v[webgl.M21] * v[webgl.M33];
				t[webgl.M22] = v[webgl.M01] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M11] * v[webgl.M30] + v[webgl.M03] * v[webgl.M10] * v[webgl.M31]
					- v[webgl.M00] * v[webgl.M13] * v[webgl.M31] - v[webgl.M01] * v[webgl.M10] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M33];
				t[webgl.M23] = v[webgl.M03] * v[webgl.M11] * v[webgl.M20] - v[webgl.M01] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M10] * v[webgl.M21]
					+ v[webgl.M00] * v[webgl.M13] * v[webgl.M21] + v[webgl.M01] * v[webgl.M10] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M23];
				t[webgl.M30] = v[webgl.M12] * v[webgl.M21] * v[webgl.M30] - v[webgl.M11] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M20] * v[webgl.M31]
					+ v[webgl.M10] * v[webgl.M22] * v[webgl.M31] + v[webgl.M11] * v[webgl.M20] * v[webgl.M32] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32];
				t[webgl.M31] = v[webgl.M01] * v[webgl.M22] * v[webgl.M30] - v[webgl.M02] * v[webgl.M21] * v[webgl.M30] + v[webgl.M02] * v[webgl.M20] * v[webgl.M31]
					- v[webgl.M00] * v[webgl.M22] * v[webgl.M31] - v[webgl.M01] * v[webgl.M20] * v[webgl.M32] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32];
				t[webgl.M32] = v[webgl.M02] * v[webgl.M11] * v[webgl.M30] - v[webgl.M01] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M10] * v[webgl.M31]
					+ v[webgl.M00] * v[webgl.M12] * v[webgl.M31] + v[webgl.M01] * v[webgl.M10] * v[webgl.M32] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32];
				t[webgl.M33] = v[webgl.M01] * v[webgl.M12] * v[webgl.M20] - v[webgl.M02] * v[webgl.M11] * v[webgl.M20] + v[webgl.M02] * v[webgl.M10] * v[webgl.M21]
					- v[webgl.M00] * v[webgl.M12] * v[webgl.M21] - v[webgl.M01] * v[webgl.M10] * v[webgl.M22] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22];
				v[webgl.M00] = t[webgl.M00] * inv_det;
				v[webgl.M01] = t[webgl.M01] * inv_det;
				v[webgl.M02] = t[webgl.M02] * inv_det;
				v[webgl.M03] = t[webgl.M03] * inv_det;
				v[webgl.M10] = t[webgl.M10] * inv_det;
				v[webgl.M11] = t[webgl.M11] * inv_det;
				v[webgl.M12] = t[webgl.M12] * inv_det;
				v[webgl.M13] = t[webgl.M13] * inv_det;
				v[webgl.M20] = t[webgl.M20] * inv_det;
				v[webgl.M21] = t[webgl.M21] * inv_det;
				v[webgl.M22] = t[webgl.M22] * inv_det;
				v[webgl.M23] = t[webgl.M23] * inv_det;
				v[webgl.M30] = t[webgl.M30] * inv_det;
				v[webgl.M31] = t[webgl.M31] * inv_det;
				v[webgl.M32] = t[webgl.M32] * inv_det;
				v[webgl.M33] = t[webgl.M33] * inv_det;
				return this;
			};
			Matrix4.prototype.determinant = function () {
				var v = this.values;
				return v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]
					+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]
					- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]
					- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]
					+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]
					+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]
					- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]
					- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];
			};
			Matrix4.prototype.translate = function (x, y, z) {
				var v = this.values;
				v[webgl.M03] += x;
				v[webgl.M13] += y;
				v[webgl.M23] += z;
				return this;
			};
			Matrix4.prototype.copy = function () {
				return new Matrix4().set(this.values);
			};
			Matrix4.prototype.projection = function (near, far, fovy, aspectRatio) {
				this.identity();
				var l_fd = (1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));
				var l_a1 = (far + near) / (near - far);
				var l_a2 = (2 * far * near) / (near - far);
				var v = this.values;
				v[webgl.M00] = l_fd / aspectRatio;
				v[webgl.M10] = 0;
				v[webgl.M20] = 0;
				v[webgl.M30] = 0;
				v[webgl.M01] = 0;
				v[webgl.M11] = l_fd;
				v[webgl.M21] = 0;
				v[webgl.M31] = 0;
				v[webgl.M02] = 0;
				v[webgl.M12] = 0;
				v[webgl.M22] = l_a1;
				v[webgl.M32] = -1;
				v[webgl.M03] = 0;
				v[webgl.M13] = 0;
				v[webgl.M23] = l_a2;
				v[webgl.M33] = 0;
				return this;
			};
			Matrix4.prototype.ortho2d = function (x, y, width, height) {
				return this.ortho(x, x + width, y, y + height, 0, 1);
			};
			Matrix4.prototype.ortho = function (left, right, bottom, top, near, far) {
				this.identity();
				var x_orth = 2 / (right - left);
				var y_orth = 2 / (top - bottom);
				var z_orth = -2 / (far - near);
				var tx = -(right + left) / (right - left);
				var ty = -(top + bottom) / (top - bottom);
				var tz = -(far + near) / (far - near);
				var v = this.values;
				v[webgl.M00] = x_orth;
				v[webgl.M10] = 0;
				v[webgl.M20] = 0;
				v[webgl.M30] = 0;
				v[webgl.M01] = 0;
				v[webgl.M11] = y_orth;
				v[webgl.M21] = 0;
				v[webgl.M31] = 0;
				v[webgl.M02] = 0;
				v[webgl.M12] = 0;
				v[webgl.M22] = z_orth;
				v[webgl.M32] = 0;
				v[webgl.M03] = tx;
				v[webgl.M13] = ty;
				v[webgl.M23] = tz;
				v[webgl.M33] = 1;
				return this;
			};
			Matrix4.prototype.multiply = function (matrix) {
				var t = this.temp;
				var v = this.values;
				var m = matrix.values;
				t[webgl.M00] = v[webgl.M00] * m[webgl.M00] + v[webgl.M01] * m[webgl.M10] + v[webgl.M02] * m[webgl.M20] + v[webgl.M03] * m[webgl.M30];
				t[webgl.M01] = v[webgl.M00] * m[webgl.M01] + v[webgl.M01] * m[webgl.M11] + v[webgl.M02] * m[webgl.M21] + v[webgl.M03] * m[webgl.M31];
				t[webgl.M02] = v[webgl.M00] * m[webgl.M02] + v[webgl.M01] * m[webgl.M12] + v[webgl.M02] * m[webgl.M22] + v[webgl.M03] * m[webgl.M32];
				t[webgl.M03] = v[webgl.M00] * m[webgl.M03] + v[webgl.M01] * m[webgl.M13] + v[webgl.M02] * m[webgl.M23] + v[webgl.M03] * m[webgl.M33];
				t[webgl.M10] = v[webgl.M10] * m[webgl.M00] + v[webgl.M11] * m[webgl.M10] + v[webgl.M12] * m[webgl.M20] + v[webgl.M13] * m[webgl.M30];
				t[webgl.M11] = v[webgl.M10] * m[webgl.M01] + v[webgl.M11] * m[webgl.M11] + v[webgl.M12] * m[webgl.M21] + v[webgl.M13] * m[webgl.M31];
				t[webgl.M12] = v[webgl.M10] * m[webgl.M02] + v[webgl.M11] * m[webgl.M12] + v[webgl.M12] * m[webgl.M22] + v[webgl.M13] * m[webgl.M32];
				t[webgl.M13] = v[webgl.M10] * m[webgl.M03] + v[webgl.M11] * m[webgl.M13] + v[webgl.M12] * m[webgl.M23] + v[webgl.M13] * m[webgl.M33];
				t[webgl.M20] = v[webgl.M20] * m[webgl.M00] + v[webgl.M21] * m[webgl.M10] + v[webgl.M22] * m[webgl.M20] + v[webgl.M23] * m[webgl.M30];
				t[webgl.M21] = v[webgl.M20] * m[webgl.M01] + v[webgl.M21] * m[webgl.M11] + v[webgl.M22] * m[webgl.M21] + v[webgl.M23] * m[webgl.M31];
				t[webgl.M22] = v[webgl.M20] * m[webgl.M02] + v[webgl.M21] * m[webgl.M12] + v[webgl.M22] * m[webgl.M22] + v[webgl.M23] * m[webgl.M32];
				t[webgl.M23] = v[webgl.M20] * m[webgl.M03] + v[webgl.M21] * m[webgl.M13] + v[webgl.M22] * m[webgl.M23] + v[webgl.M23] * m[webgl.M33];
				t[webgl.M30] = v[webgl.M30] * m[webgl.M00] + v[webgl.M31] * m[webgl.M10] + v[webgl.M32] * m[webgl.M20] + v[webgl.M33] * m[webgl.M30];
				t[webgl.M31] = v[webgl.M30] * m[webgl.M01] + v[webgl.M31] * m[webgl.M11] + v[webgl.M32] * m[webgl.M21] + v[webgl.M33] * m[webgl.M31];
				t[webgl.M32] = v[webgl.M30] * m[webgl.M02] + v[webgl.M31] * m[webgl.M12] + v[webgl.M32] * m[webgl.M22] + v[webgl.M33] * m[webgl.M32];
				t[webgl.M33] = v[webgl.M30] * m[webgl.M03] + v[webgl.M31] * m[webgl.M13] + v[webgl.M32] * m[webgl.M23] + v[webgl.M33] * m[webgl.M33];
				return this.set(this.temp);
			};
			Matrix4.prototype.multiplyLeft = function (matrix) {
				var t = this.temp;
				var v = this.values;
				var m = matrix.values;
				t[webgl.M00] = m[webgl.M00] * v[webgl.M00] + m[webgl.M01] * v[webgl.M10] + m[webgl.M02] * v[webgl.M20] + m[webgl.M03] * v[webgl.M30];
				t[webgl.M01] = m[webgl.M00] * v[webgl.M01] + m[webgl.M01] * v[webgl.M11] + m[webgl.M02] * v[webgl.M21] + m[webgl.M03] * v[webgl.M31];
				t[webgl.M02] = m[webgl.M00] * v[webgl.M02] + m[webgl.M01] * v[webgl.M12] + m[webgl.M02] * v[webgl.M22] + m[webgl.M03] * v[webgl.M32];
				t[webgl.M03] = m[webgl.M00] * v[webgl.M03] + m[webgl.M01] * v[webgl.M13] + m[webgl.M02] * v[webgl.M23] + m[webgl.M03] * v[webgl.M33];
				t[webgl.M10] = m[webgl.M10] * v[webgl.M00] + m[webgl.M11] * v[webgl.M10] + m[webgl.M12] * v[webgl.M20] + m[webgl.M13] * v[webgl.M30];
				t[webgl.M11] = m[webgl.M10] * v[webgl.M01] + m[webgl.M11] * v[webgl.M11] + m[webgl.M12] * v[webgl.M21] + m[webgl.M13] * v[webgl.M31];
				t[webgl.M12] = m[webgl.M10] * v[webgl.M02] + m[webgl.M11] * v[webgl.M12] + m[webgl.M12] * v[webgl.M22] + m[webgl.M13] * v[webgl.M32];
				t[webgl.M13] = m[webgl.M10] * v[webgl.M03] + m[webgl.M11] * v[webgl.M13] + m[webgl.M12] * v[webgl.M23] + m[webgl.M13] * v[webgl.M33];
				t[webgl.M20] = m[webgl.M20] * v[webgl.M00] + m[webgl.M21] * v[webgl.M10] + m[webgl.M22] * v[webgl.M20] + m[webgl.M23] * v[webgl.M30];
				t[webgl.M21] = m[webgl.M20] * v[webgl.M01] + m[webgl.M21] * v[webgl.M11] + m[webgl.M22] * v[webgl.M21] + m[webgl.M23] * v[webgl.M31];
				t[webgl.M22] = m[webgl.M20] * v[webgl.M02] + m[webgl.M21] * v[webgl.M12] + m[webgl.M22] * v[webgl.M22] + m[webgl.M23] * v[webgl.M32];
				t[webgl.M23] = m[webgl.M20] * v[webgl.M03] + m[webgl.M21] * v[webgl.M13] + m[webgl.M22] * v[webgl.M23] + m[webgl.M23] * v[webgl.M33];
				t[webgl.M30] = m[webgl.M30] * v[webgl.M00] + m[webgl.M31] * v[webgl.M10] + m[webgl.M32] * v[webgl.M20] + m[webgl.M33] * v[webgl.M30];
				t[webgl.M31] = m[webgl.M30] * v[webgl.M01] + m[webgl.M31] * v[webgl.M11] + m[webgl.M32] * v[webgl.M21] + m[webgl.M33] * v[webgl.M31];
				t[webgl.M32] = m[webgl.M30] * v[webgl.M02] + m[webgl.M31] * v[webgl.M12] + m[webgl.M32] * v[webgl.M22] + m[webgl.M33] * v[webgl.M32];
				t[webgl.M33] = m[webgl.M30] * v[webgl.M03] + m[webgl.M31] * v[webgl.M13] + m[webgl.M32] * v[webgl.M23] + m[webgl.M33] * v[webgl.M33];
				return this.set(this.temp);
			};
			Matrix4.prototype.lookAt = function (position, direction, up) {
				Matrix4.initTemps();
				var xAxis = Matrix4.xAxis, yAxis = Matrix4.yAxis, zAxis = Matrix4.zAxis;
				zAxis.setFrom(direction).normalize();
				xAxis.setFrom(direction).normalize();
				xAxis.cross(up).normalize();
				yAxis.setFrom(xAxis).cross(zAxis).normalize();
				this.identity();
				var val = this.values;
				val[webgl.M00] = xAxis.x;
				val[webgl.M01] = xAxis.y;
				val[webgl.M02] = xAxis.z;
				val[webgl.M10] = yAxis.x;
				val[webgl.M11] = yAxis.y;
				val[webgl.M12] = yAxis.z;
				val[webgl.M20] = -zAxis.x;
				val[webgl.M21] = -zAxis.y;
				val[webgl.M22] = -zAxis.z;
				Matrix4.tmpMatrix.identity();
				Matrix4.tmpMatrix.values[webgl.M03] = -position.x;
				Matrix4.tmpMatrix.values[webgl.M13] = -position.y;
				Matrix4.tmpMatrix.values[webgl.M23] = -position.z;
				this.multiply(Matrix4.tmpMatrix);
				return this;
			};
			Matrix4.initTemps = function () {
				if (Matrix4.xAxis === null)
					Matrix4.xAxis = new webgl.Vector3();
				if (Matrix4.yAxis === null)
					Matrix4.yAxis = new webgl.Vector3();
				if (Matrix4.zAxis === null)
					Matrix4.zAxis = new webgl.Vector3();
			};
			Matrix4.xAxis = null;
			Matrix4.yAxis = null;
			Matrix4.zAxis = null;
			Matrix4.tmpMatrix = new Matrix4();
			return Matrix4;
		}());
		webgl.Matrix4 = Matrix4;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var Mesh = (function () {
			function Mesh(context, attributes, maxVertices, maxIndices) {
				this.attributes = attributes;
				this.verticesLength = 0;
				this.dirtyVertices = false;
				this.indicesLength = 0;
				this.dirtyIndices = false;
				this.elementsPerVertex = 0;
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				this.elementsPerVertex = 0;
				for (var i = 0; i < attributes.length; i++) {
					this.elementsPerVertex += attributes[i].numElements;
				}
				this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);
				this.indices = new Uint16Array(maxIndices);
				this.context.addRestorable(this);
			}
			Mesh.prototype.getAttributes = function () { return this.attributes; };
			Mesh.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex; };
			Mesh.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex; };
			Mesh.prototype.setVerticesLength = function (length) {
				this.dirtyVertices = true;
				this.verticesLength = length;
			};
			Mesh.prototype.getVertices = function () { return this.vertices; };
			Mesh.prototype.maxIndices = function () { return this.indices.length; };
			Mesh.prototype.numIndices = function () { return this.indicesLength; };
			Mesh.prototype.setIndicesLength = function (length) {
				this.dirtyIndices = true;
				this.indicesLength = length;
			};
			Mesh.prototype.getIndices = function () { return this.indices; };
			;
			Mesh.prototype.getVertexSizeInFloats = function () {
				var size = 0;
				for (var i = 0; i < this.attributes.length; i++) {
					var attribute = this.attributes[i];
					size += attribute.numElements;
				}
				return size;
			};
			Mesh.prototype.setVertices = function (vertices) {
				this.dirtyVertices = true;
				if (vertices.length > this.vertices.length)
					throw Error("Mesh can't store more than " + this.maxVertices() + " vertices");
				this.vertices.set(vertices, 0);
				this.verticesLength = vertices.length;
			};
			Mesh.prototype.setIndices = function (indices) {
				this.dirtyIndices = true;
				if (indices.length > this.indices.length)
					throw Error("Mesh can't store more than " + this.maxIndices() + " indices");
				this.indices.set(indices, 0);
				this.indicesLength = indices.length;
			};
			Mesh.prototype.draw = function (shader, primitiveType) {
				this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);
			};
			Mesh.prototype.drawWithOffset = function (shader, primitiveType, offset, count) {
				var gl = this.context.gl;
				if (this.dirtyVertices || this.dirtyIndices)
					this.update();
				this.bind(shader);
				if (this.indicesLength > 0) {
					gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);
				}
				else {
					gl.drawArrays(primitiveType, offset, count);
				}
				this.unbind(shader);
			};
			Mesh.prototype.bind = function (shader) {
				var gl = this.context.gl;
				gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
				var offset = 0;
				for (var i = 0; i < this.attributes.length; i++) {
					var attrib = this.attributes[i];
					var location_1 = shader.getAttributeLocation(attrib.name);
					gl.enableVertexAttribArray(location_1);
					gl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);
					offset += attrib.numElements;
				}
				if (this.indicesLength > 0)
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
			};
			Mesh.prototype.unbind = function (shader) {
				var gl = this.context.gl;
				for (var i = 0; i < this.attributes.length; i++) {
					var attrib = this.attributes[i];
					var location_2 = shader.getAttributeLocation(attrib.name);
					gl.disableVertexAttribArray(location_2);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				if (this.indicesLength > 0)
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			};
			Mesh.prototype.update = function () {
				var gl = this.context.gl;
				if (this.dirtyVertices) {
					if (!this.verticesBuffer) {
						this.verticesBuffer = gl.createBuffer();
					}
					gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);
					this.dirtyVertices = false;
				}
				if (this.dirtyIndices) {
					if (!this.indicesBuffer) {
						this.indicesBuffer = gl.createBuffer();
					}
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
					gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);
					this.dirtyIndices = false;
				}
			};
			Mesh.prototype.restore = function () {
				this.verticesBuffer = null;
				this.indicesBuffer = null;
				this.update();
			};
			Mesh.prototype.dispose = function () {
				this.context.removeRestorable(this);
				var gl = this.context.gl;
				gl.deleteBuffer(this.verticesBuffer);
				gl.deleteBuffer(this.indicesBuffer);
			};
			return Mesh;
		}());
		webgl.Mesh = Mesh;
		var VertexAttribute = (function () {
			function VertexAttribute(name, type, numElements) {
				this.name = name;
				this.type = type;
				this.numElements = numElements;
			}
			return VertexAttribute;
		}());
		webgl.VertexAttribute = VertexAttribute;
		var Position2Attribute = (function (_super) {
			__extends(Position2Attribute, _super);
			function Position2Attribute() {
				_super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 2);
			}
			return Position2Attribute;
		}(VertexAttribute));
		webgl.Position2Attribute = Position2Attribute;
		var Position3Attribute = (function (_super) {
			__extends(Position3Attribute, _super);
			function Position3Attribute() {
				_super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 3);
			}
			return Position3Attribute;
		}(VertexAttribute));
		webgl.Position3Attribute = Position3Attribute;
		var TexCoordAttribute = (function (_super) {
			__extends(TexCoordAttribute, _super);
			function TexCoordAttribute(unit) {
				if (unit === void 0) { unit = 0; }
				_super.call(this, webgl.Shader.TEXCOORDS + (unit == 0 ? "" : unit), VertexAttributeType.Float, 2);
			}
			return TexCoordAttribute;
		}(VertexAttribute));
		webgl.TexCoordAttribute = TexCoordAttribute;
		var ColorAttribute = (function (_super) {
			__extends(ColorAttribute, _super);
			function ColorAttribute() {
				_super.call(this, webgl.Shader.COLOR, VertexAttributeType.Float, 4);
			}
			return ColorAttribute;
		}(VertexAttribute));
		webgl.ColorAttribute = ColorAttribute;
		var Color2Attribute = (function (_super) {
			__extends(Color2Attribute, _super);
			function Color2Attribute() {
				_super.call(this, webgl.Shader.COLOR2, VertexAttributeType.Float, 4);
			}
			return Color2Attribute;
		}(VertexAttribute));
		webgl.Color2Attribute = Color2Attribute;
		(function (VertexAttributeType) {
			VertexAttributeType[VertexAttributeType["Float"] = 0] = "Float";
		})(webgl.VertexAttributeType || (webgl.VertexAttributeType = {}));
		var VertexAttributeType = webgl.VertexAttributeType;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var PolygonBatcher = (function () {
			function PolygonBatcher(context, twoColorTint, maxVertices) {
				if (twoColorTint === void 0) { twoColorTint = true; }
				if (maxVertices === void 0) { maxVertices = 10920; }
				this.isDrawing = false;
				this.shader = null;
				this.lastTexture = null;
				this.verticesLength = 0;
				this.indicesLength = 0;
				if (maxVertices > 10920)
					throw new Error("Can't have more than 10920 triangles per batch: " + maxVertices);
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				var attributes = twoColorTint ?
					[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute(), new webgl.Color2Attribute()] :
					[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute()];
				this.mesh = new webgl.Mesh(context, attributes, maxVertices, maxVertices * 3);
				this.srcBlend = this.context.gl.SRC_ALPHA;
				this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
			}
			PolygonBatcher.prototype.begin = function (shader) {
				var gl = this.context.gl;
				if (this.isDrawing)
					throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()");
				this.drawCalls = 0;
				this.shader = shader;
				this.lastTexture = null;
				this.isDrawing = true;
				gl.enable(gl.BLEND);
				gl.blendFunc(this.srcBlend, this.dstBlend);
			};
			PolygonBatcher.prototype.setBlendMode = function (srcBlend, dstBlend) {
				var gl = this.context.gl;
				this.srcBlend = srcBlend;
				this.dstBlend = dstBlend;
				if (this.isDrawing) {
					this.flush();
					gl.blendFunc(this.srcBlend, this.dstBlend);
				}
			};
			PolygonBatcher.prototype.draw = function (texture, vertices, indices) {
				if (texture != this.lastTexture) {
					this.flush();
					this.lastTexture = texture;
				}
				else if (this.verticesLength + vertices.length > this.mesh.getVertices().length ||
					this.indicesLength + indices.length > this.mesh.getIndices().length) {
					this.flush();
				}
				var indexStart = this.mesh.numVertices();
				this.mesh.getVertices().set(vertices, this.verticesLength);
				this.verticesLength += vertices.length;
				this.mesh.setVerticesLength(this.verticesLength);
				var indicesArray = this.mesh.getIndices();
				for (var i = this.indicesLength, j = 0; j < indices.length; i++, j++)
					indicesArray[i] = indices[j] + indexStart;
				this.indicesLength += indices.length;
				this.mesh.setIndicesLength(this.indicesLength);
			};
			PolygonBatcher.prototype.flush = function () {
				var gl = this.context.gl;
				if (this.verticesLength == 0)
					return;
				this.lastTexture.bind();
				this.mesh.draw(this.shader, gl.TRIANGLES);
				this.verticesLength = 0;
				this.indicesLength = 0;
				this.mesh.setVerticesLength(0);
				this.mesh.setIndicesLength(0);
				this.drawCalls++;
			};
			PolygonBatcher.prototype.end = function () {
				var gl = this.context.gl;
				if (!this.isDrawing)
					throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()");
				if (this.verticesLength > 0 || this.indicesLength > 0)
					this.flush();
				this.shader = null;
				this.lastTexture = null;
				this.isDrawing = false;
				gl.disable(gl.BLEND);
			};
			PolygonBatcher.prototype.getDrawCalls = function () { return this.drawCalls; };
			PolygonBatcher.prototype.dispose = function () {
				this.mesh.dispose();
			};
			return PolygonBatcher;
		}());
		webgl.PolygonBatcher = PolygonBatcher;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var SceneRenderer = (function () {
			function SceneRenderer(canvas, context, twoColorTint) {
				if (twoColorTint === void 0) { twoColorTint = true; }
				this.twoColorTint = false;
				this.activeRenderer = null;
				this.QUAD = [
					0, 0, 1, 1, 1, 1, 0, 0,
					0, 0, 1, 1, 1, 1, 0, 0,
					0, 0, 1, 1, 1, 1, 0, 0,
					0, 0, 1, 1, 1, 1, 0, 0,
				];
				this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
				this.WHITE = new spine.Color(1, 1, 1, 1);
				this.canvas = canvas;
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				this.twoColorTint = twoColorTint;
				this.camera = new webgl.OrthoCamera(canvas.width, canvas.height);
				this.batcherShader = twoColorTint ? webgl.Shader.newTwoColoredTextured(this.context) : webgl.Shader.newColoredTextured(this.context);
				this.batcher = new webgl.PolygonBatcher(this.context, twoColorTint);
				this.shapesShader = webgl.Shader.newColored(this.context);
				this.shapes = new webgl.ShapeRenderer(this.context);
				this.skeletonRenderer = new webgl.SkeletonRenderer(this.context, twoColorTint);
				this.skeletonDebugRenderer = new webgl.SkeletonDebugRenderer(this.context);
			}
			SceneRenderer.prototype.begin = function () {
				this.camera.update();
				this.enableRenderer(this.batcher);
			};
			SceneRenderer.prototype.drawSkeleton = function (skeleton, premultipliedAlpha) {
				if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }
				this.enableRenderer(this.batcher);
				this.skeletonRenderer.premultipliedAlpha = premultipliedAlpha;
				this.skeletonRenderer.draw(this.batcher, skeleton);
			};
			SceneRenderer.prototype.drawSkeletonDebug = function (skeleton, premultipliedAlpha, ignoredBones) {
				if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }
				if (ignoredBones === void 0) { ignoredBones = null; }
				this.enableRenderer(this.shapes);
				this.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha;
				this.skeletonDebugRenderer.draw(this.shapes, skeleton, ignoredBones);
			};
			SceneRenderer.prototype.drawTexture = function (texture, x, y, width, height, color) {
				if (color === void 0) { color = null; }
				this.enableRenderer(this.batcher);
				if (color === null)
					color = this.WHITE;
				var quad = this.QUAD;
				var i = 0;
				quad[i++] = x;
				quad[i++] = y;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 0;
				quad[i++] = 1;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x + width;
				quad[i++] = y;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 1;
				quad[i++] = 1;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x + width;
				quad[i++] = y + height;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 1;
				quad[i++] = 0;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x;
				quad[i++] = y + height;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 0;
				quad[i++] = 0;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);
			};
			SceneRenderer.prototype.drawTextureRotated = function (texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {
				if (color === void 0) { color = null; }
				if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }
				this.enableRenderer(this.batcher);
				if (color === null)
					color = this.WHITE;
				var quad = this.QUAD;
				var worldOriginX = x + pivotX;
				var worldOriginY = y + pivotY;
				var fx = -pivotX;
				var fy = -pivotY;
				var fx2 = width - pivotX;
				var fy2 = height - pivotY;
				var p1x = fx;
				var p1y = fy;
				var p2x = fx;
				var p2y = fy2;
				var p3x = fx2;
				var p3y = fy2;
				var p4x = fx2;
				var p4y = fy;
				var x1 = 0;
				var y1 = 0;
				var x2 = 0;
				var y2 = 0;
				var x3 = 0;
				var y3 = 0;
				var x4 = 0;
				var y4 = 0;
				if (angle != 0) {
					var cos = spine.MathUtils.cosDeg(angle);
					var sin = spine.MathUtils.sinDeg(angle);
					x1 = cos * p1x - sin * p1y;
					y1 = sin * p1x + cos * p1y;
					x4 = cos * p2x - sin * p2y;
					y4 = sin * p2x + cos * p2y;
					x3 = cos * p3x - sin * p3y;
					y3 = sin * p3x + cos * p3y;
					x2 = x3 + (x1 - x4);
					y2 = y3 + (y1 - y4);
				}
				else {
					x1 = p1x;
					y1 = p1y;
					x4 = p2x;
					y4 = p2y;
					x3 = p3x;
					y3 = p3y;
					x2 = p4x;
					y2 = p4y;
				}
				x1 += worldOriginX;
				y1 += worldOriginY;
				x2 += worldOriginX;
				y2 += worldOriginY;
				x3 += worldOriginX;
				y3 += worldOriginY;
				x4 += worldOriginX;
				y4 += worldOriginY;
				var i = 0;
				quad[i++] = x1;
				quad[i++] = y1;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 0;
				quad[i++] = 1;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x2;
				quad[i++] = y2;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 1;
				quad[i++] = 1;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x3;
				quad[i++] = y3;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 1;
				quad[i++] = 0;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x4;
				quad[i++] = y4;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = 0;
				quad[i++] = 0;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);
			};
			SceneRenderer.prototype.drawRegion = function (region, x, y, width, height, color, premultipliedAlpha) {
				if (color === void 0) { color = null; }
				if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }
				this.enableRenderer(this.batcher);
				if (color === null)
					color = this.WHITE;
				var quad = this.QUAD;
				var i = 0;
				quad[i++] = x;
				quad[i++] = y;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = region.u;
				quad[i++] = region.v2;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x + width;
				quad[i++] = y;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = region.u2;
				quad[i++] = region.v2;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x + width;
				quad[i++] = y + height;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = region.u2;
				quad[i++] = region.v;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				quad[i++] = x;
				quad[i++] = y + height;
				quad[i++] = color.r;
				quad[i++] = color.g;
				quad[i++] = color.b;
				quad[i++] = color.a;
				quad[i++] = region.u;
				quad[i++] = region.v;
				if (this.twoColorTint) {
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
					quad[i++] = 0;
				}
				this.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);
			};
			SceneRenderer.prototype.line = function (x, y, x2, y2, color, color2) {
				if (color === void 0) { color = null; }
				if (color2 === void 0) { color2 = null; }
				this.enableRenderer(this.shapes);
				this.shapes.line(x, y, x2, y2, color);
			};
			SceneRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {
				if (color === void 0) { color = null; }
				if (color2 === void 0) { color2 = null; }
				if (color3 === void 0) { color3 = null; }
				this.enableRenderer(this.shapes);
				this.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);
			};
			SceneRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {
				if (color === void 0) { color = null; }
				if (color2 === void 0) { color2 = null; }
				if (color3 === void 0) { color3 = null; }
				if (color4 === void 0) { color4 = null; }
				this.enableRenderer(this.shapes);
				this.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);
			};
			SceneRenderer.prototype.rect = function (filled, x, y, width, height, color) {
				if (color === void 0) { color = null; }
				this.enableRenderer(this.shapes);
				this.shapes.rect(filled, x, y, width, height, color);
			};
			SceneRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {
				if (color === void 0) { color = null; }
				this.enableRenderer(this.shapes);
				this.shapes.rectLine(filled, x1, y1, x2, y2, width, color);
			};
			SceneRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {
				if (color === void 0) { color = null; }
				this.enableRenderer(this.shapes);
				this.shapes.polygon(polygonVertices, offset, count, color);
			};
			SceneRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {
				if (color === void 0) { color = null; }
				if (segments === void 0) { segments = 0; }
				this.enableRenderer(this.shapes);
				this.shapes.circle(filled, x, y, radius, color, segments);
			};
			SceneRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {
				if (color === void 0) { color = null; }
				this.enableRenderer(this.shapes);
				this.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);
			};
			SceneRenderer.prototype.end = function () {
				if (this.activeRenderer === this.batcher)
					this.batcher.end();
				else if (this.activeRenderer === this.shapes)
					this.shapes.end();
				this.activeRenderer = null;
			};
			SceneRenderer.prototype.resize = function (resizeMode) {
				var canvas = this.canvas;
				var w = canvas.clientWidth;
				var h = canvas.clientHeight;
				if (canvas.width != w || canvas.height != h) {
					canvas.width = w;
					canvas.height = h;
				}
				this.context.gl.viewport(0, 0, canvas.width, canvas.height);
				if (resizeMode === ResizeMode.Stretch) {
				}
				else if (resizeMode === ResizeMode.Expand) {
					this.camera.setViewport(w, h);
				}
				else if (resizeMode === ResizeMode.Fit) {
					var sourceWidth = canvas.width, sourceHeight = canvas.height;
					var targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight;
					var targetRatio = targetHeight / targetWidth;
					var sourceRatio = sourceHeight / sourceWidth;
					var scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;
					this.camera.viewportWidth = sourceWidth * scale;
					this.camera.viewportHeight = sourceHeight * scale;
				}
				this.camera.update();
			};
			SceneRenderer.prototype.enableRenderer = function (renderer) {
				if (this.activeRenderer === renderer)
					return;
				this.end();
				if (renderer instanceof webgl.PolygonBatcher) {
					this.batcherShader.bind();
					this.batcherShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);
					this.batcherShader.setUniformi("u_texture", 0);
					this.batcher.begin(this.batcherShader);
					this.activeRenderer = this.batcher;
				}
				else if (renderer instanceof webgl.ShapeRenderer) {
					this.shapesShader.bind();
					this.shapesShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);
					this.shapes.begin(this.shapesShader);
					this.activeRenderer = this.shapes;
				}
				else {
					this.activeRenderer = this.skeletonDebugRenderer;
				}
			};
			SceneRenderer.prototype.dispose = function () {
				this.batcher.dispose();
				this.batcherShader.dispose();
				this.shapes.dispose();
				this.shapesShader.dispose();
				this.skeletonDebugRenderer.dispose();
			};
			return SceneRenderer;
		}());
		webgl.SceneRenderer = SceneRenderer;
		(function (ResizeMode) {
			ResizeMode[ResizeMode["Stretch"] = 0] = "Stretch";
			ResizeMode[ResizeMode["Expand"] = 1] = "Expand";
			ResizeMode[ResizeMode["Fit"] = 2] = "Fit";
		})(webgl.ResizeMode || (webgl.ResizeMode = {}));
		var ResizeMode = webgl.ResizeMode;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var Shader = (function () {
			function Shader(context, vertexShader, fragmentShader) {
				this.vertexShader = vertexShader;
				this.fragmentShader = fragmentShader;
				this.vs = null;
				this.fs = null;
				this.program = null;
				this.tmp2x2 = new Float32Array(2 * 2);
				this.tmp3x3 = new Float32Array(3 * 3);
				this.tmp4x4 = new Float32Array(4 * 4);
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				this.context.addRestorable(this);
				this.compile();
			}
			Shader.prototype.getProgram = function () { return this.program; };
			Shader.prototype.getVertexShader = function () { return this.vertexShader; };
			Shader.prototype.getFragmentShader = function () { return this.fragmentShader; };
			Shader.prototype.compile = function () {
				var gl = this.context.gl;
				try {
					this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);
					this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);
					this.program = this.compileProgram(this.vs, this.fs);
				}
				catch (e) {
					this.dispose();
					throw e;
				}
			};
			Shader.prototype.compileShader = function (type, source) {
				var gl = this.context.gl;
				var shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					var error = "Couldn't compile shader: " + gl.getShaderInfoLog(shader);
					gl.deleteShader(shader);
					if (!gl.isContextLost())
						throw new Error(error);
				}
				return shader;
			};
			Shader.prototype.compileProgram = function (vs, fs) {
				var gl = this.context.gl;
				var program = gl.createProgram();
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					var error = "Couldn't compile shader program: " + gl.getProgramInfoLog(program);
					gl.deleteProgram(program);
					if (!gl.isContextLost())
						throw new Error(error);
				}
				return program;
			};
			Shader.prototype.restore = function () {
				this.compile();
			};
			Shader.prototype.bind = function () {
				this.context.gl.useProgram(this.program);
			};
			Shader.prototype.unbind = function () {
				this.context.gl.useProgram(null);
			};
			Shader.prototype.setUniformi = function (uniform, value) {
				this.context.gl.uniform1i(this.getUniformLocation(uniform), value);
			};
			Shader.prototype.setUniformf = function (uniform, value) {
				this.context.gl.uniform1f(this.getUniformLocation(uniform), value);
			};
			Shader.prototype.setUniform2f = function (uniform, value, value2) {
				this.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);
			};
			Shader.prototype.setUniform3f = function (uniform, value, value2, value3) {
				this.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);
			};
			Shader.prototype.setUniform4f = function (uniform, value, value2, value3, value4) {
				this.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);
			};
			Shader.prototype.setUniform2x2f = function (uniform, value) {
				var gl = this.context.gl;
				this.tmp2x2.set(value);
				gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);
			};
			Shader.prototype.setUniform3x3f = function (uniform, value) {
				var gl = this.context.gl;
				this.tmp3x3.set(value);
				gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);
			};
			Shader.prototype.setUniform4x4f = function (uniform, value) {
				var gl = this.context.gl;
				this.tmp4x4.set(value);
				gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);
			};
			Shader.prototype.getUniformLocation = function (uniform) {
				var gl = this.context.gl;
				var location = gl.getUniformLocation(this.program, uniform);
				if (!location && !gl.isContextLost())
					throw new Error("Couldn't find location for uniform " + uniform);
				return location;
			};
			Shader.prototype.getAttributeLocation = function (attribute) {
				var gl = this.context.gl;
				var location = gl.getAttribLocation(this.program, attribute);
				if (location == -1 && !gl.isContextLost())
					throw new Error("Couldn't find location for attribute " + attribute);
				return location;
			};
			Shader.prototype.dispose = function () {
				this.context.removeRestorable(this);
				var gl = this.context.gl;
				if (this.vs) {
					gl.deleteShader(this.vs);
					this.vs = null;
				}
				if (this.fs) {
					gl.deleteShader(this.fs);
					this.fs = null;
				}
				if (this.program) {
					gl.deleteProgram(this.program);
					this.program = null;
				}
			};
			Shader.newColoredTextured = function (context) {
				var vs = "\n\t\t\t\tattribute vec4 " + Shader.POSITION + ";\n\t\t\t\tattribute vec4 " + Shader.COLOR + ";\n\t\t\t\tattribute vec2 " + Shader.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + Shader.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + Shader.COLOR + ";\n\t\t\t\t\tv_texCoords = " + Shader.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + Shader.MVP_MATRIX + " * " + Shader.POSITION + ";\n\t\t\t\t}\n\t\t\t";
				var fs = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n\t\t\t\t}\n\t\t\t";
				return new Shader(context, vs, fs);
			};
			Shader.newTwoColoredTextured = function (context) {
				var vs = "\n\t\t\t\tattribute vec4 " + Shader.POSITION + ";\n\t\t\t\tattribute vec4 " + Shader.COLOR + ";\n\t\t\t\tattribute vec4 " + Shader.COLOR2 + ";\n\t\t\t\tattribute vec2 " + Shader.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + Shader.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_light;\n\t\t\t\tvarying vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_light = " + Shader.COLOR + ";\n\t\t\t\t\tv_dark = " + Shader.COLOR2 + ";\n\t\t\t\t\tv_texCoords = " + Shader.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + Shader.MVP_MATRIX + " * " + Shader.POSITION + ";\n\t\t\t\t}\n\t\t\t";
				var fs = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_light;\n\t\t\t\tvarying LOWP vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tvec4 texColor = texture2D(u_texture, v_texCoords);\n\t\t\t\t\tfloat alpha = texColor.a * v_light.a;\n\t\t\t\t\tgl_FragColor.a = alpha;\n\t\t\t\t\tgl_FragColor.rgb = (1.0 - texColor.rgb) * v_dark.rgb * alpha + texColor.rgb * v_light.rgb;\n\t\t\t\t}\n\t\t\t";
				return new Shader(context, vs, fs);
			};
			Shader.newColored = function (context) {
				var vs = "\n\t\t\t\tattribute vec4 " + Shader.POSITION + ";\n\t\t\t\tattribute vec4 " + Shader.COLOR + ";\n\t\t\t\tuniform mat4 " + Shader.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + Shader.COLOR + ";\n\t\t\t\t\tgl_Position = " + Shader.MVP_MATRIX + " * " + Shader.POSITION + ";\n\t\t\t\t}\n\t\t\t";
				var fs = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color;\n\t\t\t\t}\n\t\t\t";
				return new Shader(context, vs, fs);
			};
			Shader.MVP_MATRIX = "u_projTrans";
			Shader.POSITION = "a_position";
			Shader.COLOR = "a_color";
			Shader.COLOR2 = "a_color2";
			Shader.TEXCOORDS = "a_texCoords";
			Shader.SAMPLER = "u_texture";
			return Shader;
		}());
		webgl.Shader = Shader;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var ShapeRenderer = (function () {
			function ShapeRenderer(context, maxVertices) {
				if (maxVertices === void 0) { maxVertices = 10920; }
				this.isDrawing = false;
				this.shapeType = ShapeType.Filled;
				this.color = new spine.Color(1, 1, 1, 1);
				this.vertexIndex = 0;
				this.tmp = new spine.Vector2();
				if (maxVertices > 10920)
					throw new Error("Can't have more than 10920 triangles per batch: " + maxVertices);
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
				this.mesh = new webgl.Mesh(context, [new webgl.Position2Attribute(), new webgl.ColorAttribute()], maxVertices, 0);
				this.srcBlend = this.context.gl.SRC_ALPHA;
				this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
			}
			ShapeRenderer.prototype.begin = function (shader) {
				if (this.isDrawing)
					throw new Error("ShapeRenderer.begin() has already been called");
				this.shader = shader;
				this.vertexIndex = 0;
				this.isDrawing = true;
				var gl = this.context.gl;
				gl.enable(gl.BLEND);
				gl.blendFunc(this.srcBlend, this.dstBlend);
			};
			ShapeRenderer.prototype.setBlendMode = function (srcBlend, dstBlend) {
				var gl = this.context.gl;
				this.srcBlend = srcBlend;
				this.dstBlend = dstBlend;
				if (this.isDrawing) {
					this.flush();
					gl.blendFunc(this.srcBlend, this.dstBlend);
				}
			};
			ShapeRenderer.prototype.setColor = function (color) {
				this.color.setFromColor(color);
			};
			ShapeRenderer.prototype.setColorWith = function (r, g, b, a) {
				this.color.set(r, g, b, a);
			};
			ShapeRenderer.prototype.point = function (x, y, color) {
				if (color === void 0) { color = null; }
				this.check(ShapeType.Point, 1);
				if (color === null)
					color = this.color;
				this.vertex(x, y, color);
			};
			ShapeRenderer.prototype.line = function (x, y, x2, y2, color) {
				if (color === void 0) { color = null; }
				this.check(ShapeType.Line, 2);
				var vertices = this.mesh.getVertices();
				var idx = this.vertexIndex;
				if (color === null)
					color = this.color;
				this.vertex(x, y, color);
				this.vertex(x2, y2, color);
			};
			ShapeRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {
				if (color === void 0) { color = null; }
				if (color2 === void 0) { color2 = null; }
				if (color3 === void 0) { color3 = null; }
				this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);
				var vertices = this.mesh.getVertices();
				var idx = this.vertexIndex;
				if (color === null)
					color = this.color;
				if (color2 === null)
					color2 = this.color;
				if (color3 === null)
					color3 = this.color;
				if (filled) {
					this.vertex(x, y, color);
					this.vertex(x2, y2, color2);
					this.vertex(x3, y3, color3);
				}
				else {
					this.vertex(x, y, color);
					this.vertex(x2, y2, color2);
					this.vertex(x2, y2, color);
					this.vertex(x3, y3, color2);
					this.vertex(x3, y3, color);
					this.vertex(x, y, color2);
				}
			};
			ShapeRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {
				if (color === void 0) { color = null; }
				if (color2 === void 0) { color2 = null; }
				if (color3 === void 0) { color3 = null; }
				if (color4 === void 0) { color4 = null; }
				this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);
				var vertices = this.mesh.getVertices();
				var idx = this.vertexIndex;
				if (color === null)
					color = this.color;
				if (color2 === null)
					color2 = this.color;
				if (color3 === null)
					color3 = this.color;
				if (color4 === null)
					color4 = this.color;
				if (filled) {
					this.vertex(x, y, color);
					this.vertex(x2, y2, color2);
					this.vertex(x3, y3, color3);
					this.vertex(x3, y3, color3);
					this.vertex(x4, y4, color4);
					this.vertex(x, y, color);
				}
				else {
					this.vertex(x, y, color);
					this.vertex(x2, y2, color2);
					this.vertex(x2, y2, color2);
					this.vertex(x3, y3, color3);
					this.vertex(x3, y3, color3);
					this.vertex(x4, y4, color4);
					this.vertex(x4, y4, color4);
					this.vertex(x, y, color);
				}
			};
			ShapeRenderer.prototype.rect = function (filled, x, y, width, height, color) {
				if (color === void 0) { color = null; }
				this.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);
			};
			ShapeRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {
				if (color === void 0) { color = null; }
				this.check(filled ? ShapeType.Filled : ShapeType.Line, 8);
				if (color === null)
					color = this.color;
				var t = this.tmp.set(y2 - y1, x1 - x2);
				t.normalize();
				width *= 0.5;
				var tx = t.x * width;
				var ty = t.y * width;
				if (!filled) {
					this.vertex(x1 + tx, y1 + ty, color);
					this.vertex(x1 - tx, y1 - ty, color);
					this.vertex(x2 + tx, y2 + ty, color);
					this.vertex(x2 - tx, y2 - ty, color);
					this.vertex(x2 + tx, y2 + ty, color);
					this.vertex(x1 + tx, y1 + ty, color);
					this.vertex(x2 - tx, y2 - ty, color);
					this.vertex(x1 - tx, y1 - ty, color);
				}
				else {
					this.vertex(x1 + tx, y1 + ty, color);
					this.vertex(x1 - tx, y1 - ty, color);
					this.vertex(x2 + tx, y2 + ty, color);
					this.vertex(x2 - tx, y2 - ty, color);
					this.vertex(x2 + tx, y2 + ty, color);
					this.vertex(x1 - tx, y1 - ty, color);
				}
			};
			ShapeRenderer.prototype.x = function (x, y, size) {
				this.line(x - size, y - size, x + size, y + size);
				this.line(x - size, y + size, x + size, y - size);
			};
			ShapeRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {
				if (color === void 0) { color = null; }
				if (count < 3)
					throw new Error("Polygon must contain at least 3 vertices");
				this.check(ShapeType.Line, count * 2);
				if (color === null)
					color = this.color;
				var vertices = this.mesh.getVertices();
				var idx = this.vertexIndex;
				offset <<= 1;
				count <<= 1;
				var firstX = polygonVertices[offset];
				var firstY = polygonVertices[offset + 1];
				var last = offset + count;
				for (var i = offset, n = offset + count - 2; i < n; i += 2) {
					var x1 = polygonVertices[i];
					var y1 = polygonVertices[i + 1];
					var x2 = 0;
					var y2 = 0;
					if (i + 2 >= last) {
						x2 = firstX;
						y2 = firstY;
					}
					else {
						x2 = polygonVertices[i + 2];
						y2 = polygonVertices[i + 3];
					}
					this.vertex(x1, y1, color);
					this.vertex(x2, y2, color);
				}
			};
			ShapeRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {
				if (color === void 0) { color = null; }
				if (segments === void 0) { segments = 0; }
				if (segments === 0)
					segments = Math.max(1, (6 * spine.MathUtils.cbrt(radius)) | 0);
				if (segments <= 0)
					throw new Error("segments must be > 0.");
				if (color === null)
					color = this.color;
				var angle = 2 * spine.MathUtils.PI / segments;
				var cos = Math.cos(angle);
				var sin = Math.sin(angle);
				var cx = radius, cy = 0;
				if (!filled) {
					this.check(ShapeType.Line, segments * 2 + 2);
					for (var i = 0; i < segments; i++) {
						this.vertex(x + cx, y + cy, color);
						var temp_1 = cx;
						cx = cos * cx - sin * cy;
						cy = sin * temp_1 + cos * cy;
						this.vertex(x + cx, y + cy, color);
					}
					this.vertex(x + cx, y + cy, color);
				}
				else {
					this.check(ShapeType.Filled, segments * 3 + 3);
					segments--;
					for (var i = 0; i < segments; i++) {
						this.vertex(x, y, color);
						this.vertex(x + cx, y + cy, color);
						var temp_2 = cx;
						cx = cos * cx - sin * cy;
						cy = sin * temp_2 + cos * cy;
						this.vertex(x + cx, y + cy, color);
					}
					this.vertex(x, y, color);
					this.vertex(x + cx, y + cy, color);
				}
				var temp = cx;
				cx = radius;
				cy = 0;
				this.vertex(x + cx, y + cy, color);
			};
			ShapeRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {
				if (color === void 0) { color = null; }
				this.check(ShapeType.Line, segments * 2 + 2);
				if (color === null)
					color = this.color;
				var subdiv_step = 1 / segments;
				var subdiv_step2 = subdiv_step * subdiv_step;
				var subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;
				var pre1 = 3 * subdiv_step;
				var pre2 = 3 * subdiv_step2;
				var pre4 = 6 * subdiv_step2;
				var pre5 = 6 * subdiv_step3;
				var tmp1x = x1 - cx1 * 2 + cx2;
				var tmp1y = y1 - cy1 * 2 + cy2;
				var tmp2x = (cx1 - cx2) * 3 - x1 + x2;
				var tmp2y = (cy1 - cy2) * 3 - y1 + y2;
				var fx = x1;
				var fy = y1;
				var dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
				var dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
				var ddfx = tmp1x * pre4 + tmp2x * pre5;
				var ddfy = tmp1y * pre4 + tmp2y * pre5;
				var dddfx = tmp2x * pre5;
				var dddfy = tmp2y * pre5;
				while (segments-- > 0) {
					this.vertex(fx, fy, color);
					fx += dfx;
					fy += dfy;
					dfx += ddfx;
					dfy += ddfy;
					ddfx += dddfx;
					ddfy += dddfy;
					this.vertex(fx, fy, color);
				}
				this.vertex(fx, fy, color);
				this.vertex(x2, y2, color);
			};
			ShapeRenderer.prototype.vertex = function (x, y, color) {
				var idx = this.vertexIndex;
				var vertices = this.mesh.getVertices();
				vertices[idx++] = x;
				vertices[idx++] = y;
				vertices[idx++] = color.r;
				vertices[idx++] = color.g;
				vertices[idx++] = color.b;
				vertices[idx++] = color.a;
				this.vertexIndex = idx;
			};
			ShapeRenderer.prototype.end = function () {
				if (!this.isDrawing)
					throw new Error("ShapeRenderer.begin() has not been called");
				this.flush();
				this.context.gl.disable(this.context.gl.BLEND);
				this.isDrawing = false;
			};
			ShapeRenderer.prototype.flush = function () {
				if (this.vertexIndex == 0)
					return;
				this.mesh.setVerticesLength(this.vertexIndex);
				this.mesh.draw(this.shader, this.shapeType);
				this.vertexIndex = 0;
			};
			ShapeRenderer.prototype.check = function (shapeType, numVertices) {
				if (!this.isDrawing)
					throw new Error("ShapeRenderer.begin() has not been called");
				if (this.shapeType == shapeType) {
					if (this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)
						this.flush();
					else
						return;
				}
				else {
					this.flush();
					this.shapeType = shapeType;
				}
			};
			ShapeRenderer.prototype.dispose = function () {
				this.mesh.dispose();
			};
			return ShapeRenderer;
		}());
		webgl.ShapeRenderer = ShapeRenderer;
		(function (ShapeType) {
			ShapeType[ShapeType["Point"] = 0] = "Point";
			ShapeType[ShapeType["Line"] = 1] = "Line";
			ShapeType[ShapeType["Filled"] = 4] = "Filled";
		})(webgl.ShapeType || (webgl.ShapeType = {}));
		var ShapeType = webgl.ShapeType;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var SkeletonDebugRenderer = (function () {
			function SkeletonDebugRenderer(context) {
				this.boneLineColor = new spine.Color(1, 0, 0, 1);
				this.boneOriginColor = new spine.Color(0, 1, 0, 1);
				this.attachmentLineColor = new spine.Color(0, 0, 1, 0.5);
				this.triangleLineColor = new spine.Color(1, 0.64, 0, 0.5);
				this.pathColor = new spine.Color().setFromString("FF7F00");
				this.clipColor = new spine.Color(0.8, 0, 0, 2);
				this.aabbColor = new spine.Color(0, 1, 0, 0.5);
				this.drawBones = true;
				this.drawRegionAttachments = true;
				this.drawBoundingBoxes = true;
				this.drawMeshHull = true;
				this.drawMeshTriangles = true;
				this.drawPaths = true;
				this.drawSkeletonXY = false;
				this.drawClipping = true;
				this.premultipliedAlpha = false;
				this.scale = 1;
				this.boneWidth = 2;
				this.bounds = new spine.SkeletonBounds();
				this.temp = new Array();
				this.vertices = spine.Utils.newFloatArray(2 * 1024);
				this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);
			}
			SkeletonDebugRenderer.prototype.draw = function (shapes, skeleton, ignoredBones) {
				if (ignoredBones === void 0) { ignoredBones = null; }
				var skeletonX = skeleton.x;
				var skeletonY = skeleton.y;
				var gl = this.context.gl;
				var srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;
				shapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);
				var bones = skeleton.bones;
				if (this.drawBones) {
					shapes.setColor(this.boneLineColor);
					for (var i = 0, n = bones.length; i < n; i++) {
						var bone = bones[i];
						if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)
							continue;
						if (bone.parent == null)
							continue;
						var x = skeletonX + bone.data.length * bone.a + bone.worldX;
						var y = skeletonY + bone.data.length * bone.c + bone.worldY;
						shapes.rectLine(true, skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, this.boneWidth * this.scale);
					}
					if (this.drawSkeletonXY)
						shapes.x(skeletonX, skeletonY, 4 * this.scale);
				}
				if (this.drawRegionAttachments) {
					shapes.setColor(this.attachmentLineColor);
					var slots = skeleton.slots;
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var attachment = slot.getAttachment();
						if (attachment instanceof spine.RegionAttachment) {
							var regionAttachment = attachment;
							var vertices = this.vertices;
							regionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2);
							shapes.line(vertices[0], vertices[1], vertices[2], vertices[3]);
							shapes.line(vertices[2], vertices[3], vertices[4], vertices[5]);
							shapes.line(vertices[4], vertices[5], vertices[6], vertices[7]);
							shapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);
						}
					}
				}
				if (this.drawMeshHull || this.drawMeshTriangles) {
					var slots = skeleton.slots;
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var attachment = slot.getAttachment();
						if (!(attachment instanceof spine.MeshAttachment))
							continue;
						var mesh = attachment;
						var vertices = this.vertices;
						mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);
						var triangles = mesh.triangles;
						var hullLength = mesh.hullLength;
						if (this.drawMeshTriangles) {
							shapes.setColor(this.triangleLineColor);
							for (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {
								var v1 = triangles[ii] * 2, v2 = triangles[ii + 1] * 2, v3 = triangles[ii + 2] * 2;
								shapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);
							}
						}
						if (this.drawMeshHull && hullLength > 0) {
							shapes.setColor(this.attachmentLineColor);
							hullLength = (hullLength >> 1) * 2;
							var lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];
							for (var ii = 0, nn = hullLength; ii < nn; ii += 2) {
								var x = vertices[ii], y = vertices[ii + 1];
								shapes.line(x, y, lastX, lastY);
								lastX = x;
								lastY = y;
							}
						}
					}
				}
				if (this.drawBoundingBoxes) {
					var bounds = this.bounds;
					bounds.update(skeleton, true);
					shapes.setColor(this.aabbColor);
					shapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
					var polygons = bounds.polygons;
					var boxes = bounds.boundingBoxes;
					for (var i = 0, n = polygons.length; i < n; i++) {
						var polygon = polygons[i];
						shapes.setColor(boxes[i].color);
						shapes.polygon(polygon, 0, polygon.length);
					}
				}
				if (this.drawPaths) {
					var slots = skeleton.slots;
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var attachment = slot.getAttachment();
						if (!(attachment instanceof spine.PathAttachment))
							continue;
						var path = attachment;
						var nn = path.worldVerticesLength;
						var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);
						path.computeWorldVertices(slot, 0, nn, world, 0, 2);
						var color = this.pathColor;
						var x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;
						if (path.closed) {
							shapes.setColor(color);
							var cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];
							x2 = world[nn - 4];
							y2 = world[nn - 3];
							shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);
							shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);
							shapes.line(x1, y1, cx1, cy1);
							shapes.line(x2, y2, cx2, cy2);
						}
						nn -= 4;
						for (var ii = 4; ii < nn; ii += 6) {
							var cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];
							x2 = world[ii + 4];
							y2 = world[ii + 5];
							shapes.setColor(color);
							shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);
							shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);
							shapes.line(x1, y1, cx1, cy1);
							shapes.line(x2, y2, cx2, cy2);
							x1 = x2;
							y1 = y2;
						}
					}
				}
				if (this.drawBones) {
					shapes.setColor(this.boneOriginColor);
					for (var i = 0, n = bones.length; i < n; i++) {
						var bone = bones[i];
						if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)
							continue;
						shapes.circle(true, skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer.GREEN, 8);
					}
				}
				if (this.drawClipping) {
					var slots = skeleton.slots;
					shapes.setColor(this.clipColor);
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var attachment = slot.getAttachment();
						if (!(attachment instanceof spine.ClippingAttachment))
							continue;
						var clip = attachment;
						var nn = clip.worldVerticesLength;
						var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);
						clip.computeWorldVertices(slot, 0, nn, world, 0, 2);
						for (var i_5 = 0, n_2 = world.length; i_5 < n_2; i_5 += 2) {
							var x = world[i_5];
							var y = world[i_5 + 1];
							var x2 = world[(i_5 + 2) % world.length];
							var y2 = world[(i_5 + 3) % world.length];
							shapes.line(x, y, x2, y2);
						}
					}
				}
			};
			SkeletonDebugRenderer.prototype.dispose = function () {
			};
			SkeletonDebugRenderer.LIGHT_GRAY = new spine.Color(192 / 255, 192 / 255, 192 / 255, 1);
			SkeletonDebugRenderer.GREEN = new spine.Color(0, 1, 0, 1);
			return SkeletonDebugRenderer;
		}());
		webgl.SkeletonDebugRenderer = SkeletonDebugRenderer;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var Renderable = (function () {
			function Renderable(vertices, numVertices, numFloats) {
				this.vertices = vertices;
				this.numVertices = numVertices;
				this.numFloats = numFloats;
			}
			return Renderable;
		}());
		;
		var SkeletonRenderer = (function () {
			function SkeletonRenderer(context, twoColorTint) {
				if (twoColorTint === void 0) { twoColorTint = true; }
				this.premultipliedAlpha = false;
				this.tempColor = new spine.Color();
				this.tempColor2 = new spine.Color();
				this.vertexSize = 2 + 2 + 4;
				this.twoColorTint = false;
				this.renderable = new Renderable(null, 0, 0);
				this.clipper = new spine.SkeletonClipping();
				this.twoColorTint = twoColorTint;
				if (twoColorTint)
					this.vertexSize += 4;
				this.vertices = spine.Utils.newFloatArray(this.vertexSize * 1024);
			}
			SkeletonRenderer.prototype.draw = function (batcher, skeleton) {
				var clipper = this.clipper;
				var premultipliedAlpha = this.premultipliedAlpha;
				var twoColorTint = this.twoColorTint;
				var blendMode = null;
				var renderable = this.renderable;
				var uvs = null;
				var triangles = null;
				var drawOrder = skeleton.drawOrder;
				var attachmentColor = null;
				var skeletonColor = skeleton.color;
				var vertexSize = twoColorTint ? 12 : 8;
				for (var i = 0, n = drawOrder.length; i < n; i++) {
					var clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;
					var slot = drawOrder[i];
					var attachment = slot.getAttachment();
					var texture = null;
					if (attachment instanceof spine.RegionAttachment) {
						var region = attachment;
						renderable.vertices = this.vertices;
						renderable.numVertices = 4;
						renderable.numFloats = clippedVertexSize << 2;
						region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);
						triangles = SkeletonRenderer.QUAD_TRIANGLES;
						uvs = region.uvs;
						texture = region.region.renderObject.texture;
						attachmentColor = region.color;
					}
					else if (attachment instanceof spine.MeshAttachment) {
						var mesh = attachment;
						renderable.vertices = this.vertices;
						renderable.numVertices = (mesh.worldVerticesLength >> 1);
						renderable.numFloats = renderable.numVertices * clippedVertexSize;
						if (renderable.numFloats > renderable.vertices.length) {
							renderable.vertices = this.vertices = spine.Utils.newFloatArray(renderable.numFloats);
						}
						mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);
						triangles = mesh.triangles;
						texture = mesh.region.renderObject.texture;
						uvs = mesh.uvs;
						attachmentColor = mesh.color;
					}
					else if (attachment instanceof spine.ClippingAttachment) {
						var clip = (attachment);
						clipper.clipStart(slot, clip);
						continue;
					}
					else
						continue;
					if (texture != null) {
						var slotColor = slot.color;
						var finalColor = this.tempColor;
						finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;
						finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;
						finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;
						finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;
						if (premultipliedAlpha) {
							finalColor.r *= finalColor.a;
							finalColor.g *= finalColor.a;
							finalColor.b *= finalColor.a;
						}
						var darkColor = this.tempColor2;
						if (slot.darkColor == null)
							darkColor.set(0, 0, 0, 1);
						else
							darkColor.setFromColor(slot.darkColor);
						var slotBlendMode = slot.data.blendMode;
						if (slotBlendMode != blendMode) {
							blendMode = slotBlendMode;
							batcher.setBlendMode(webgl.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl.WebGLBlendModeConverter.getDestGLBlendMode(blendMode));
						}
						if (clipper.isClipping()) {
							clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);
							var clippedVertices = new Float32Array(clipper.clippedVertices);
							var clippedTriangles = clipper.clippedTriangles;
							batcher.draw(texture, clippedVertices, clippedTriangles);
						}
						else {
							var verts = renderable.vertices;
							if (!twoColorTint) {
								for (var v = 2, u = 0, n_3 = renderable.numFloats; v < n_3; v += vertexSize, u += 2) {
									verts[v] = finalColor.r;
									verts[v + 1] = finalColor.g;
									verts[v + 2] = finalColor.b;
									verts[v + 3] = finalColor.a;
									verts[v + 4] = uvs[u];
									verts[v + 5] = uvs[u + 1];
								}
							}
							else {
								for (var v = 2, u = 0, n_4 = renderable.numFloats; v < n_4; v += vertexSize, u += 2) {
									verts[v] = finalColor.r;
									verts[v + 1] = finalColor.g;
									verts[v + 2] = finalColor.b;
									verts[v + 3] = finalColor.a;
									verts[v + 4] = uvs[u];
									verts[v + 5] = uvs[u + 1];
									verts[v + 6] = darkColor.r;
									verts[v + 7] = darkColor.g;
									verts[v + 8] = darkColor.b;
									verts[v + 9] = darkColor.a;
								}
							}
							var view = renderable.vertices.subarray(0, renderable.numFloats);
							batcher.draw(texture, view, triangles);
						}
					}
					clipper.clipEndWithSlot(slot);
				}
				clipper.clipEnd();
			};
			SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
			return SkeletonRenderer;
		}());
		webgl.SkeletonRenderer = SkeletonRenderer;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var Vector3 = (function () {
			function Vector3(x, y, z) {
				if (x === void 0) { x = 0; }
				if (y === void 0) { y = 0; }
				if (z === void 0) { z = 0; }
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.x = x;
				this.y = y;
				this.z = z;
			}
			Vector3.prototype.setFrom = function (v) {
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				return this;
			};
			Vector3.prototype.set = function (x, y, z) {
				this.x = x;
				this.y = y;
				this.z = z;
				return this;
			};
			Vector3.prototype.add = function (v) {
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				return this;
			};
			Vector3.prototype.sub = function (v) {
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				return this;
			};
			Vector3.prototype.scale = function (s) {
				this.x *= s;
				this.y *= s;
				this.z *= s;
				return this;
			};
			Vector3.prototype.normalize = function () {
				var len = this.length();
				if (len == 0)
					return this;
				len = 1 / len;
				this.x *= len;
				this.y *= len;
				this.z *= len;
				return this;
			};
			Vector3.prototype.cross = function (v) {
				return this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
			};
			Vector3.prototype.multiply = function (matrix) {
				var l_mat = matrix.values;
				return this.set(this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03], this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13], this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]);
			};
			Vector3.prototype.project = function (matrix) {
				var l_mat = matrix.values;
				var l_w = 1 / (this.x * l_mat[webgl.M30] + this.y * l_mat[webgl.M31] + this.z * l_mat[webgl.M32] + l_mat[webgl.M33]);
				return this.set((this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03]) * l_w, (this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13]) * l_w, (this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]) * l_w);
			};
			Vector3.prototype.dot = function (v) {
				return this.x * v.x + this.y * v.y + this.z * v.z;
			};
			Vector3.prototype.length = function () {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
			};
			Vector3.prototype.distance = function (v) {
				var a = v.x - this.x;
				var b = v.y - this.y;
				var c = v.z - this.z;
				return Math.sqrt(a * a + b * b + c * c);
			};
			return Vector3;
		}());
		webgl.Vector3 = Vector3;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var webgl;
	(function (webgl) {
		var ManagedWebGLRenderingContext = (function () {
			function ManagedWebGLRenderingContext(canvasOrContext, contextConfig) {
				var _this = this;
				if (contextConfig === void 0) { contextConfig = { alpha: "true" }; }
				this.restorables = new Array();
				if (canvasOrContext instanceof HTMLCanvasElement) {
					var canvas = canvasOrContext;
					this.gl = (canvas.getContext("webgl", contextConfig) || canvas.getContext("experimental-webgl", contextConfig));
					this.canvas = canvas;
					canvas.addEventListener("webglcontextlost", function (e) {
						var event = e;
						if (e) {
							e.preventDefault();
						}
					});
					canvas.addEventListener("webglcontextrestored", function (e) {
						for (var i = 0, n = _this.restorables.length; i < n; i++) {
							_this.restorables[i].restore();
						}
					});
				}
				else {
					this.gl = canvasOrContext;
					this.canvas = this.gl.canvas;
				}
			}
			ManagedWebGLRenderingContext.prototype.addRestorable = function (restorable) {
				this.restorables.push(restorable);
			};
			ManagedWebGLRenderingContext.prototype.removeRestorable = function (restorable) {
				var index = this.restorables.indexOf(restorable);
				if (index > -1)
					this.restorables.splice(index, 1);
			};
			return ManagedWebGLRenderingContext;
		}());
		webgl.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;
		var WebGLBlendModeConverter = (function () {
			function WebGLBlendModeConverter() {
			}
			WebGLBlendModeConverter.getDestGLBlendMode = function (blendMode) {
				switch (blendMode) {
					case spine.BlendMode.Normal: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;
					case spine.BlendMode.Additive: return WebGLBlendModeConverter.ONE;
					case spine.BlendMode.Multiply: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;
					case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;
					default: throw new Error("Unknown blend mode: " + blendMode);
				}
			};
			WebGLBlendModeConverter.getSourceGLBlendMode = function (blendMode, premultipliedAlpha) {
				if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }
				switch (blendMode) {
					case spine.BlendMode.Normal: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;
					case spine.BlendMode.Additive: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;
					case spine.BlendMode.Multiply: return WebGLBlendModeConverter.DST_COLOR;
					case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE;
					default: throw new Error("Unknown blend mode: " + blendMode);
				}
			};
			WebGLBlendModeConverter.ZERO = 0;
			WebGLBlendModeConverter.ONE = 1;
			WebGLBlendModeConverter.SRC_COLOR = 0x0300;
			WebGLBlendModeConverter.ONE_MINUS_SRC_COLOR = 0x0301;
			WebGLBlendModeConverter.SRC_ALPHA = 0x0302;
			WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA = 0x0303;
			WebGLBlendModeConverter.DST_ALPHA = 0x0304;
			WebGLBlendModeConverter.ONE_MINUS_DST_ALPHA = 0x0305;
			WebGLBlendModeConverter.DST_COLOR = 0x0306;
			return WebGLBlendModeConverter;
		}());
		webgl.WebGLBlendModeConverter = WebGLBlendModeConverter;
	})(webgl = spine.webgl || (spine.webgl = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SpineWidget = (function () {
		function SpineWidget(element, config) {
			var _this = this;
			this.mvp = new spine.webgl.Matrix4();
			this.paused = false;
			this.lastFrameTime = Date.now() / 1000.0;
			this.backgroundColor = new spine.Color();
			this.loaded = false;
			this.bounds = { offset: new spine.Vector2(), size: new spine.Vector2() };
			if (!element)
				throw new Error("Please provide a DOM element, e.g. document.getElementById('myelement')");
			if (!config)
				throw new Error("Please provide a configuration, specifying at least the json file, atlas file and animation name");
			var elementId = element;
			if (typeof (element) === "string")
				element = document.getElementById(element);
			if (element == null)
				throw new Error("Element " + elementId + " does not exist");
			this.validateConfig(config);
			var existingCanvas = element.children[0];
			var canvas = this.canvas = existingCanvas || document.createElement("canvas");
			canvas.style.width = "100%";
			canvas.style.height = "100%";
			if (!existingCanvas) {
				element.appendChild(canvas);
			}
			canvas.width = element.clientWidth;
			canvas.height = element.clientHeight;
			var webglConfig = { alpha: config.alpha };
			this.context = new spine.webgl.ManagedWebGLRenderingContext(canvas, webglConfig);
			this.shader = spine.webgl.Shader.newTwoColoredTextured(this.context);
			this.batcher = new spine.webgl.PolygonBatcher(this.context);
			this.mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);
			this.skeletonRenderer = new spine.webgl.SkeletonRenderer(this.context);
			this.debugShader = spine.webgl.Shader.newColored(this.context);
			this.debugRenderer = new spine.webgl.SkeletonDebugRenderer(this.context);
			this.shapes = new spine.webgl.ShapeRenderer(this.context);
			var assets = this.assetManager = new spine.webgl.AssetManager(this.context, config.imagesPath ? config.imagesPath : "");
			if (!config.atlasContent) {
				assets.loadText(config.atlas);
			}
			if (!config.jsonContent) {
				assets.loadText(config.json);
			}
			if (config.atlasPages == null) {
				if (config.atlas) {
					var atlasPage = config.atlas.replace(".atlas", ".png");
					if (atlasPage.lastIndexOf(config.imagesPath) == 0) {
						atlasPage = atlasPage.substr(config.imagesPath.length);
					}
					assets.loadTexture(atlasPage);
				}
				else {
					var firstLine = config.atlasContent.trim().split("\n")[0];
					assets.loadTexture(firstLine);
				}
			}
			else {
				for (var i = 0; i < config.atlasPages.length; i++) {
					if (config.atlasPagesContent && config.atlasPagesContent[i]) {
						assets.loadTextureData(config.atlasPages[i], config.atlasPagesContent[0]);
					}
					else {
						assets.loadTexture(config.atlasPages[i]);
					}
				}
			}
			requestAnimationFrame(function () { _this.load(); });
		}
		SpineWidget.prototype.validateConfig = function (config) {
			if (!config.atlas && !config.atlasContent)
				throw new Error("Please specify config.atlas or config.atlasContent");
			if (!config.json && !config.jsonContent)
				throw new Error("Please specify config.json or config.jsonContent");
			if (!config.animation)
				throw new Error("Please specify config.animationName");
			if (!config.scale)
				config.scale = 1.0;
			if (!config.skin)
				config.skin = "default";
			if (config.loop === undefined)
				config.loop = true;
			if (!config.x)
				config.x = 0;
			if (!config.y)
				config.y = 0;
			if (config.fitToCanvas === undefined)
				config.fitToCanvas = true;
			if (!config.backgroundColor)
				config.backgroundColor = "#555555";
			if (!config.imagesPath) {
				if (config.atlas) {
					var index = config.atlas.lastIndexOf("/");
					if (index != -1) {
						config.imagesPath = config.atlas.substr(0, index) + "/";
					}
					else {
						config.imagesPath = "";
					}
				}
				else {
					config.imagesPath = "";
				}
			}
			if (config.json && config.json.lastIndexOf(config.imagesPath) == 0) {
				config.json = config.json.substr(config.imagesPath.length);
			}
			if (config.atlas && config.atlas.lastIndexOf(config.imagesPath) == 0) {
				config.atlas = config.atlas.substr(config.imagesPath.length);
			}
			if (!config.premultipliedAlpha === undefined)
				config.premultipliedAlpha = false;
			if (!config.debug === undefined)
				config.debug = false;
			if (!config.alpha === undefined)
				config.alpha = true;
			this.backgroundColor.setFromString(config.backgroundColor);
			this.config = config;
		};
		SpineWidget.prototype.load = function () {
			var _this = this;
			var assetManager = this.assetManager;
			var imagesPath = this.config.imagesPath;
			var config = this.config;
			if (assetManager.isLoadingComplete()) {
				if (assetManager.hasErrors()) {
					if (config.error)
						config.error(this, "Failed to load assets: " + JSON.stringify(assetManager.getErrors()));
					else
						throw new Error("Failed to load assets: " + JSON.stringify(assetManager.getErrors()));
				}
				var atlasContent = config.atlasContent === undefined ? this.assetManager.get(this.config.atlas) : config.atlasContent;
				var atlas = new spine.TextureAtlas(atlasContent, function (path) {
					var texture = assetManager.get(path);
					return texture;
				});
				var atlasLoader = new spine.AtlasAttachmentLoader(atlas);
				var skeletonJson = new spine.SkeletonJson(atlasLoader);
				skeletonJson.scale = config.scale;
				var jsonContent = config.jsonContent === undefined ? assetManager.get(config.json) : config.jsonContent;
				var skeletonData = skeletonJson.readSkeletonData(jsonContent);
				var skeleton = this.skeleton = new spine.Skeleton(skeletonData);
				var bounds = this.bounds;
				skeleton.setSkinByName(config.skin);
				skeleton.setToSetupPose();
				skeleton.updateWorldTransform();
				skeleton.getBounds(bounds.offset, bounds.size, []);
				if (!config.fitToCanvas) {
					skeleton.x = config.x;
					skeleton.y = config.y;
				}
				var animationState = this.state = new spine.AnimationState(new spine.AnimationStateData(skeleton.data));
				animationState.setAnimation(0, config.animation, config.loop);
				this.loaded = true;
				if (config.success)
					config.success(this);
				requestAnimationFrame(function () { _this.render(); });
			}
			else
				requestAnimationFrame(function () { _this.load(); });
		};
		SpineWidget.prototype.render = function () {
			var _this = this;
			var now = Date.now() / 1000;
			var delta = now - this.lastFrameTime;
			if (delta > 0.1)
				delta = 0;
			this.lastFrameTime = now;
			var gl = this.context.gl;
			var color = this.backgroundColor;
			this.resize();
			gl.clearColor(color.r, color.g, color.b, color.a);
			gl.clear(gl.COLOR_BUFFER_BIT);
			var state = this.state;
			var skeleton = this.skeleton;
			var premultipliedAlpha = this.config.premultipliedAlpha;
			state.update(delta);
			state.apply(skeleton);
			skeleton.updateWorldTransform();
			var shader = this.shader;
			var batcher = this.batcher;
			var skeletonRenderer = this.skeletonRenderer;
			shader.bind();
			shader.setUniformi(spine.webgl.Shader.SAMPLER, 0);
			shader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, this.mvp.values);
			batcher.begin(shader);
			skeletonRenderer.premultipliedAlpha = premultipliedAlpha;
			skeletonRenderer.draw(batcher, skeleton);
			batcher.end();
			shader.unbind();
			if (this.config.debug) {
				var shader_1 = this.debugShader;
				var shapes = this.shapes;
				var renderer = this.debugRenderer;
				shader_1.bind();
				shader_1.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, this.mvp.values);
				renderer.premultipliedAlpha = premultipliedAlpha;
				shapes.begin(shader_1);
				renderer.draw(shapes, skeleton);
				shapes.end();
				shader_1.unbind();
			}
			if (!this.paused)
				requestAnimationFrame(function () { _this.render(); });
		};
		SpineWidget.prototype.resize = function () {
			var canvas = this.canvas;
			var w = canvas.clientWidth;
			var h = canvas.clientHeight;
			var bounds = this.bounds;
			var devicePixelRatio = window.devicePixelRatio || 1;
			if (canvas.width != Math.floor(w * devicePixelRatio) || canvas.height != Math.floor(h * devicePixelRatio)) {
				canvas.width = Math.floor(w * devicePixelRatio);
				canvas.height = Math.floor(h * devicePixelRatio);
			}
			if (this.config.fitToCanvas) {
				var centerX = bounds.offset.x + bounds.size.x / 2;
				var centerY = bounds.offset.y + bounds.size.y / 2;
				var scaleX = bounds.size.x / w;
				var scaleY = bounds.size.y / h;
				var scale = Math.max(scaleX, scaleY) * 1.2;
				if (scale < 1)
					scale = 1;
				var width = w * scale;
				var height = h * scale;
				this.skeleton.x = this.skeleton.y = 0;
				this.mvp.ortho2d(centerX - width / 2, centerY - height / 2, width, height);
			}
			else {
				this.mvp.ortho2d(0, 0, w - 1, h - 1);
			}
			this.context.gl.viewport(0, 0, canvas.width, canvas.height);
		};
		SpineWidget.prototype.pause = function () {
			this.paused = true;
		};
		SpineWidget.prototype.play = function () {
			var _this = this;
			this.paused = false;
			requestAnimationFrame(function () { _this.render(); });
		};
		SpineWidget.prototype.isPlaying = function () {
			return !this.paused;
		};
		SpineWidget.prototype.setAnimation = function (animationName, animationStateListener) {
			if (animationStateListener === void 0) { animationStateListener = null; }
			if (!this.loaded)
				throw new Error("Widget isn't loaded yet");
			this.skeleton.setToSetupPose();
			var entry = this.state.setAnimation(0, animationName, this.config.loop);
			entry.listener = animationStateListener;
		};
		SpineWidget.loadWidgets = function () {
			var widgets = document.getElementsByClassName("spine-widget");
			for (var i = 0; i < widgets.length; i++) {
				SpineWidget.loadWidget(widgets[i]);
			}
		};
		SpineWidget.loadWidget = function (widget) {
			var config = new SpineWidgetConfig();
			config.atlas = widget.getAttribute("data-atlas");
			config.json = widget.getAttribute("data-json");
			config.animation = widget.getAttribute("data-animation");
			if (widget.getAttribute("data-images-path"))
				config.imagesPath = widget.getAttribute("data-images-path");
			if (widget.getAttribute("data-atlas-pages"))
				config.atlasPages = widget.getAttribute("data-atlas-pages").split(",");
			if (widget.getAttribute("data-skin"))
				config.skin = widget.getAttribute("data-skin");
			if (widget.getAttribute("data-loop"))
				config.loop = widget.getAttribute("data-loop") === "true";
			if (widget.getAttribute("data-scale"))
				config.scale = parseFloat(widget.getAttribute("data-scale"));
			if (widget.getAttribute("data-x"))
				config.x = parseFloat(widget.getAttribute("data-x"));
			if (widget.getAttribute("data-y"))
				config.y = parseFloat(widget.getAttribute("data-y"));
			if (widget.getAttribute("data-fit-to-canvas"))
				config.fitToCanvas = widget.getAttribute("data-fit-to-canvas") === "true";
			if (widget.getAttribute("data-background-color"))
				config.backgroundColor = widget.getAttribute("data-background-color");
			if (widget.getAttribute("data-premultiplied-alpha"))
				config.premultipliedAlpha = widget.getAttribute("data-premultiplied-alpha") === "true";
			if (widget.getAttribute("data-debug"))
				config.debug = widget.getAttribute("data-debug") === "true";
			if (widget.getAttribute("data-alpha"))
				config.alpha = widget.getAttribute("data-alpha") === "true";
			new spine.SpineWidget(widget, config);
		};
		SpineWidget.ready = function () {
			if (SpineWidget.pageLoaded)
				return;
			SpineWidget.pageLoaded = true;
			SpineWidget.loadWidgets();
		};
		SpineWidget.setupDOMListener = function () {
			if (document.addEventListener) {
				document.addEventListener("DOMContentLoaded", SpineWidget.ready, false);
				window.addEventListener("load", SpineWidget.ready, false);
			}
			else {
				document.attachEvent("onreadystatechange", function readyStateChange() {
					if (document.readyState === "complete")
						SpineWidget.ready();
				});
				window.attachEvent("onload", SpineWidget.ready);
			}
		};
		SpineWidget.pageLoaded = false;
		return SpineWidget;
	}());
	spine.SpineWidget = SpineWidget;
	var SpineWidgetConfig = (function () {
		function SpineWidgetConfig() {
			this.skin = "default";
			this.loop = true;
			this.scale = 1.0;
			this.x = 0;
			this.y = 0;
			this.alpha = true;
			this.fitToCanvas = true;
			this.backgroundColor = "#555555";
			this.premultipliedAlpha = false;
			this.debug = false;
		}
		return SpineWidgetConfig;
	}());
	spine.SpineWidgetConfig = SpineWidgetConfig;
})(spine || (spine = {}));
spine.SpineWidget.setupDOMListener();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (spine);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _spine_runtime_spine_widget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spine_runtime/spine-widget */ "./src/spine_runtime/spine-widget.js");
/* harmony import */ var _spine_runtime_SkeletonBinary3_5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spine_runtime/SkeletonBinary3.5.js */ "./src/spine_runtime/SkeletonBinary3.5.js");


function parse(data) {
  const parser = new _spine_runtime_SkeletonBinary3_5_js__WEBPACK_IMPORTED_MODULE_1__.SkeletonBinary();
  parser.data = data;
  parser.initJson();
  return parser.json;
}
function loadSkel(path) {
  return new Promise((res, rej) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", path, true);
    xhr.responseType = "arraybuffer";
    xhr.onloadend = (e) => {
      if (xhr.status >= 200 && xhr.status < 300) {
        res(parse(new Uint8Array(xhr.response)));
      } else {
        rej(xhr.status);
      }
    };
    xhr.send();
  });
}
function render(
  dom,
  {
    atlasPath,
    atlasPages,
    skelPath,
    ani,
    backgroundColor = "#ffffff",
    debug = false,
    loop = true,
    skin,
    scale,
    x = 500,
    y = 200,
    fitToCanvas = false,
    onSuccess,
    onSkelLoaded,
  }
) {
  loadSkel(skelPath).then(function (json) {
    if (onSkelLoaded) {
      onSkelLoaded(json);
    }
    if (debug) {
      console.log(json);
    }
    new _spine_runtime_spine_widget__WEBPACK_IMPORTED_MODULE_0__.default.SpineWidget(dom, {
      jsonContent: json,
      atlas: atlasPath,
      atlasPages,
      animation: ani,
      backgroundColor,
      debug,
      loop,
      skin,
      scale,
      x,
      y,
      fitToCanvas,
      success: onSuccess,
      premultipliedAlpha: true,
    });
  });
}

})();

window.SpineRender = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGluZVJlbmRlci8uL3NyYy9zcGluZV9ydW50aW1lL1NrZWxldG9uQmluYXJ5My41LmpzIiwid2VicGFjazovL1NwaW5lUmVuZGVyLy4vc3JjL3NwaW5lX3J1bnRpbWUvc3BpbmUtd2lkZ2V0LmpzIiwid2VicGFjazovL1NwaW5lUmVuZGVyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL1NwaW5lUmVuZGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9TcGluZVJlbmRlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1NwaW5lUmVuZGVyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vU3BpbmVSZW5kZXIvLi9zcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBLGVBQWU7QUFDZixpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ3B5QkEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNDQUFzQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQWdEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFnRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQTZDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQseUJBQXlCLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMENBQTBDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QywwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9EQUFvRDtBQUN0RDtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBDQUEwQztBQUM1QztBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0RBQWtEO0FBQ3BEO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBZ0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOENBQThDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUE0QztBQUM5QztBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0RBQWtEO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhDQUE4QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixzQkFBc0IsT0FBTztBQUM3QixzQkFBc0IsT0FBTztBQUM3QixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0Isc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsMENBQTBDO0FBQzVDLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLDBDQUEwQztBQUM1QyxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxtREFBbUQ7QUFDbkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLDBDQUEwQztBQUM1QyxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RSw2Q0FBNkMsc0RBQXNEO0FBQ25HLDZDQUE2QyxxREFBcUQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FLDRDQUE0Qyw0QkFBNEI7QUFDeEUsNENBQTRDLDJCQUEyQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOERBQThEO0FBQ2pFO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RCxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6Qyw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekMsNEJBQTRCLGVBQWU7QUFDM0MsNEJBQTRCLGVBQWU7QUFDM0MsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6Qyw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QztBQUMvQztBQUNBLEVBQUUsMENBQTBDO0FBQzVDLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkUsbURBQW1ELDBCQUEwQjtBQUM3RSxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDhDQUE4QyxrREFBa0QsaURBQWlELCtCQUErQixtQ0FBbUMsMEJBQTBCLDJDQUEyQyxtREFBbUQsOEVBQThFLFdBQVc7QUFDbmUscUdBQXFHLDJGQUEyRixtQ0FBbUMsc0NBQXNDLDBCQUEwQix1RUFBdUUsV0FBVztBQUNyWDtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsOENBQThDLCtDQUErQyxrREFBa0QsaURBQWlELCtCQUErQiw4QkFBOEIsbUNBQW1DLDBCQUEwQiwyQ0FBMkMsMkNBQTJDLG1EQUFtRCw4RUFBOEUsV0FBVztBQUMzbEIscUdBQXFHLDJGQUEyRixtQ0FBbUMsbUNBQW1DLHNDQUFzQywwQkFBMEIsOERBQThELGlEQUFpRCxtQ0FBbUMsc0dBQXNHLFdBQVc7QUFDemtCO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw4Q0FBOEMsaURBQWlELCtCQUErQiwwQkFBMEIsMkNBQTJDLDhFQUE4RSxXQUFXO0FBQzNWLHFHQUFxRywyRkFBMkYsMEJBQTBCLG1DQUFtQyxXQUFXO0FBQ3hRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsMENBQTBDO0FBQzVDLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6Qyw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMENBQTBDO0FBQzdDO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLDBDQUEwQztBQUM1QyxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5Qix1QkFBdUIsT0FBTztBQUM5Qix1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLDBDQUEwQztBQUM1QyxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0IsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSwwQ0FBMEM7QUFDNUMsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0IsRUFBRTtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDLGNBQWMsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0IsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQSxpRUFBZSxLQUFLLEVBQUM7Ozs7Ozs7VUM5elJyQjtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEEsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOaUQ7QUFDcUI7QUFDdEU7QUFDQSxxQkFBcUIsK0VBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwiZmlsZSI6IlNwaW5lUmVuZGVyZXIuNGE2ZTYzYmQuY2h1bmsuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gU2tlbGV0b25CaW5hcnkoKSB7fVxuXG5Ta2VsZXRvbkJpbmFyeS5wcm90b3R5cGUgPSB7XG4gIGRhdGE6IG51bGwsXG4gIHNjYWxlOiAweDEsXG4gIGpzb246IHt9LFxuICBuZXh0TnVtOiAweDAsXG4gIGNoYXJzOiBudWxsLFxuICByZWFkQnl0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5leHROdW0gPCB0aGlzLmRhdGEubGVuZ3RoID8gdGhpcy5kYXRhW3RoaXMubmV4dE51bSsrXSA6IG51bGw7XG4gIH0sXG4gIHJlYWRCb29sZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJ5dGUoKSAhPSAweDA7XG4gIH0sXG4gIHJlYWRTaG9ydDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5yZWFkQnl0ZSgpIDw8IDB4OCkgfCB0aGlzLnJlYWRCeXRlKCk7XG4gIH0sXG4gIHJlYWRJbnQ6IGZ1bmN0aW9uIChvcHRpbWl6ZVBvc2l0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpbWl6ZVBvc2l0aXZlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5yZWFkQnl0ZSgpIDw8IDB4MTgpIHxcbiAgICAgICAgKHRoaXMucmVhZEJ5dGUoKSA8PCAweDEwKSB8XG4gICAgICAgICh0aGlzLnJlYWRCeXRlKCkgPDwgMHg4KSB8XG4gICAgICAgIHRoaXMucmVhZEJ5dGUoKVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGIgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICAgIGlmICgoYiAmIDB4ODApICE9IDB4MCkge1xuICAgICAgYiA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDB4NztcbiAgICAgIGlmICgoYiAmIDB4ODApICE9IDB4MCkge1xuICAgICAgICBiID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAweGU7XG4gICAgICAgIGlmICgoYiAmIDB4ODApICE9IDB4MCkge1xuICAgICAgICAgIGIgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMHgxNTtcbiAgICAgICAgICBpZiAoKGIgJiAweDgwKSAhPSAweDApIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAweDFjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW1pemVQb3NpdGl2ZSA/IHJlc3VsdCA6IChyZXN1bHQgPj4gMHgxKSBeIC0ocmVzdWx0ICYgMHgxKTtcbiAgfSxcbiAgYnl0ZXMyRmxvYXQzMjogZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgbGV0IHNpZ24gPSBieXRlcyAmIDB4ODAwMDAwMDAgPyAtMHgxIDogMHgxO1xuICAgIGxldCBleHBvbmVudCA9ICgoYnl0ZXMgPj4gMHgxNykgJiAweGZmKSAtIDB4N2Y7XG4gICAgbGV0IHNpZ25pZmljYW5kID0gYnl0ZXMgJiB+KC0weDEgPDwgMHgxNyk7XG4gICAgaWYgKGV4cG9uZW50ID09IDB4ODApXG4gICAgICByZXR1cm4gc2lnbiAqIChzaWduaWZpY2FuZCA/IE51bWJlci5OYU4gOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIGlmIChleHBvbmVudCA9PSAtMHg3Zikge1xuICAgICAgaWYgKHNpZ25pZmljYW5kID09IDB4MCkgcmV0dXJuIHNpZ24gKiAweDA7XG4gICAgICBleHBvbmVudCA9IC0weDdlO1xuICAgICAgc2lnbmlmaWNhbmQgLz0gMHgxIDw8IDB4MTY7XG4gICAgfSBlbHNlIHNpZ25pZmljYW5kID0gKHNpZ25pZmljYW5kIHwgKDB4MSA8PCAweDE3KSkgLyAoMHgxIDw8IDB4MTcpO1xuICAgIHJldHVybiBzaWduICogc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygweDIsIGV4cG9uZW50KTtcbiAgfSxcbiAgcmVhZEZsb2F0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXMyRmxvYXQzMihcbiAgICAgICh0aGlzLnJlYWRCeXRlKCkgPDwgMHgxOCkgK1xuICAgICAgICAodGhpcy5yZWFkQnl0ZSgpIDw8IDB4MTApICtcbiAgICAgICAgKHRoaXMucmVhZEJ5dGUoKSA8PCAweDgpICtcbiAgICAgICAgKHRoaXMucmVhZEJ5dGUoKSA8PCAweDApXG4gICAgKTtcbiAgfSxcbiAgcmVhZFZlcnRpY2VzOiBmdW5jdGlvbiAodmVydGV4Q291bnQpIHtcbiAgICBsZXQgdmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAweDE7XG4gICAgaWYgKCF0aGlzLnJlYWRCb29sZWFuKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRGbG9hdEFycmF5KHZlcnRpY2VzTGVuZ3RoLCB0aGlzLnNjYWxlKTtcbiAgICB9XG4gICAgbGV0IGJvbmVzQXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgbGV0IGRhdGFMZW5ndGggPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBib25lc0FycmF5LnB1c2goZGF0YUxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqID0gMHgwOyBqIDwgZGF0YUxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJvbmVzQXJyYXkucHVzaCh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgICAgICBib25lc0FycmF5LnB1c2godGhpcy5yZWFkRmxvYXQoKSAqIHRoaXMuc2NhbGUpO1xuICAgICAgICBib25lc0FycmF5LnB1c2godGhpcy5yZWFkRmxvYXQoKSAqIHRoaXMuc2NhbGUpO1xuICAgICAgICBib25lc0FycmF5LnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib25lc0FycmF5O1xuICB9LFxuICByZWFkRmxvYXRBcnJheTogZnVuY3Rpb24gKGxlbmd0aCwgc2NhbGUpIHtcbiAgICBsZXQgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBpZiAoc2NhbGUgPT0gMHgxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSB0aGlzLnJlYWRGbG9hdCgpICogc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcbiAgcmVhZFNob3J0QXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICBsZXQgYXJyYXkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IG47IGkrKykge1xuICAgICAgYXJyYXlbaV0gPSB0aGlzLnJlYWRTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIHJlYWRJbnRBcnJheTogZnVuY3Rpb24gKCkge1xuICAgIGxldCBuID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgIGxldCBhcnJheSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgbjsgaSsrKSBhcnJheVtpXSA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIHJlYWRIZXg6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgaGV4ID0gdGhpcy5yZWFkQnl0ZSgpLnRvU3RyaW5nKDB4MTApO1xuICAgIHJldHVybiBoZXgubGVuZ3RoID09IDB4MiA/IGhleCA6IFwiMFwiICsgaGV4O1xuICB9LFxuICByZWFkQ29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkSGV4KCkgKyB0aGlzLnJlYWRIZXgoKSArIHRoaXMucmVhZEhleCgpICsgdGhpcy5yZWFkSGV4KCk7XG4gIH0sXG4gIHJlYWRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY2hhckNvdW50ID0gdGhpcy5yZWFkSW50KHRoaXMsICEhW10pO1xuICAgIHN3aXRjaCAoY2hhckNvdW50KSB7XG4gICAgICBjYXNlIDB4MDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIDB4MTpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNoYXJDb3VudC0tO1xuICAgIHRoaXMuY2hhcnMgPSBcIlwiO1xuICAgIGxldCBjaGFySW5kZXggPSAweDA7XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IGNoYXJDb3VudDsgKSB7XG4gICAgICBjaGFySW5kZXggPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICBzd2l0Y2ggKGNoYXJJbmRleCA+PiAweDQpIHtcbiAgICAgICAgY2FzZSAweGM6XG4gICAgICAgIGNhc2UgMHhkOlxuICAgICAgICAgIHRoaXMuY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICgoY2hhckluZGV4ICYgMHgxZikgPDwgMHg2KSB8ICh0aGlzLnJlYWRCeXRlKCkgJiAweDNmKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaSArPSAweDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHhlOlxuICAgICAgICAgIHRoaXMuY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICgoY2hhckluZGV4ICYgMHhmKSA8PCAweGMpIHxcbiAgICAgICAgICAgICAgKCh0aGlzLnJlYWRCeXRlKCkgJiAweDNmKSA8PCAweDYpIHxcbiAgICAgICAgICAgICAgKHRoaXMucmVhZEJ5dGUoKSAmIDB4M2YpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpICs9IDB4MztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckluZGV4KTtcbiAgICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoYXJzO1xuICB9LFxuICBpbml0SnNvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuanNvbi5za2VsZXRvbiA9IHt9O1xuICAgIGxldCBza2VsZXRvbiA9IHRoaXMuanNvbi5za2VsZXRvbjtcbiAgICBza2VsZXRvbi5oYXNoID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgaWYgKHNrZWxldG9uLmhhc2gubGVuZ3RoID09IDB4MCkgc2tlbGV0b24uaGFzaCA9IG51bGw7XG4gICAgc2tlbGV0b24uc3BpbmUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICBpZiAoc2tlbGV0b24uc3BpbmUubGVuZ3RoID09IDB4MCkgc2tlbGV0b24uc3BpbmUgPSBudWxsO1xuICAgIHNrZWxldG9uLndpZHRoID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICBza2VsZXRvbi5oZWlnaHQgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgIGxldCBub25lc3NlbnRpYWwgPSB0aGlzLnJlYWRCb29sZWFuKCk7XG4gICAgaWYgKG5vbmVzc2VudGlhbCkge1xuICAgICAgc2tlbGV0b24uZnBzID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHNrZWxldG9uLmltYWdlcyA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgaWYgKHNrZWxldG9uLmltYWdlcy5sZW5ndGggPT0gMHgwKSBza2VsZXRvbi5pbWFnZXMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmpzb24uYm9uZXMgPSBuZXcgQXJyYXkodGhpcy5yZWFkSW50KCEhW10pKTtcbiAgICBsZXQgYm9uZXMgPSB0aGlzLmpzb24uYm9uZXM7XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYm9uZURhdGEgPSB7fTtcbiAgICAgIGJvbmVEYXRhLm5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIGJvbmVEYXRhLnBhcmVudCA9IG51bGw7XG4gICAgICBpZiAoaSAhPSAweDApIHtcbiAgICAgICAgY29uc3Qgbm9uZXNzZW50aWFsID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgICBib25lRGF0YS5wYXJlbnQgPSBib25lc1tub25lc3NlbnRpYWxdLm5hbWU7XG4gICAgICB9XG4gICAgICBib25lRGF0YS5yb3RhdGlvbiA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICBib25lRGF0YVtcInhcIl0gPSB0aGlzLnJlYWRGbG9hdCgpICogdGhpcy5zY2FsZTtcbiAgICAgIGJvbmVEYXRhW1wieVwiXSA9IHRoaXMucmVhZEZsb2F0KCkgKiB0aGlzLnNjYWxlO1xuICAgICAgYm9uZURhdGEuc2NhbGVYID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIGJvbmVEYXRhLnNjYWxlWSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICBib25lRGF0YS5zaGVhclggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgYm9uZURhdGEuc2hlYXJZID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIGJvbmVEYXRhLmxlbmd0aCA9IHRoaXMucmVhZEZsb2F0KCkgKiB0aGlzLnNjYWxlO1xuICAgICAgYm9uZURhdGEudHJhbnNmb3JtID0gVHJhbnNmb3JtTW9kZVt0aGlzLnJlYWRJbnQoISFbXSldO1xuICAgICAgaWYgKG5vbmVzc2VudGlhbCkge1xuICAgICAgICBib25lRGF0YS5jb2xvciA9IHRoaXMucmVhZENvbG9yKCk7XG4gICAgICB9XG4gICAgICBib25lc1tpXSA9IGJvbmVEYXRhO1xuICAgIH1cbiAgICB0aGlzLmpzb24uc2xvdHMgPSBuZXcgQXJyYXkodGhpcy5yZWFkSW50KCEhW10pKTtcbiAgICBsZXQgc2xvdHMgPSB0aGlzLmpzb24uc2xvdHM7XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xvdERhdGEgPSB7fTtcbiAgICAgIHNsb3REYXRhLm5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIGNvbnN0IGJvbmVEYXRhID0gdGhpcy5qc29uLmJvbmVzW3RoaXMucmVhZEludCghIVtdKV07XG4gICAgICBzbG90RGF0YS5ib25lID0gYm9uZURhdGEubmFtZTtcbiAgICAgIHNsb3REYXRhLmNvbG9yID0gdGhpcy5yZWFkQ29sb3IoKTtcbiAgICAgIHNsb3REYXRhLmF0dGFjaG1lbnQgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIHNsb3REYXRhLmJsZW5kID0gQmxlbmRNb2RlW3RoaXMucmVhZEludCghIVtdKV07XG4gICAgICBzbG90c1tpXSA9IHNsb3REYXRhO1xuICAgIH1cbiAgICB0aGlzLmpzb25bXCJpa1wiXSA9IG5ldyBBcnJheSh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgIGxldCBpayA9IHRoaXMuanNvbltcImlrXCJdO1xuICAgIGZvciAobGV0IGkgPSAweDA7IGkgPCBpay5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGlrQ29uc3RyYWludHMgPSB7fTtcbiAgICAgIGlrQ29uc3RyYWludHMubmFtZSA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgaWtDb25zdHJhaW50cy5vcmRlciA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgIGlrQ29uc3RyYWludHMuYm9uZXMgPSBuZXcgQXJyYXkodGhpcy5yZWFkSW50KCEhW10pKTtcbiAgICAgIGZvciAobGV0IGogPSAweDA7IGogPCBpa0NvbnN0cmFpbnRzLmJvbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlrQ29uc3RyYWludHMuYm9uZXNbal0gPSB0aGlzLmpzb24uYm9uZXNbdGhpcy5yZWFkSW50KCEhW10pXS5uYW1lO1xuICAgICAgfVxuICAgICAgaWtDb25zdHJhaW50cy50YXJnZXQgPSB0aGlzLmpzb24uYm9uZXNbdGhpcy5yZWFkSW50KCEhW10pXS5uYW1lO1xuICAgICAgaWtDb25zdHJhaW50cy5taXggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgaWtDb25zdHJhaW50cy5iZW5kUG9zaXRpdmUgPSB0aGlzLnJlYWRCeXRlKCkgIT0gMHhmZjtcbiAgICAgIGlrW2ldID0gaWtDb25zdHJhaW50cztcbiAgICB9XG4gICAgdGhpcy5qc29uLnRyYW5zZm9ybSA9IG5ldyBBcnJheSh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLmpzb24udHJhbnNmb3JtO1xuICAgIGZvciAobGV0IGkgPSAweDA7IGkgPCB0cmFuc2Zvcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm1EYXRhID0ge307XG4gICAgICB0cmFuc2Zvcm1EYXRhLm5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEub3JkZXIgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBjb25zdCBib25lcyA9IG5ldyBBcnJheSh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgICAgZm9yIChsZXQgaiA9IDB4MCwgbGVuID0gYm9uZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgYm9uZXNbal0gPSB0aGlzLmpzb24uYm9uZXNbdGhpcy5yZWFkSW50KCEhW10pXS5uYW1lO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtRGF0YS5ib25lcyA9IGJvbmVzO1xuICAgICAgdHJhbnNmb3JtRGF0YS50YXJnZXQgPSB0aGlzLmpzb24uYm9uZXNbdGhpcy5yZWFkSW50KCEhW10pXS5uYW1lO1xuICAgICAgdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICB0cmFuc2Zvcm1EYXRhW1wieFwiXSA9IHRoaXMucmVhZEZsb2F0KCkgKiB0aGlzLnNjYWxlO1xuICAgICAgdHJhbnNmb3JtRGF0YVtcInlcIl0gPSB0aGlzLnJlYWRGbG9hdCgpICogdGhpcy5zY2FsZTtcbiAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVYID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVZID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEuc2hlYXJZID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEucm90YXRlTWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNsYXRlTWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVNaXggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgdHJhbnNmb3JtRGF0YS5zaGVhck1peCA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICB0cmFuc2Zvcm1baV0gPSB0cmFuc2Zvcm1EYXRhO1xuICAgIH1cbiAgICB0aGlzLmpzb24ucGF0aCA9IG5ldyBBcnJheSh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgIGxldCBwYXRoID0gdGhpcy5qc29uLnBhdGg7XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXRoRGF0YSA9IHt9O1xuICAgICAgcGF0aERhdGEubmFtZSA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgcGF0aERhdGEub3JkZXIgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBwYXRoRGF0YS5ib25lcyA9IG5ldyBBcnJheSh0aGlzLnJlYWRJbnQoISFbXSkpO1xuICAgICAgZm9yIChsZXQgaiA9IDB4MCwgbGVuID0gcGF0aERhdGEuYm9uZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcGF0aERhdGEuYm9uZXNbal0gPSB0aGlzLmpzb24uYm9uZXNbdGhpcy5yZWFkSW50KCEhW10pXS5uYW1lO1xuICAgICAgfVxuICAgICAgcGF0aERhdGEudGFyZ2V0ID0gdGhpcy5qc29uLnNsb3RzW3RoaXMucmVhZEludCghIVtdKV0ubmFtZTtcbiAgICAgIHBhdGhEYXRhLnBvc2l0aW9uTW9kZSA9IFBvc2l0aW9uTW9kZVt0aGlzLnJlYWRJbnQoISFbXSldO1xuICAgICAgcGF0aERhdGEuc3BhY2luZ01vZGUgPSBTcGFjaW5nTW9kZVt0aGlzLnJlYWRJbnQoISFbXSldO1xuICAgICAgcGF0aERhdGEucm90YXRlTW9kZSA9IFJvdGF0ZU1vZGVbdGhpcy5yZWFkSW50KCEhW10pXTtcbiAgICAgIHBhdGhEYXRhLnJvdGF0aW9uID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHBhdGhEYXRhLnBvc2l0aW9uID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIGlmIChwYXRoRGF0YS5wb3NpdGlvbk1vZGUgPT0gXCJmaXhlZFwiKSB7XG4gICAgICAgIHBhdGhEYXRhLnBvc2l0aW9uICo9IHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBwYXRoRGF0YS5zcGFjaW5nID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIGlmIChwYXRoRGF0YS5zcGFjaW5nTW9kZSA9PSBcImxlbmd0aFwiIHx8IHBhdGhEYXRhLnNwYWNpbmdNb2RlID09IFwiZml4ZWRcIikge1xuICAgICAgICBwYXRoRGF0YS5zcGFjaW5nICo9IHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBwYXRoRGF0YS5yb3RhdGVNaXggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgcGF0aERhdGEudHJhbnNsYXRlTWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgIHBhdGhbaV0gPSBwYXRoRGF0YTtcbiAgICB9XG4gICAgdGhpcy5qc29uLnNraW5zID0ge307XG4gICAgdGhpcy5qc29uLnNraW5zTmFtZSA9IG5ldyBBcnJheSgpO1xuICAgIGxldCBza2lucyA9IHRoaXMuanNvbi5za2lucztcbiAgICBsZXQgc2tpbkRhdGEgPSB0aGlzLnJlYWRTa2luKFwiZGVmYXVsdFwiLCBub25lc3NlbnRpYWwpO1xuICAgIGlmIChza2luRGF0YSAhPSBudWxsKSB7XG4gICAgICBza2lucy5kZWZhdWx0ID0gc2tpbkRhdGE7XG4gICAgICB0aGlzLmpzb24uc2tpbnNOYW1lLnB1c2goXCJkZWZhdWx0XCIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMHgwLCBsZW4gPSB0aGlzLnJlYWRJbnQoISFbXSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHNraW5OYW1lID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgICBsZXQgc2tpbiA9IHRoaXMucmVhZFNraW4oc2tpbk5hbWUsIG5vbmVzc2VudGlhbCk7XG4gICAgICBza2luc1tza2luTmFtZV0gPSBza2luO1xuICAgICAgdGhpcy5qc29uLnNraW5zTmFtZS5wdXNoKHNraW5OYW1lKTtcbiAgICB9XG4gICAgdGhpcy5qc29uLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuanNvbi5ldmVudHNOYW1lID0gW107XG4gICAgbGV0IGV2ZW50cyA9IHRoaXMuanNvbi5ldmVudHM7XG4gICAgZm9yIChsZXQgaSA9IDB4MCwgbGVuID0gdGhpcy5yZWFkSW50KCEhW10pOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBldmVudE5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIGxldCBldmVudCA9IHt9O1xuICAgICAgZXZlbnQuaW50ID0gdGhpcy5yZWFkSW50KCFbXSk7XG4gICAgICBldmVudC5mbG9hdCA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICBldmVudC5zdHJpbmcgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnQ7XG4gICAgICB0aGlzLmpzb24uZXZlbnRzTmFtZVtpXSA9IGV2ZW50TmFtZTtcbiAgICB9XG4gICAgdGhpcy5qc29uLmFuaW1hdGlvbnMgPSB7fTtcbiAgICBsZXQgYW5pbWF0aW9ucyA9IHRoaXMuanNvbi5hbmltYXRpb25zO1xuICAgIGZvciAobGV0IGkgPSAweDAsIGxlbiA9IHRoaXMucmVhZEludCghIVtdKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgYW5pbWF0aW9uTmFtZSA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHRoaXMucmVhZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcbiAgICAgIGFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gPSBhbmltYXRpb247XG4gICAgfVxuICB9LFxuICByZWFkU2tpbihzbG90SW5kZXgsIG5vbmVzc2VudGlhbCkge1xuICAgIGxldCBzbG90Q291bnQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgaWYgKHNsb3RDb3VudCA9PSAweDApIHJldHVybiBudWxsO1xuICAgIGxldCBza2luID0ge307XG4gICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IHNsb3RDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBjb25zdCBzbG90ID0ge307XG4gICAgICBmb3IgKGxldCBqID0gMHgwLCBuID0gdGhpcy5yZWFkSW50KCEhW10pOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgICAgIGxldCBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChuYW1lLCBub25lc3NlbnRpYWwpO1xuICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgc2xvdFtuYW1lXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNraW5bdGhpcy5qc29uLnNsb3RzW3Nsb3RJbmRleF0ubmFtZV0gPSBzbG90O1xuICAgIH1cbiAgICByZXR1cm4gc2tpbjtcbiAgfSxcbiAgcmVhZEF0dGFjaG1lbnQoYXR0YWNobWVudE5hbWUsIG5vbmVzc2VudGlhbCkge1xuICAgIGxldCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgbGV0IG5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICBpZiAobmFtZSA9PSBudWxsKSBuYW1lID0gYXR0YWNobWVudE5hbWU7XG5cbiAgICBsZXQgcGF0aCxcbiAgICAgIG4sXG4gICAgICByZWdpb24gPSB7fSxcbiAgICAgIGJveCA9IHt9LFxuICAgICAgbWVzaCA9IHt9LFxuICAgICAgbGlua2RlTWVzaCA9IHt9O1xuICAgIGxldCBhcnJheTtcbiAgICBsZXQgcG9pbnQgPSB7fTtcbiAgICBsZXQgY2xpcHBpbmcgPSB7fTtcblxuICAgIHN3aXRjaCAoQXR0YWNobWVudFR5cGVbdGhpcy5yZWFkQnl0ZSgpXSkge1xuICAgICAgY2FzZSBcInJlZ2lvblwiOlxuICAgICAgICBwYXRoID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHBhdGggPSBuYW1lO1xuICAgICAgICByZWdpb24udHlwZSA9IFwicmVnaW9uXCI7XG4gICAgICAgIHJlZ2lvbi5uYW1lID0gbmFtZTtcbiAgICAgICAgcmVnaW9uLnBhdGggPSBwYXRoLnRyaW0oKTtcbiAgICAgICAgcmVnaW9uLnJvdGF0aW9uID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgcmVnaW9uW1wieFwiXSA9IHRoaXMucmVhZEZsb2F0KCkgKiBzY2FsZTtcbiAgICAgICAgcmVnaW9uW1wieVwiXSA9IHRoaXMucmVhZEZsb2F0KCkgKiBzY2FsZTtcbiAgICAgICAgcmVnaW9uLnNjYWxlWCA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgIHJlZ2lvbi5zY2FsZVkgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICByZWdpb24ud2lkdGggPSB0aGlzLnJlYWRGbG9hdCgpICogc2NhbGU7XG4gICAgICAgIHJlZ2lvbi5oZWlnaHQgPSB0aGlzLnJlYWRGbG9hdCgpICogc2NhbGU7XG4gICAgICAgIHJlZ2lvbi5jb2xvciA9IHRoaXMucmVhZENvbG9yKCk7XG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgICBjYXNlIFwiYm91bmRpbmdib3hcIjpcbiAgICAgICAgYm94LnR5cGUgPSBcImJvdW5kaW5nYm94XCI7XG4gICAgICAgIGJveC5uYW1lID0gbmFtZTtcbiAgICAgICAgbiA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgYm94LnZlcnRleENvdW50ID0gbjtcbiAgICAgICAgYm94LnZlcnRpY2VzID0gdGhpcy5yZWFkVmVydGljZXMobik7XG4gICAgICAgIGlmICh0aGlzLm5vbmVzc2VudGlhbCkge1xuICAgICAgICAgIGJveC5jb2xvciA9IHRoaXMucmVhZENvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgIGNhc2UgXCJtZXNoXCI6XG4gICAgICAgIHBhdGggPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkgcGF0aCA9IG5hbWU7XG4gICAgICAgIG1lc2gudHlwZSA9IFwibWVzaFwiO1xuICAgICAgICBtZXNoLm5hbWUgPSBuYW1lO1xuICAgICAgICBtZXNoLnBhdGggPSBwYXRoO1xuICAgICAgICBtZXNoLmNvbG9yID0gdGhpcy5yZWFkQ29sb3IoKTtcbiAgICAgICAgbiA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgbWVzaC51dnMgPSB0aGlzLnJlYWRGbG9hdEFycmF5KG4gPDwgMHgxLCAweDEpO1xuICAgICAgICBtZXNoLnRyaWFuZ2xlcyA9IHRoaXMucmVhZFNob3J0QXJyYXkoKTtcbiAgICAgICAgbWVzaC52ZXJ0aWNlcyA9IHRoaXMucmVhZFZlcnRpY2VzKG4pO1xuICAgICAgICBtZXNoLmh1bGwgPSB0aGlzLnJlYWRJbnQoISFbXSkgPDwgMHgxO1xuICAgICAgICBpZiAobm9uZXNzZW50aWFsKSB7XG4gICAgICAgICAgbWVzaC5lZGdlcyA9IHRoaXMucmVhZFNob3J0QXJyYXkoKTtcbiAgICAgICAgICBtZXNoLndpZHRoID0gdGhpcy5yZWFkRmxvYXQoKSAqIHNjYWxlO1xuICAgICAgICAgIG1lc2guaGVpZ2h0ID0gdGhpcy5yZWFkRmxvYXQoKSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNoO1xuICAgICAgY2FzZSBcImxpbmtlZG1lc2hcIjpcbiAgICAgICAgcGF0aCA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSBwYXRoID0gbmFtZTtcbiAgICAgICAgbGlua2RlTWVzaC50eXBlID0gXCJsaW5rZWRtZXNoXCI7XG4gICAgICAgIGxpbmtkZU1lc2gubmFtZSA9IG5hbWU7XG4gICAgICAgIGxpbmtkZU1lc2gucGF0aCA9IHBhdGg7XG4gICAgICAgIGxpbmtkZU1lc2guY29sb3IgPSB0aGlzLnJlYWRDb2xvcigpO1xuICAgICAgICBsaW5rZGVNZXNoLnNraW4gPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgbGlua2RlTWVzaC5wYXJlbnQgPSB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgbGlua2RlTWVzaC5kZWZvcm0gPSB0aGlzLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcbiAgICAgICAgICBsaW5rZGVNZXNoLndpZHRoID0gdGhpcy5yZWFkRmxvYXQoKSAqIHNjYWxlO1xuICAgICAgICAgIGxpbmtkZU1lc2guaGVpZ2h0ID0gdGhpcy5yZWFkRmxvYXQoKSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rZGVNZXNoO1xuICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgcGF0aCA9IHt9O1xuICAgICAgICBwYXRoLnR5cGUgPSBcInBhdGhcIjtcbiAgICAgICAgcGF0aC5uYW1lID0gbmFtZTtcbiAgICAgICAgcGF0aC5jbG9zZWQgPSB0aGlzLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIHBhdGguY29uc3RhbnRTcGVlZCA9IHRoaXMucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgbiA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgcGF0aC52ZXJ0ZXhDb3VudCA9IG47XG4gICAgICAgIHBhdGgudmVydGljZXMgPSB0aGlzLnJlYWRWZXJ0aWNlcyhuKTtcbiAgICAgICAgYXJyYXkgPSBhcnJheSA9IG5ldyBBcnJheShuIC8gMHgzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJyYXlbaV0gPSB0aGlzLnJlYWRGbG9hdCgpICogc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5sZW5ndGhzID0gYXJyYXk7XG4gICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcbiAgICAgICAgICBwYXRoLmNvbG9yID0gdGhpcy5yZWFkQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBwb2ludC50eXBlID0gXCJwb2ludFwiO1xuICAgICAgICBwb2ludC5uYW1lID0gbmFtZTtcbiAgICAgICAgcG9pbnQucm90YXRpb24gPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICBwb2ludFtcInhcIl0gPSB0aGlzLnJlYWRGbG9hdCgpICogc2NhbGU7XG4gICAgICAgIHBvaW50W1wieVwiXSA9IHRoaXMucmVhZEZsb2F0KCkgKiBzY2FsZTtcbiAgICAgICAgaWYgKG5vbmVzc2VudGlhbCkge1xuICAgICAgICAgIHBhdGguY29sb3IgPSB0aGlzLnJlYWRDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIGNhc2UgXCJjbGlwcGluZ1wiOlxuICAgICAgICBjbGlwcGluZy50eXBlID0gXCJjbGlwcGluZ1wiO1xuICAgICAgICBjbGlwcGluZy5uYW1lID0gbmFtZTtcbiAgICAgICAgY2xpcHBpbmcuZW5kID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgICBuID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgICBjbGlwcGluZy52ZXJ0ZXhDb3VudCA9IG47XG4gICAgICAgIGNsaXBwaW5nLnZlcnRpY2VzID0gdGhpcy5yZWFkVmVydGljZXMobik7XG4gICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcbiAgICAgICAgICBjbGlwcGluZy5jb2xvciA9IHRoaXMucmVhZENvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaXBwaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcmVhZEN1cnZlKGZyYW1lSW5kZXgsIHRpbWVsaW5lKSB7XG4gICAgbGV0IGN4MSwgY3kxLCBjeDIsIGN5MjtcbiAgICBzd2l0Y2ggKHRoaXMucmVhZEJ5dGUoKSkge1xuICAgICAgY2FzZSAweDA6XG4gICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLmN1cnZlID0gXCJsaW5lYXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MTpcbiAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0uY3VydmUgPSBcInN0ZXBwZWRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MjpcbiAgICAgICAgY3gxID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgY3kxID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgY3gyID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgY3kyID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0uY3VydmUgPSBbY3gxLCBjeTEsIGN4MiwgY3kyXTtcbiAgICB9XG4gIH0sXG4gIHJlYWRBbmltYXRpb24obmFtZSkge1xuICAgIGxldCBhbmltYXRpb24gPSB7fTtcbiAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGxldCBkdXJhdGlvbiA9IDB4MDtcbiAgICBsZXQgc2xvdHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMHgwLCBubiA9IHRoaXMucmVhZEludCghIVtdKTsgaSA8IG5uOyBpKyspIHtcbiAgICAgIGxldCBzbG90SW5kZXggPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBsZXQgc2xvdE1hcCA9IHt9O1xuICAgICAgbGV0IHRpbWVDb3VudCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgIGZvciAobGV0IGlpID0gMHgwOyBpaSA8IHRpbWVDb3VudDsgaWkrKykge1xuICAgICAgICBsZXQgdGltZWxpbmVUeXBlID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgICBsZXQgZnJhbWVDb3VudCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgbGV0IHRpbWVsaW5lO1xuICAgICAgICBzd2l0Y2ggKHRpbWVsaW5lVHlwZSkge1xuICAgICAgICAgIGNhc2UgMHgwOlxuICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBmcmFtZUluZGV4ID0gMHgwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XG4gICAgICAgICAgICAgIGxldCB0aW1lID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdID0ge307XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS5uYW1lID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbG90TWFwLmF0dGFjaG1lbnQgPSB0aW1lbGluZTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lW2ZyYW1lQ291bnQgLSAweDFdLnRpbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE6XG4gICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBBcnJheShmcmFtZUNvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGZyYW1lSW5kZXggPSAweDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5yZWFkQ29sb3IoKTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDB4MSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGZyYW1lSW5kZXgsIHRpbWVsaW5lKTsgLy9sZXQgY3VydmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdE1hcC5jb2xvciA9IHRpbWVsaW5lO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmVbZnJhbWVDb3VudCAtIDB4MV0udGltZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MjpcbiAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgZnJhbWVJbmRleCA9IDB4MDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgbGV0IGxpZ2h0Q29sb3IgPSB0aGlzLnJlYWRDb2xvcigpO1xuICAgICAgICAgICAgICBsZXQgZGFya0NvbG9yID0gdGhpcy5yZWFkQ29sb3IoKTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLmxpZ2h0ID0gbGlnaHRDb2xvcjtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0uZGFyayA9IGRhcmtDb2xvcjtcbiAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMHgxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoZnJhbWVJbmRleCwgdGltZWxpbmUpOyAvLyBsZXQgY3VydmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdE1hcC50d29Db2xvciA9IHRpbWVsaW5lO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmVbZnJhbWVDb3VudCAtIDB4MV0udGltZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2xvdHNbdGhpcy5qc29uLnNsb3RzW3Nsb3RJbmRleF0ubmFtZV0gPSBzbG90TWFwO1xuICAgIH1cbiAgICBhbmltYXRpb24uc2xvdHMgPSBzbG90cztcbiAgICBsZXQgYm9uZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMHgwLCBuID0gdGhpcy5yZWFkSW50KCEhW10pOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYm9uZUluZGV4ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgbGV0IGJvbmVNYXAgPSB7fTtcbiAgICAgIGZvciAobGV0IGlpID0gMHgwLCBubiA9IHRoaXMucmVhZEludCghIVtdKTsgaWkgPCBubjsgaWkrKykge1xuICAgICAgICBjb25zdCB0aW1lbGluZVR5cGUgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICAgIGxldCB0aW1lbGluZTtcbiAgICAgICAgbGV0IHRpbWVsaW5lU2NhbGUgPSAweDE7XG5cbiAgICAgICAgc3dpdGNoICh0aW1lbGluZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIDB4MDpcbiAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgZnJhbWVJbmRleCA9IDB4MDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgY29uc3QgdGxhbmdsZSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdID0ge307XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS5hbmdsZSA9IHRsYW5nbGU7XG4gICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDB4MSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGZyYW1lSW5kZXgsIHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9uZU1hcC5yb3RhdGUgPSB0aW1lbGluZTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lW2ZyYW1lQ291bnQgLSAweDFdLnRpbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE6XG4gICAgICAgICAgY2FzZSAweDI6XG4gICAgICAgICAgY2FzZSAweDM6XG4gICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBBcnJheShmcmFtZUNvdW50KTtcbiAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT0gMHgxKSB7XG4gICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGZyYW1lSW5kZXggPSAweDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgbGV0IHRsdGltZSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgICAgICAgIGxldCB0bHggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICAgICAgICBsZXQgdGx5ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRsdGltZTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF1bXCJ4XCJdID0gdGx4ICogdGltZWxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF1bXCJ5XCJdID0gdGx5ICogdGltZWxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMHgxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoZnJhbWVJbmRleCwgdGltZWxpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZWxpbmVUeXBlID09IDB4MSkge1xuICAgICAgICAgICAgICBib25lTWFwLnRyYW5zbGF0ZSA9IHRpbWVsaW5lO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGluZVR5cGUgPT0gMHgyKSB7XG4gICAgICAgICAgICAgIGJvbmVNYXAuc2NhbGUgPSB0aW1lbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJvbmVNYXAuc2hlYXIgPSB0aW1lbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lW2ZyYW1lQ291bnQgLSAweDFdLnRpbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJvbmVzW3RoaXMuanNvbi5ib25lc1tib25lSW5kZXhdLm5hbWVdID0gYm9uZU1hcDtcbiAgICB9XG4gICAgYW5pbWF0aW9uLmJvbmVzID0gYm9uZXM7XG4gICAgbGV0IGlrID0ge307XG4gICAgZm9yIChsZXQgaSA9IDB4MCwgbm4gPSB0aGlzLnJlYWRJbnQoISFbXSk7IGkgPCBubjsgaSsrKSB7XG4gICAgICBjb25zdCBpa0luZGV4ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgY29uc3QgZnJhbWVDb3VudCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgIGNvbnN0IHRpbWVsaW5lID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuICAgICAgZm9yIChsZXQgZnJhbWVJbmRleCA9IDB4MDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgY29uc3QgYmVuZFBvc2l0aXZlID0gdGhpcy5yZWFkQnl0ZSgpICE9IDB4ZmY7XG4gICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdID0ge307XG4gICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS5taXggPSBtaXg7XG4gICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLmJlbmRQb3NpdGl2ZSA9IGJlbmRQb3NpdGl2ZTtcbiAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMHgxKSB7XG4gICAgICAgICAgdGhpcy5yZWFkQ3VydmUoZnJhbWVJbmRleCwgdGltZWxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpa1t0aGlzLmpzb25bXCJpa1wiXVtpa0luZGV4XS5uYW1lXSA9IHRpbWVsaW5lO1xuICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmVbZnJhbWVDb3VudCAtIDB4MV0udGltZSk7XG4gICAgfVxuICAgIGFuaW1hdGlvbltcImlrXCJdID0gaWs7XG4gICAgbGV0IGZmZCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAweDAsIG5uID0gdGhpcy5yZWFkSW50KCEhW10pOyBpIDwgbm47IGkrKykge1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgY29uc3QgZnJhbWVDb3VudCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgIGNvbnN0IHRpbWVsaW5lID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuICAgICAgZm9yIChsZXQgZnJhbWVJbmRleCA9IDB4MDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xuICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XSA9IHt9O1xuICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS50aW1lID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0ucm90YXRlTWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udHJhbnNsYXRlTWl4ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0uc2NhbGVNaXggPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS5zaGVhck1peCA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDB4MSkge1xuICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGZyYW1lSW5kZXgsIHRpbWVsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmZkW3RoaXMuanNvbi50cmFuc2Zvcm1bc2xvdEluZGV4XS5uYW1lXSA9IHRpbWVsaW5lO1xuICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmVbZnJhbWVDb3VudCAtIDB4MV0udGltZSk7XG4gICAgfVxuICAgIGFuaW1hdGlvbi50cmFuc2Zvcm0gPSBmZmQ7XG5cbiAgICBsZXQgcGF0aCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAweDAsIG4gPSB0aGlzLnJlYWRJbnQoISFbXSk7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBwYXRoT3JkZXIgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICBsZXQgcGF0aERhdGEgPSB0aGlzLmpzb24ucGF0aFtwYXRoT3JkZXJdO1xuICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgIGZvciAobGV0IGlpID0gMHgwLCBubiA9IHRoaXMucmVhZEludCghIVtdKTsgaWkgPCBubjsgaWkrKykge1xuICAgICAgICBjb25zdCB0aW1lbGluZVR5cGUgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICAgIGxldCB0aW1lbGluZSwgdGltZSwgdGltZWxpbmVTY2FsZTtcbiAgICAgICAgc3dpdGNoICh0aW1lbGluZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIDB4MDpcbiAgICAgICAgICBjYXNlIDB4MTpcbiAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IDB4MTtcbiAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT0gMHgxKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXRoRGF0YS5zcGFjaW5nTW9kZSA9PSBcImxlbmd0aFwiIHx8XG4gICAgICAgICAgICAgICAgcGF0aERhdGEuc3BhY2luZ01vZGUgPT0gXCJmaXhlZFwiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocGF0aERhdGEucG9zaXRpb25Nb2RlID09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBmcmFtZUluZGV4ID0gMHgwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICAgICAgICBsZXQgXzB4ZWJjNzk1ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT0gMHgwKSB7XG4gICAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0ucG9zaXRpb24gPSBfMHhlYmM3OTUgKiB0aW1lbGluZVNjYWxlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLnNwYWNpbmcgPSBfMHhlYmM3OTUgKiB0aW1lbGluZVNjYWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDB4MSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShmcmFtZUluZGV4LCB0aW1lbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZWxpbmVUeXBlID09IDB4MCkge1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gdGltZWxpbmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhLnNwYWNpbmcgPSB0aW1lbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lW2ZyYW1lQ291bnQgLSAweDFdLnRpbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDI6XG4gICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBBcnJheShmcmFtZUNvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGZyYW1lSW5kZXggPSAweDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgdGltZSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgICAgICAgIGxldCBfMHg0N2YwZjAgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICAgICAgICBsZXQgXzB4MWJiMWQ3ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgIHRpbWVsaW5lW2ZyYW1lSW5kZXhdLnJvdGF0ZU1peCA9IF8weDQ3ZjBmMDtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udHJhbnNsYXRlTWl4ID0gXzB4MWJiMWQ3O1xuICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA8IGZyYW1lQ291bnQgLSAweDEpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoZnJhbWVJbmRleCwgdGltZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5taXggPSB0aW1lbGluZTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lW2ZyYW1lQ291bnQgLSAweDFdLnRpbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGhbdGhpcy5qc29uLnBhdGhbcGF0aE9yZGVyXS5uYW1lXSA9IGRhdGE7XG4gICAgfVxuICAgIGFuaW1hdGlvbi5wYXRocyA9IHBhdGg7XG5cbiAgICAvLyDlj5jph4/lkI3lj6/og73kuI3lr7lcbiAgICBsZXQgZGVmb3JtID0ge307XG4gICAgZm9yIChsZXQgaSA9IDB4MCwgbiA9IHRoaXMucmVhZEludCghIVtdKTsgaSA8IG47IGkrKykge1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgbGV0IHNraW5OYW1lID0gdGhpcy5qc29uLnNraW5zTmFtZVtpbmRleF07XG4gICAgICBsZXQgZGVmb3JtRGF0YSA9IHt9O1xuICAgICAgZm9yIChsZXQgaWkgPSAweDAsIG5uID0gdGhpcy5yZWFkSW50KCEhW10pOyBpaSA8IG5uOyBpaSsrKSB7XG4gICAgICAgIGNvbnN0IHNsb3RJbmRleCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgY29uc3Qgc2xvdCA9IHRoaXMuanNvbi5zbG90c1tzbG90SW5kZXhdO1xuICAgICAgICBjb25zdCBhdHRhY2htZW50ID0ge307XG4gICAgICAgIGZvciAobGV0IGlpaSA9IDB4MCwgbm5uID0gdGhpcy5yZWFkSW50KCEhW10pOyBpaWkgPCBubm47IGlpaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICAgICAgY29uc3QgdGltZWxpbmUgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XG4gICAgICAgICAgZm9yIChsZXQgZnJhbWVJbmRleCA9IDB4MDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHRoaXMucmVhZEZsb2F0KCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XSA9IHt9O1xuICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICBpZiAoZW5kICE9IDB4MCkge1xuICAgICAgICAgICAgICBsZXQgdmVydGljZXMgPSBuZXcgQXJyYXkoZW5kKTtcbiAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgICAgICAgICBpZiAodGhpcy5zY2FsZSA9PSAweDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXSA9IHRoaXMucmVhZEZsb2F0KCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aW1lbGluZVtmcmFtZUluZGV4XS5vZmZzZXQgPSBzdGFydDtcbiAgICAgICAgICAgICAgdGltZWxpbmVbZnJhbWVJbmRleF0udmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDB4MSlcbiAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoZnJhbWVJbmRleCwgdGltZWxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRhY2htZW50W25hbWVdID0gdGltZWxpbmU7XG4gICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmVbZnJhbWVDb3VudCAtIDB4MV0udGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmb3JtRGF0YVtzbG90Lm5hbWVdID0gYXR0YWNobWVudDtcbiAgICAgIH1cbiAgICAgIGRlZm9ybVtza2luTmFtZV0gPSBkZWZvcm1EYXRhO1xuICAgIH1cbiAgICBhbmltYXRpb24uZGVmb3JtID0gZGVmb3JtO1xuXG4gICAgbGV0IGRyYXdPcmRlckNvdW50ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgIGlmIChkcmF3T3JkZXJDb3VudCA+IDB4MCkge1xuICAgICAgbGV0IGRyYXdPcmRlcnMgPSBuZXcgQXJyYXkoZHJhd09yZGVyQ291bnQpO1xuICAgICAgZm9yIChsZXQgaSA9IDB4MDsgaSA8IGRyYXdPcmRlckNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZHJhd09yZGVyTWFwID0ge307XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRDb3VudCA9IHRoaXMucmVhZEludCghIVtdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBBcnJheShvZmZzZXRDb3VudCk7XG4gICAgICAgIGZvciAobGV0IGlpID0gMHgwOyBpaSA8IG9mZnNldENvdW50OyBpaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TWFwID0ge307XG4gICAgICAgICAgY29uc3Qgc2xvdEluZGV4ID0gdGhpcy5yZWFkSW50KCEhW10pO1xuICAgICAgICAgIG9mZnNldE1hcC5zbG90ID0gdGhpcy5qc29uLnNsb3RzW3Nsb3RJbmRleF0ubmFtZTtcbiAgICAgICAgICBsZXQgZG9vZmZzZXQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgICAgICAgb2Zmc2V0TWFwLm9mZnNldCA9IGRvb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldHNbaWldID0gb2Zmc2V0TWFwO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdPcmRlck1hcC5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICAgICAgZHJhd09yZGVyTWFwLnRpbWUgPSB0aW1lO1xuICAgICAgICBkcmF3T3JkZXJzW2ldID0gZHJhd09yZGVyTWFwO1xuICAgICAgfVxuICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgZHJhd09yZGVyc1tkcmF3T3JkZXJDb3VudCAtIDB4MV0udGltZSk7XG4gICAgICBhbmltYXRpb24uZHJhd09yZGVyID0gZHJhd09yZGVycztcbiAgICB9XG4gICAgbGV0IGV2ZW50Q291bnQgPSB0aGlzLnJlYWRJbnQoISFbXSk7XG4gICAgaWYgKGV2ZW50Q291bnQgPiAweDApIHtcbiAgICAgIGxldCBldmVudHMgPSBuZXcgQXJyYXkoZXZlbnRDb3VudCk7XG4gICAgICBmb3IgKGxldCBpID0gMHgwOyBpIDwgZXZlbnRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLnJlYWRGbG9hdCgpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5qc29uLmV2ZW50c05hbWVbdGhpcy5yZWFkSW50KCEhW10pXTtcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gdGhpcy5qc29uLmV2ZW50c1tuYW1lXTtcbiAgICAgICAgY29uc3QgZSA9IHt9O1xuICAgICAgICBlLm5hbWUgPSBuYW1lO1xuICAgICAgICBlLmludCA9IHRoaXMucmVhZEludCghW10pO1xuICAgICAgICBlLmZsb2F0ID0gdGhpcy5yZWFkRmxvYXQoKTtcbiAgICAgICAgZS5zdHJpbmcgPSB0aGlzLnJlYWRCb29sZWFuKCkgPyB0aGlzLnJlYWRTdHJpbmcoKSA6IGV2ZW50RGF0YS5zdHJpbmc7XG4gICAgICAgIGUudGltZSA9IHRpbWU7XG4gICAgICAgIGV2ZW50c1tpXSA9IGU7XG4gICAgICB9XG4gICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCBldmVudHNbZXZlbnRDb3VudCAtIDB4MV0udGltZSk7XG4gICAgICBhbmltYXRpb24uZXZlbnRzID0gZXZlbnRzO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxufTtcblxudmFyIEJsZW5kTW9kZSA9IFtcIm5vcm1hbFwiLCBcImFkZGl0aXZlXCIsIFwibXVsdGlwbHlcIiwgXCJzY3JlZW5cIl07XG5cbnZhciBBdHRhY2htZW50VHlwZSA9IFtcbiAgXCJyZWdpb25cIixcbiAgXCJib3VuZGluZ2JveFwiLFxuICBcIm1lc2hcIixcbiAgXCJsaW5rZWRtZXNoXCIsXG4gIFwicGF0aFwiLFxuICBcInBvaW50XCIsXG4gIFwiY2xpcHBpbmdcIixcbl07XG5cbnZhciBUcmFuc2Zvcm1Nb2RlID0gW1xuICBcIm5vcm1hbFwiLFxuICBcIm9ubHlUcmFuc2xhdGlvblwiLFxuICBcIm5vUm90YXRpb25PclJlZmxlY3Rpb25cIixcbiAgXCJub1NjYWxlXCIsXG4gIFwibm9TY2FsZU9yUmVmbGVjdGlvblwiLFxuXTtcblxudmFyIFBvc2l0aW9uTW9kZSA9IFtcImZpeGVkXCIsIFwicGVyY2VudFwiXTtcblxudmFyIFNwYWNpbmdNb2RlID0gW1wibGVuZ3RoXCIsIFwiZml4ZWRcIiwgXCJwZXJjZW50XCJdO1xuXG52YXIgUm90YXRlTW9kZSA9IFtcInRhbmdlbnRcIiwgXCJjaGFpblwiLCBcImNoYWluU2NhbGVcIl07XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG5cdGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuXHRmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gQW5pbWF0aW9uKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pIHtcblx0XHRcdGlmIChuYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKHRpbWVsaW5lcyA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0aW1lbGluZXMgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMudGltZWxpbmVzID0gdGltZWxpbmVzO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdH1cblx0XHRBbmltYXRpb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgbG9vcCwgZXZlbnRzLCBhbHBoYSwgcG9zZSwgZGlyZWN0aW9uKSB7XG5cdFx0XHRpZiAoc2tlbGV0b24gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKGxvb3AgJiYgdGhpcy5kdXJhdGlvbiAhPSAwKSB7XG5cdFx0XHRcdHRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdFx0aWYgKGxhc3RUaW1lID4gMClcblx0XHRcdFx0XHRsYXN0VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRpbWVsaW5lcyA9IHRoaXMudGltZWxpbmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHR0aW1lbGluZXNbaV0uYXBwbHkoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldCwgc3RlcCkge1xuXHRcdFx0aWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMTsgfVxuXHRcdFx0dmFyIGxvdyA9IDA7XG5cdFx0XHR2YXIgaGlnaCA9IHZhbHVlcy5sZW5ndGggLyBzdGVwIC0gMjtcblx0XHRcdGlmIChoaWdoID09IDApXG5cdFx0XHRcdHJldHVybiBzdGVwO1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBoaWdoID4+PiAxO1xuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc1soY3VycmVudCArIDEpICogc3RlcF0gPD0gdGFyZ2V0KVxuXHRcdFx0XHRcdGxvdyA9IGN1cnJlbnQgKyAxO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aGlnaCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChsb3cgPT0gaGlnaClcblx0XHRcdFx0XHRyZXR1cm4gKGxvdyArIDEpICogc3RlcDtcblx0XHRcdFx0Y3VycmVudCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEFuaW1hdGlvbi5saW5lYXJTZWFyY2ggPSBmdW5jdGlvbiAodmFsdWVzLCB0YXJnZXQsIHN0ZXApIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsYXN0ID0gdmFsdWVzLmxlbmd0aCAtIHN0ZXA7IGkgPD0gbGFzdDsgaSArPSBzdGVwKVxuXHRcdFx0XHRpZiAodmFsdWVzW2ldID4gdGFyZ2V0KVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cdFx0cmV0dXJuIEFuaW1hdGlvbjtcblx0fSgpKTtcblx0c3BpbmUuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuXHQoZnVuY3Rpb24gKE1peFBvc2UpIHtcblx0XHRNaXhQb3NlW01peFBvc2VbXCJzZXR1cFwiXSA9IDBdID0gXCJzZXR1cFwiO1xuXHRcdE1peFBvc2VbTWl4UG9zZVtcImN1cnJlbnRcIl0gPSAxXSA9IFwiY3VycmVudFwiO1xuXHRcdE1peFBvc2VbTWl4UG9zZVtcImN1cnJlbnRMYXllcmVkXCJdID0gMl0gPSBcImN1cnJlbnRMYXllcmVkXCI7XG5cdH0pKHNwaW5lLk1peFBvc2UgfHwgKHNwaW5lLk1peFBvc2UgPSB7fSkpO1xuXHR2YXIgTWl4UG9zZSA9IHNwaW5lLk1peFBvc2U7XG5cdChmdW5jdGlvbiAoTWl4RGlyZWN0aW9uKSB7XG5cdFx0TWl4RGlyZWN0aW9uW01peERpcmVjdGlvbltcImluXCJdID0gMF0gPSBcImluXCI7XG5cdFx0TWl4RGlyZWN0aW9uW01peERpcmVjdGlvbltcIm91dFwiXSA9IDFdID0gXCJvdXRcIjtcblx0fSkoc3BpbmUuTWl4RGlyZWN0aW9uIHx8IChzcGluZS5NaXhEaXJlY3Rpb24gPSB7fSkpO1xuXHR2YXIgTWl4RGlyZWN0aW9uID0gc3BpbmUuTWl4RGlyZWN0aW9uO1xuXHQoZnVuY3Rpb24gKFRpbWVsaW5lVHlwZSkge1xuXHRcdFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJyb3RhdGVcIl0gPSAwXSA9IFwicm90YXRlXCI7XG5cdFx0VGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcInRyYW5zbGF0ZVwiXSA9IDFdID0gXCJ0cmFuc2xhdGVcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wic2NhbGVcIl0gPSAyXSA9IFwic2NhbGVcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wic2hlYXJcIl0gPSAzXSA9IFwic2hlYXJcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiYXR0YWNobWVudFwiXSA9IDRdID0gXCJhdHRhY2htZW50XCI7XG5cdFx0VGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImNvbG9yXCJdID0gNV0gPSBcImNvbG9yXCI7XG5cdFx0VGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImRlZm9ybVwiXSA9IDZdID0gXCJkZWZvcm1cIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiZXZlbnRcIl0gPSA3XSA9IFwiZXZlbnRcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiZHJhd09yZGVyXCJdID0gOF0gPSBcImRyYXdPcmRlclwiO1xuXHRcdFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJpa0NvbnN0cmFpbnRcIl0gPSA5XSA9IFwiaWtDb25zdHJhaW50XCI7XG5cdFx0VGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcInRyYW5zZm9ybUNvbnN0cmFpbnRcIl0gPSAxMF0gPSBcInRyYW5zZm9ybUNvbnN0cmFpbnRcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wicGF0aENvbnN0cmFpbnRQb3NpdGlvblwiXSA9IDExXSA9IFwicGF0aENvbnN0cmFpbnRQb3NpdGlvblwiO1xuXHRcdFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJwYXRoQ29uc3RyYWludFNwYWNpbmdcIl0gPSAxMl0gPSBcInBhdGhDb25zdHJhaW50U3BhY2luZ1wiO1xuXHRcdFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJwYXRoQ29uc3RyYWludE1peFwiXSA9IDEzXSA9IFwicGF0aENvbnN0cmFpbnRNaXhcIjtcblx0XHRUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1widHdvQ29sb3JcIl0gPSAxNF0gPSBcInR3b0NvbG9yXCI7XG5cdH0pKHNwaW5lLlRpbWVsaW5lVHlwZSB8fCAoc3BpbmUuVGltZWxpbmVUeXBlID0ge30pKTtcblx0dmFyIFRpbWVsaW5lVHlwZSA9IHNwaW5lLlRpbWVsaW5lVHlwZTtcblx0dmFyIEN1cnZlVGltZWxpbmUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEN1cnZlVGltZWxpbmUoZnJhbWVDb3VudCkge1xuXHRcdFx0aWYgKGZyYW1lQ291bnQgPD0gMClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZnJhbWVDb3VudCBtdXN0IGJlID4gMDogXCIgKyBmcmFtZUNvdW50KTtcblx0XHRcdHRoaXMuY3VydmVzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheSgoZnJhbWVDb3VudCAtIDEpICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSk7XG5cdFx0fVxuXHRcdEN1cnZlVGltZWxpbmUucHJvdG90eXBlLmdldEZyYW1lQ291bnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJ2ZXMubGVuZ3RoIC8gQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSArIDE7XG5cdFx0fTtcblx0XHRDdXJ2ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRMaW5lYXIgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCkge1xuXHRcdFx0dGhpcy5jdXJ2ZXNbZnJhbWVJbmRleCAqIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkVdID0gQ3VydmVUaW1lbGluZS5MSU5FQVI7XG5cdFx0fTtcblx0XHRDdXJ2ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRTdGVwcGVkID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcblx0XHRcdHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFXSA9IEN1cnZlVGltZWxpbmUuU1RFUFBFRDtcblx0XHR9O1xuXHRcdEN1cnZlVGltZWxpbmUucHJvdG90eXBlLmdldEN1cnZlVHlwZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XG5cdFx0XHR2YXIgaW5kZXggPSBmcmFtZUluZGV4ICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRTtcblx0XHRcdGlmIChpbmRleCA9PSB0aGlzLmN1cnZlcy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBDdXJ2ZVRpbWVsaW5lLkxJTkVBUjtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5jdXJ2ZXNbaW5kZXhdO1xuXHRcdFx0aWYgKHR5cGUgPT0gQ3VydmVUaW1lbGluZS5MSU5FQVIpXG5cdFx0XHRcdHJldHVybiBDdXJ2ZVRpbWVsaW5lLkxJTkVBUjtcblx0XHRcdGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuU1RFUFBFRClcblx0XHRcdFx0cmV0dXJuIEN1cnZlVGltZWxpbmUuU1RFUFBFRDtcblx0XHRcdHJldHVybiBDdXJ2ZVRpbWVsaW5lLkJFWklFUjtcblx0XHR9O1xuXHRcdEN1cnZlVGltZWxpbmUucHJvdG90eXBlLnNldEN1cnZlID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIGN4MSwgY3kxLCBjeDIsIGN5Mikge1xuXHRcdFx0dmFyIHRtcHggPSAoLWN4MSAqIDIgKyBjeDIpICogMC4wMywgdG1weSA9ICgtY3kxICogMiArIGN5MikgKiAwLjAzO1xuXHRcdFx0dmFyIGRkZGZ4ID0gKChjeDEgLSBjeDIpICogMyArIDEpICogMC4wMDYsIGRkZGZ5ID0gKChjeTEgLSBjeTIpICogMyArIDEpICogMC4wMDY7XG5cdFx0XHR2YXIgZGRmeCA9IHRtcHggKiAyICsgZGRkZngsIGRkZnkgPSB0bXB5ICogMiArIGRkZGZ5O1xuXHRcdFx0dmFyIGRmeCA9IGN4MSAqIDAuMyArIHRtcHggKyBkZGRmeCAqIDAuMTY2NjY2NjcsIGRmeSA9IGN5MSAqIDAuMyArIHRtcHkgKyBkZGRmeSAqIDAuMTY2NjY2Njc7XG5cdFx0XHR2YXIgaSA9IGZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuY3VydmVzO1xuXHRcdFx0Y3VydmVzW2krK10gPSBDdXJ2ZVRpbWVsaW5lLkJFWklFUjtcblx0XHRcdHZhciB4ID0gZGZ4LCB5ID0gZGZ5O1xuXHRcdFx0Zm9yICh2YXIgbiA9IGkgKyBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFIC0gMTsgaSA8IG47IGkgKz0gMikge1xuXHRcdFx0XHRjdXJ2ZXNbaV0gPSB4O1xuXHRcdFx0XHRjdXJ2ZXNbaSArIDFdID0geTtcblx0XHRcdFx0ZGZ4ICs9IGRkZng7XG5cdFx0XHRcdGRmeSArPSBkZGZ5O1xuXHRcdFx0XHRkZGZ4ICs9IGRkZGZ4O1xuXHRcdFx0XHRkZGZ5ICs9IGRkZGZ5O1xuXHRcdFx0XHR4ICs9IGRmeDtcblx0XHRcdFx0eSArPSBkZnk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRDdXJ2ZVRpbWVsaW5lLnByb3RvdHlwZS5nZXRDdXJ2ZVBlcmNlbnQgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgcGVyY2VudCkge1xuXHRcdFx0cGVyY2VudCA9IHNwaW5lLk1hdGhVdGlscy5jbGFtcChwZXJjZW50LCAwLCAxKTtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmN1cnZlcztcblx0XHRcdHZhciBpID0gZnJhbWVJbmRleCAqIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkU7XG5cdFx0XHR2YXIgdHlwZSA9IGN1cnZlc1tpXTtcblx0XHRcdGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuTElORUFSKVxuXHRcdFx0XHRyZXR1cm4gcGVyY2VudDtcblx0XHRcdGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuU1RFUFBFRClcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRpKys7XG5cdFx0XHR2YXIgeCA9IDA7XG5cdFx0XHRmb3IgKHZhciBzdGFydCA9IGksIG4gPSBpICsgQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSAtIDE7IGkgPCBuOyBpICs9IDIpIHtcblx0XHRcdFx0eCA9IGN1cnZlc1tpXTtcblx0XHRcdFx0aWYgKHggPj0gcGVyY2VudCkge1xuXHRcdFx0XHRcdHZhciBwcmV2WCA9IHZvaWQgMCwgcHJldlkgPSB2b2lkIDA7XG5cdFx0XHRcdFx0aWYgKGkgPT0gc3RhcnQpIHtcblx0XHRcdFx0XHRcdHByZXZYID0gMDtcblx0XHRcdFx0XHRcdHByZXZZID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwcmV2WCA9IGN1cnZlc1tpIC0gMl07XG5cdFx0XHRcdFx0XHRwcmV2WSA9IGN1cnZlc1tpIC0gMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwcmV2WSArIChjdXJ2ZXNbaSArIDFdIC0gcHJldlkpICogKHBlcmNlbnQgLSBwcmV2WCkgLyAoeCAtIHByZXZYKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHkgPSBjdXJ2ZXNbaSAtIDFdO1xuXHRcdFx0cmV0dXJuIHkgKyAoMSAtIHkpICogKHBlcmNlbnQgLSB4KSAvICgxIC0geCk7XG5cdFx0fTtcblx0XHRDdXJ2ZVRpbWVsaW5lLkxJTkVBUiA9IDA7XG5cdFx0Q3VydmVUaW1lbGluZS5TVEVQUEVEID0gMTtcblx0XHRDdXJ2ZVRpbWVsaW5lLkJFWklFUiA9IDI7XG5cdFx0Q3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSA9IDEwICogMiAtIDE7XG5cdFx0cmV0dXJuIEN1cnZlVGltZWxpbmU7XG5cdH0oKSk7XG5cdHNwaW5lLkN1cnZlVGltZWxpbmUgPSBDdXJ2ZVRpbWVsaW5lO1xuXHR2YXIgUm90YXRlVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhSb3RhdGVUaW1lbGluZSwgX3N1cGVyKTtcblx0XHRmdW5jdGlvbiBSb3RhdGVUaW1lbGluZShmcmFtZUNvdW50KSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KTtcblx0XHRcdHRoaXMuZnJhbWVzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50IDw8IDEpO1xuXHRcdH1cblx0XHRSb3RhdGVUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnJvdGF0ZSA8PCAyNCkgKyB0aGlzLmJvbmVJbmRleDtcblx0XHR9O1xuXHRcdFJvdGF0ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBkZWdyZWVzKSB7XG5cdFx0XHRmcmFtZUluZGV4IDw8PSAxO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFJvdGF0ZVRpbWVsaW5lLlJPVEFUSU9OXSA9IGRlZ3JlZXM7XG5cdFx0fTtcblx0XHRSb3RhdGVUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0Ym9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbjtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2UuY3VycmVudDpcblx0XHRcdFx0XHRcdHZhciByXzEgPSBib25lLmRhdGEucm90YXRpb24gLSBib25lLnJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0cl8xIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gcl8xIC8gMzYwKSB8IDApKSAqIDM2MDtcblx0XHRcdFx0XHRcdGJvbmUucm90YXRpb24gKz0gcl8xICogYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBSb3RhdGVUaW1lbGluZS5FTlRSSUVTXSkge1xuXHRcdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKVxuXHRcdFx0XHRcdGJvbmUucm90YXRpb24gPSBib25lLmRhdGEucm90YXRpb24gKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dICogYWxwaGE7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciByXzIgPSBib25lLmRhdGEucm90YXRpb24gKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dIC0gYm9uZS5yb3RhdGlvbjtcblx0XHRcdFx0XHRyXzIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByXzIgLyAzNjApIHwgMCkpICogMzYwO1xuXHRcdFx0XHRcdGJvbmUucm90YXRpb24gKz0gcl8yICogYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFJvdGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdFx0dmFyIHByZXZSb3RhdGlvbiA9IGZyYW1lc1tmcmFtZSArIFJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dO1xuXHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHR2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KChmcmFtZSA+PiAxKSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgUm90YXRlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xuXHRcdFx0dmFyIHIgPSBmcmFtZXNbZnJhbWUgKyBSb3RhdGVUaW1lbGluZS5ST1RBVElPTl0gLSBwcmV2Um90YXRpb247XG5cdFx0XHRyIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gciAvIDM2MCkgfCAwKSkgKiAzNjA7XG5cdFx0XHRyID0gcHJldlJvdGF0aW9uICsgciAqIHBlcmNlbnQ7XG5cdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKSB7XG5cdFx0XHRcdHIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MDtcblx0XHRcdFx0Ym9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIHIgKiBhbHBoYTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgciAtIGJvbmUucm90YXRpb247XG5cdFx0XHRcdHIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MDtcblx0XHRcdFx0Ym9uZS5yb3RhdGlvbiArPSByICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRSb3RhdGVUaW1lbGluZS5FTlRSSUVTID0gMjtcblx0XHRSb3RhdGVUaW1lbGluZS5QUkVWX1RJTUUgPSAtMjtcblx0XHRSb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OID0gLTE7XG5cdFx0Um90YXRlVGltZWxpbmUuUk9UQVRJT04gPSAxO1xuXHRcdHJldHVybiBSb3RhdGVUaW1lbGluZTtcblx0fShDdXJ2ZVRpbWVsaW5lKSk7XG5cdHNwaW5lLlJvdGF0ZVRpbWVsaW5lID0gUm90YXRlVGltZWxpbmU7XG5cdHZhciBUcmFuc2xhdGVUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFRyYW5zbGF0ZVRpbWVsaW5lLCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIFRyYW5zbGF0ZVRpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpO1xuXHRcdFx0dGhpcy5mcmFtZXMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTKTtcblx0XHR9XG5cdFx0VHJhbnNsYXRlVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gKFRpbWVsaW5lVHlwZS50cmFuc2xhdGUgPDwgMjQpICsgdGhpcy5ib25lSW5kZXg7XG5cdFx0fTtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgeCwgeSkge1xuXHRcdFx0ZnJhbWVJbmRleCAqPSBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFRyYW5zbGF0ZVRpbWVsaW5lLlhdID0geDtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2xhdGVUaW1lbGluZS5ZXSA9IHk7XG5cdFx0fTtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0Ym9uZS54ID0gYm9uZS5kYXRhLng7XG5cdFx0XHRcdFx0XHRib25lLnkgPSBib25lLmRhdGEueTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2UuY3VycmVudDpcblx0XHRcdFx0XHRcdGJvbmUueCArPSAoYm9uZS5kYXRhLnggLSBib25lLngpICogYWxwaGE7XG5cdFx0XHRcdFx0XHRib25lLnkgKz0gKGJvbmUuZGF0YS55IC0gYm9uZS55KSAqIGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gMCwgeSA9IDA7XG5cdFx0XHRpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVNdKSB7XG5cdFx0XHRcdHggPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWF07XG5cdFx0XHRcdHkgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdFx0XHR4ID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNsYXRlVGltZWxpbmUuUFJFVl9YXTtcblx0XHRcdFx0eSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWV07XG5cdFx0XHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xuXHRcdFx0XHR2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgVHJhbnNsYXRlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xuXHRcdFx0XHR4ICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5YXSAtIHgpICogcGVyY2VudDtcblx0XHRcdFx0eSArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNsYXRlVGltZWxpbmUuWV0gLSB5KSAqIHBlcmNlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKSB7XG5cdFx0XHRcdGJvbmUueCA9IGJvbmUuZGF0YS54ICsgeCAqIGFscGhhO1xuXHRcdFx0XHRib25lLnkgPSBib25lLmRhdGEueSArIHkgKiBhbHBoYTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRib25lLnggKz0gKGJvbmUuZGF0YS54ICsgeCAtIGJvbmUueCkgKiBhbHBoYTtcblx0XHRcdFx0Ym9uZS55ICs9IChib25lLmRhdGEueSArIHkgLSBib25lLnkpICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTID0gMztcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1RJTUUgPSAtMztcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1ggPSAtMjtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1kgPSAtMTtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5YID0gMTtcblx0XHRUcmFuc2xhdGVUaW1lbGluZS5ZID0gMjtcblx0XHRyZXR1cm4gVHJhbnNsYXRlVGltZWxpbmU7XG5cdH0oQ3VydmVUaW1lbGluZSkpO1xuXHRzcGluZS5UcmFuc2xhdGVUaW1lbGluZSA9IFRyYW5zbGF0ZVRpbWVsaW5lO1xuXHR2YXIgU2NhbGVUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFNjYWxlVGltZWxpbmUsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gU2NhbGVUaW1lbGluZShmcmFtZUNvdW50KSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KTtcblx0XHR9XG5cdFx0U2NhbGVUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnNjYWxlIDw8IDI0KSArIHRoaXMuYm9uZUluZGV4O1xuXHRcdH07XG5cdFx0U2NhbGVUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0Ym9uZS5zY2FsZVggPSBib25lLmRhdGEuc2NhbGVYO1xuXHRcdFx0XHRcdFx0Ym9uZS5zY2FsZVkgPSBib25lLmRhdGEuc2NhbGVZO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5jdXJyZW50OlxuXHRcdFx0XHRcdFx0Ym9uZS5zY2FsZVggKz0gKGJvbmUuZGF0YS5zY2FsZVggLSBib25lLnNjYWxlWCkgKiBhbHBoYTtcblx0XHRcdFx0XHRcdGJvbmUuc2NhbGVZICs9IChib25lLmRhdGEuc2NhbGVZIC0gYm9uZS5zY2FsZVkpICogYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSAwLCB5ID0gMDtcblx0XHRcdGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gU2NhbGVUaW1lbGluZS5FTlRSSUVTXSkge1xuXHRcdFx0XHR4ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTY2FsZVRpbWVsaW5lLlBSRVZfWF0gKiBib25lLmRhdGEuc2NhbGVYO1xuXHRcdFx0XHR5ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTY2FsZVRpbWVsaW5lLlBSRVZfWV0gKiBib25lLmRhdGEuc2NhbGVZO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBTY2FsZVRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdFx0XHR4ID0gZnJhbWVzW2ZyYW1lICsgU2NhbGVUaW1lbGluZS5QUkVWX1hdO1xuXHRcdFx0XHR5ID0gZnJhbWVzW2ZyYW1lICsgU2NhbGVUaW1lbGluZS5QUkVWX1ldO1xuXHRcdFx0XHR2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcblx0XHRcdFx0dmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFNjYWxlVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgU2NhbGVUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRcdHggPSAoeCArIChmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlhdIC0geCkgKiBwZXJjZW50KSAqIGJvbmUuZGF0YS5zY2FsZVg7XG5cdFx0XHRcdHkgPSAoeSArIChmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlldIC0geSkgKiBwZXJjZW50KSAqIGJvbmUuZGF0YS5zY2FsZVk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxwaGEgPT0gMSkge1xuXHRcdFx0XHRib25lLnNjYWxlWCA9IHg7XG5cdFx0XHRcdGJvbmUuc2NhbGVZID0geTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYnggPSAwLCBieSA9IDA7XG5cdFx0XHRcdGlmIChwb3NlID09IE1peFBvc2Uuc2V0dXApIHtcblx0XHRcdFx0XHRieCA9IGJvbmUuZGF0YS5zY2FsZVg7XG5cdFx0XHRcdFx0YnkgPSBib25lLmRhdGEuc2NhbGVZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGJ4ID0gYm9uZS5zY2FsZVg7XG5cdFx0XHRcdFx0YnkgPSBib25lLnNjYWxlWTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5vdXQpIHtcblx0XHRcdFx0XHR4ID0gTWF0aC5hYnMoeCkgKiBzcGluZS5NYXRoVXRpbHMuc2lnbnVtKGJ4KTtcblx0XHRcdFx0XHR5ID0gTWF0aC5hYnMoeSkgKiBzcGluZS5NYXRoVXRpbHMuc2lnbnVtKGJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRieCA9IE1hdGguYWJzKGJ4KSAqIHNwaW5lLk1hdGhVdGlscy5zaWdudW0oeCk7XG5cdFx0XHRcdFx0YnkgPSBNYXRoLmFicyhieSkgKiBzcGluZS5NYXRoVXRpbHMuc2lnbnVtKHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJvbmUuc2NhbGVYID0gYnggKyAoeCAtIGJ4KSAqIGFscGhhO1xuXHRcdFx0XHRib25lLnNjYWxlWSA9IGJ5ICsgKHkgLSBieSkgKiBhbHBoYTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBTY2FsZVRpbWVsaW5lO1xuXHR9KFRyYW5zbGF0ZVRpbWVsaW5lKSk7XG5cdHNwaW5lLlNjYWxlVGltZWxpbmUgPSBTY2FsZVRpbWVsaW5lO1xuXHR2YXIgU2hlYXJUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFNoZWFyVGltZWxpbmUsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gU2hlYXJUaW1lbGluZShmcmFtZUNvdW50KSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KTtcblx0XHR9XG5cdFx0U2hlYXJUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnNoZWFyIDw8IDI0KSArIHRoaXMuYm9uZUluZGV4O1xuXHRcdH07XG5cdFx0U2hlYXJUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0Ym9uZS5zaGVhclggPSBib25lLmRhdGEuc2hlYXJYO1xuXHRcdFx0XHRcdFx0Ym9uZS5zaGVhclkgPSBib25lLmRhdGEuc2hlYXJZO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5jdXJyZW50OlxuXHRcdFx0XHRcdFx0Ym9uZS5zaGVhclggKz0gKGJvbmUuZGF0YS5zaGVhclggLSBib25lLnNoZWFyWCkgKiBhbHBoYTtcblx0XHRcdFx0XHRcdGJvbmUuc2hlYXJZICs9IChib25lLmRhdGEuc2hlYXJZIC0gYm9uZS5zaGVhclkpICogYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSAwLCB5ID0gMDtcblx0XHRcdGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gU2hlYXJUaW1lbGluZS5FTlRSSUVTXSkge1xuXHRcdFx0XHR4ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTaGVhclRpbWVsaW5lLlBSRVZfWF07XG5cdFx0XHRcdHkgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFNoZWFyVGltZWxpbmUuUFJFVl9ZXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgU2hlYXJUaW1lbGluZS5FTlRSSUVTKTtcblx0XHRcdFx0eCA9IGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuUFJFVl9YXTtcblx0XHRcdFx0eSA9IGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuUFJFVl9ZXTtcblx0XHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBTaGVhclRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xuXHRcdFx0XHR4ID0geCArIChmcmFtZXNbZnJhbWUgKyBTaGVhclRpbWVsaW5lLlhdIC0geCkgKiBwZXJjZW50O1xuXHRcdFx0XHR5ID0geSArIChmcmFtZXNbZnJhbWUgKyBTaGVhclRpbWVsaW5lLlldIC0geSkgKiBwZXJjZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHRib25lLnNoZWFyWCA9IGJvbmUuZGF0YS5zaGVhclggKyB4ICogYWxwaGE7XG5cdFx0XHRcdGJvbmUuc2hlYXJZID0gYm9uZS5kYXRhLnNoZWFyWSArIHkgKiBhbHBoYTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRib25lLnNoZWFyWCArPSAoYm9uZS5kYXRhLnNoZWFyWCArIHggLSBib25lLnNoZWFyWCkgKiBhbHBoYTtcblx0XHRcdFx0Ym9uZS5zaGVhclkgKz0gKGJvbmUuZGF0YS5zaGVhclkgKyB5IC0gYm9uZS5zaGVhclkpICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gU2hlYXJUaW1lbGluZTtcblx0fShUcmFuc2xhdGVUaW1lbGluZSkpO1xuXHRzcGluZS5TaGVhclRpbWVsaW5lID0gU2hlYXJUaW1lbGluZTtcblx0dmFyIENvbG9yVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhDb2xvclRpbWVsaW5lLCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIENvbG9yVGltZWxpbmUoZnJhbWVDb3VudCkge1xuXHRcdFx0X3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCk7XG5cdFx0XHR0aGlzLmZyYW1lcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIENvbG9yVGltZWxpbmUuRU5UUklFUyk7XG5cdFx0fVxuXHRcdENvbG9yVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gKFRpbWVsaW5lVHlwZS5jb2xvciA8PCAyNCkgKyB0aGlzLnNsb3RJbmRleDtcblx0XHR9O1xuXHRcdENvbG9yVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHIsIGcsIGIsIGEpIHtcblx0XHRcdGZyYW1lSW5kZXggKj0gQ29sb3JUaW1lbGluZS5FTlRSSUVTO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuUl0gPSByO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuR10gPSBnO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuQl0gPSBiO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuQV0gPSBhO1xuXHRcdH07XG5cdFx0Q29sb3JUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdO1xuXHRcdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0c2xvdC5jb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmNvbG9yKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2UuY3VycmVudDpcblx0XHRcdFx0XHRcdHZhciBjb2xvciA9IHNsb3QuY29sb3IsIHNldHVwID0gc2xvdC5kYXRhLmNvbG9yO1xuXHRcdFx0XHRcdFx0Y29sb3IuYWRkKChzZXR1cC5yIC0gY29sb3IucikgKiBhbHBoYSwgKHNldHVwLmcgLSBjb2xvci5nKSAqIGFscGhhLCAoc2V0dXAuYiAtIGNvbG9yLmIpICogYWxwaGEsIChzZXR1cC5hIC0gY29sb3IuYSkgKiBhbHBoYSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBDb2xvclRpbWVsaW5lLkVOVFJJRVNdKSB7XG5cdFx0XHRcdHZhciBpID0gZnJhbWVzLmxlbmd0aDtcblx0XHRcdFx0ciA9IGZyYW1lc1tpICsgQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xuXHRcdFx0XHRnID0gZnJhbWVzW2kgKyBDb2xvclRpbWVsaW5lLlBSRVZfR107XG5cdFx0XHRcdGIgPSBmcmFtZXNbaSArIENvbG9yVGltZWxpbmUuUFJFVl9CXTtcblx0XHRcdFx0YSA9IGZyYW1lc1tpICsgQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBDb2xvclRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdFx0XHRyID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xuXHRcdFx0XHRnID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xuXHRcdFx0XHRiID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX0JdO1xuXHRcdFx0XHRhID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xuXHRcdFx0XHR2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcblx0XHRcdFx0dmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIENvbG9yVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRcdHIgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUl0gLSByKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGcgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuR10gLSBnKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGIgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuQl0gLSBiKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGEgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuQV0gLSBhKSAqIHBlcmNlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxwaGEgPT0gMSlcblx0XHRcdFx0c2xvdC5jb2xvci5zZXQociwgZywgYiwgYSk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGNvbG9yID0gc2xvdC5jb2xvcjtcblx0XHRcdFx0aWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cClcblx0XHRcdFx0XHRjb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmNvbG9yKTtcblx0XHRcdFx0Y29sb3IuYWRkKChyIC0gY29sb3IucikgKiBhbHBoYSwgKGcgLSBjb2xvci5nKSAqIGFscGhhLCAoYiAtIGNvbG9yLmIpICogYWxwaGEsIChhIC0gY29sb3IuYSkgKiBhbHBoYSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRDb2xvclRpbWVsaW5lLkVOVFJJRVMgPSA1O1xuXHRcdENvbG9yVGltZWxpbmUuUFJFVl9USU1FID0gLTU7XG5cdFx0Q29sb3JUaW1lbGluZS5QUkVWX1IgPSAtNDtcblx0XHRDb2xvclRpbWVsaW5lLlBSRVZfRyA9IC0zO1xuXHRcdENvbG9yVGltZWxpbmUuUFJFVl9CID0gLTI7XG5cdFx0Q29sb3JUaW1lbGluZS5QUkVWX0EgPSAtMTtcblx0XHRDb2xvclRpbWVsaW5lLlIgPSAxO1xuXHRcdENvbG9yVGltZWxpbmUuRyA9IDI7XG5cdFx0Q29sb3JUaW1lbGluZS5CID0gMztcblx0XHRDb2xvclRpbWVsaW5lLkEgPSA0O1xuXHRcdHJldHVybiBDb2xvclRpbWVsaW5lO1xuXHR9KEN1cnZlVGltZWxpbmUpKTtcblx0c3BpbmUuQ29sb3JUaW1lbGluZSA9IENvbG9yVGltZWxpbmU7XG5cdHZhciBUd29Db2xvclRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoVHdvQ29sb3JUaW1lbGluZSwgX3N1cGVyKTtcblx0XHRmdW5jdGlvbiBUd29Db2xvclRpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpO1xuXHRcdFx0dGhpcy5mcmFtZXMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdH1cblx0XHRUd29Db2xvclRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIChUaW1lbGluZVR5cGUudHdvQ29sb3IgPDwgMjQpICsgdGhpcy5zbG90SW5kZXg7XG5cdFx0fTtcblx0XHRUd29Db2xvclRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByLCBnLCBiLCBhLCByMiwgZzIsIGIyKSB7XG5cdFx0XHRmcmFtZUluZGV4ICo9IFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLlJdID0gcjtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkddID0gZztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkJdID0gYjtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkFdID0gYTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLlIyXSA9IHIyO1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFR3b0NvbG9yVGltZWxpbmUuRzJdID0gZzI7XG5cdFx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5CMl0gPSBiMjtcblx0XHR9O1xuXHRcdFR3b0NvbG9yVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgcG9zZSwgZGlyZWN0aW9uKSB7XG5cdFx0XHR2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdHN3aXRjaCAocG9zZSkge1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5zZXR1cDpcblx0XHRcdFx0XHRcdHNsb3QuY29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5jb2xvcik7XG5cdFx0XHRcdFx0XHRzbG90LmRhcmtDb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmRhcmtDb2xvcik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLmN1cnJlbnQ6XG5cdFx0XHRcdFx0XHR2YXIgbGlnaHQgPSBzbG90LmNvbG9yLCBkYXJrID0gc2xvdC5kYXJrQ29sb3IsIHNldHVwTGlnaHQgPSBzbG90LmRhdGEuY29sb3IsIHNldHVwRGFyayA9IHNsb3QuZGF0YS5kYXJrQ29sb3I7XG5cdFx0XHRcdFx0XHRsaWdodC5hZGQoKHNldHVwTGlnaHQuciAtIGxpZ2h0LnIpICogYWxwaGEsIChzZXR1cExpZ2h0LmcgLSBsaWdodC5nKSAqIGFscGhhLCAoc2V0dXBMaWdodC5iIC0gbGlnaHQuYikgKiBhbHBoYSwgKHNldHVwTGlnaHQuYSAtIGxpZ2h0LmEpICogYWxwaGEpO1xuXHRcdFx0XHRcdFx0ZGFyay5hZGQoKHNldHVwRGFyay5yIC0gZGFyay5yKSAqIGFscGhhLCAoc2V0dXBEYXJrLmcgLSBkYXJrLmcpICogYWxwaGEsIChzZXR1cERhcmsuYiAtIGRhcmsuYikgKiBhbHBoYSwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwLCByMiA9IDAsIGcyID0gMCwgYjIgPSAwO1xuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVNdKSB7XG5cdFx0XHRcdHZhciBpID0gZnJhbWVzLmxlbmd0aDtcblx0XHRcdFx0ciA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xuXHRcdFx0XHRnID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfR107XG5cdFx0XHRcdGIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CXTtcblx0XHRcdFx0YSA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xuXHRcdFx0XHRyMiA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1IyXTtcblx0XHRcdFx0ZzIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HMl07XG5cdFx0XHRcdGIyID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQjJdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVMpO1xuXHRcdFx0XHRyID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xuXHRcdFx0XHRnID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xuXHRcdFx0XHRiID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0JdO1xuXHRcdFx0XHRhID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xuXHRcdFx0XHRyMiA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SMl07XG5cdFx0XHRcdGcyID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0cyXTtcblx0XHRcdFx0YjIgPSBmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQjJdO1xuXHRcdFx0XHR2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcblx0XHRcdFx0dmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRcdHIgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUl0gLSByKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGcgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuR10gLSBnKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGIgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuQl0gLSBiKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGEgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuQV0gLSBhKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdHIyICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlIyXSAtIHIyKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGcyICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLkcyXSAtIGcyKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdGIyICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLkIyXSAtIGIyKSAqIHBlcmNlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxwaGEgPT0gMSkge1xuXHRcdFx0XHRzbG90LmNvbG9yLnNldChyLCBnLCBiLCBhKTtcblx0XHRcdFx0c2xvdC5kYXJrQ29sb3Iuc2V0KHIyLCBnMiwgYjIsIDEpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBsaWdodCA9IHNsb3QuY29sb3IsIGRhcmsgPSBzbG90LmRhcmtDb2xvcjtcblx0XHRcdFx0aWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHRcdGxpZ2h0LnNldEZyb21Db2xvcihzbG90LmRhdGEuY29sb3IpO1xuXHRcdFx0XHRcdGRhcmsuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5kYXJrQ29sb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpZ2h0LmFkZCgociAtIGxpZ2h0LnIpICogYWxwaGEsIChnIC0gbGlnaHQuZykgKiBhbHBoYSwgKGIgLSBsaWdodC5iKSAqIGFscGhhLCAoYSAtIGxpZ2h0LmEpICogYWxwaGEpO1xuXHRcdFx0XHRkYXJrLmFkZCgocjIgLSBkYXJrLnIpICogYWxwaGEsIChnMiAtIGRhcmsuZykgKiBhbHBoYSwgKGIyIC0gZGFyay5iKSAqIGFscGhhLCAwKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUyA9IDg7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5QUkVWX1RJTUUgPSAtODtcblx0XHRUd29Db2xvclRpbWVsaW5lLlBSRVZfUiA9IC03O1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HID0gLTY7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5QUkVWX0IgPSAtNTtcblx0XHRUd29Db2xvclRpbWVsaW5lLlBSRVZfQSA9IC00O1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SMiA9IC0zO1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HMiA9IC0yO1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CMiA9IC0xO1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuUiA9IDE7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5HID0gMjtcblx0XHRUd29Db2xvclRpbWVsaW5lLkIgPSAzO1xuXHRcdFR3b0NvbG9yVGltZWxpbmUuQSA9IDQ7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5SMiA9IDU7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5HMiA9IDY7XG5cdFx0VHdvQ29sb3JUaW1lbGluZS5CMiA9IDc7XG5cdFx0cmV0dXJuIFR3b0NvbG9yVGltZWxpbmU7XG5cdH0oQ3VydmVUaW1lbGluZSkpO1xuXHRzcGluZS5Ud29Db2xvclRpbWVsaW5lID0gVHdvQ29sb3JUaW1lbGluZTtcblx0dmFyIEF0dGFjaG1lbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gQXR0YWNobWVudFRpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdHRoaXMuZnJhbWVzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50KTtcblx0XHRcdHRoaXMuYXR0YWNobWVudE5hbWVzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuXHRcdH1cblx0XHRBdHRhY2htZW50VGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gKFRpbWVsaW5lVHlwZS5hdHRhY2htZW50IDw8IDI0KSArIHRoaXMuc2xvdEluZGV4O1xuXHRcdH07XG5cdFx0QXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5nZXRGcmFtZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcblx0XHR9O1xuXHRcdEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgYXR0YWNobWVudE5hbWUpIHtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdID0gYXR0YWNobWVudE5hbWU7XG5cdFx0fTtcblx0XHRBdHRhY2htZW50VGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgcG9zZSwgZGlyZWN0aW9uKSB7XG5cdFx0XHR2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcblx0XHRcdGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm91dCAmJiBwb3NlID09IE1peFBvc2Uuc2V0dXApIHtcblx0XHRcdFx0dmFyIGF0dGFjaG1lbnROYW1lXzEgPSBzbG90LmRhdGEuYXR0YWNobWVudE5hbWU7XG5cdFx0XHRcdHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50TmFtZV8xID09IG51bGwgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWVfMSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0XHRpZiAodGltZSA8IGZyYW1lc1swXSkge1xuXHRcdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKSB7XG5cdFx0XHRcdFx0dmFyIGF0dGFjaG1lbnROYW1lXzIgPSBzbG90LmRhdGEuYXR0YWNobWVudE5hbWU7XG5cdFx0XHRcdFx0c2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnROYW1lXzIgPT0gbnVsbCA/IG51bGwgOiBza2VsZXRvbi5nZXRBdHRhY2htZW50KHRoaXMuc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZV8yKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSlcblx0XHRcdFx0ZnJhbWVJbmRleCA9IGZyYW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmcmFtZUluZGV4ID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDEpIC0gMTtcblx0XHRcdHZhciBhdHRhY2htZW50TmFtZSA9IHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdO1xuXHRcdFx0c2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdXG5cdFx0XHRcdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnROYW1lID09IG51bGwgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpKTtcblx0XHR9O1xuXHRcdHJldHVybiBBdHRhY2htZW50VGltZWxpbmU7XG5cdH0oKSk7XG5cdHNwaW5lLkF0dGFjaG1lbnRUaW1lbGluZSA9IEF0dGFjaG1lbnRUaW1lbGluZTtcblx0dmFyIERlZm9ybVRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoRGVmb3JtVGltZWxpbmUsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gRGVmb3JtVGltZWxpbmUoZnJhbWVDb3VudCkge1xuXHRcdFx0X3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCk7XG5cdFx0XHR0aGlzLmZyYW1lcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCk7XG5cdFx0XHR0aGlzLmZyYW1lVmVydGljZXMgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XG5cdFx0fVxuXHRcdERlZm9ybVRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIChUaW1lbGluZVR5cGUuZGVmb3JtIDw8IDI3KSArICt0aGlzLmF0dGFjaG1lbnQuaWQgKyB0aGlzLnNsb3RJbmRleDtcblx0XHR9O1xuXHRcdERlZm9ybVRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB2ZXJ0aWNlcykge1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdFx0dGhpcy5mcmFtZVZlcnRpY2VzW2ZyYW1lSW5kZXhdID0gdmVydGljZXM7XG5cdFx0fTtcblx0XHREZWZvcm1UaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIHBvc2UsIGRpcmVjdGlvbikge1xuXHRcdFx0dmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF07XG5cdFx0XHR2YXIgc2xvdEF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcblx0XHRcdGlmICghKHNsb3RBdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuVmVydGV4QXR0YWNobWVudCkgfHwgIXNsb3RBdHRhY2htZW50LmFwcGx5RGVmb3JtKHRoaXMuYXR0YWNobWVudCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciB2ZXJ0aWNlc0FycmF5ID0gc2xvdC5hdHRhY2htZW50VmVydGljZXM7XG5cdFx0XHR2YXIgZnJhbWVWZXJ0aWNlcyA9IHRoaXMuZnJhbWVWZXJ0aWNlcztcblx0XHRcdHZhciB2ZXJ0ZXhDb3VudCA9IGZyYW1lVmVydGljZXNbMF0ubGVuZ3RoO1xuXHRcdFx0aWYgKHZlcnRpY2VzQXJyYXkubGVuZ3RoICE9IHZlcnRleENvdW50ICYmIHBvc2UgIT0gTWl4UG9zZS5zZXR1cClcblx0XHRcdFx0YWxwaGEgPSAxO1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKHZlcnRpY2VzQXJyYXksIHZlcnRleENvdW50KTtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdHN3aXRjaCAocG9zZSkge1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5zZXR1cDpcblx0XHRcdFx0XHRcdHZlcnRpY2VzQXJyYXkubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2UuY3VycmVudDpcblx0XHRcdFx0XHRcdGFscGhhID0gMSAtIGFscGhhO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlc1tpXSAqPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdKSB7XG5cdFx0XHRcdHZhciBsYXN0VmVydGljZXMgPSBmcmFtZVZlcnRpY2VzW2ZyYW1lcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0aWYgKGFscGhhID09IDEpIHtcblx0XHRcdFx0XHRzcGluZS5VdGlscy5hcnJheUNvcHkobGFzdFZlcnRpY2VzLCAwLCB2ZXJ0aWNlcywgMCwgdmVydGV4Q291bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhBdHRhY2htZW50ID0gc2xvdEF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0aWYgKHZlcnRleEF0dGFjaG1lbnQuYm9uZXMgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBzZXR1cCA9IHNldHVwVmVydGljZXNbaV07XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzW2ldID0gc2V0dXAgKyAobGFzdFZlcnRpY2VzW2ldIC0gc2V0dXApICogYWxwaGE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlc1tpXSA9IGxhc3RWZXJ0aWNlc1tpXSAqIGFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlc1tpXSArPSAobGFzdFZlcnRpY2VzW2ldIC0gdmVydGljZXNbaV0pICogYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUpO1xuXHRcdFx0dmFyIHByZXZWZXJ0aWNlcyA9IGZyYW1lVmVydGljZXNbZnJhbWUgLSAxXTtcblx0XHRcdHZhciBuZXh0VmVydGljZXMgPSBmcmFtZVZlcnRpY2VzW2ZyYW1lXTtcblx0XHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xuXHRcdFx0dmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lIC0gMV0gLSBmcmFtZVRpbWUpKTtcblx0XHRcdGlmIChhbHBoYSA9PSAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2ldO1xuXHRcdFx0XHRcdHZlcnRpY2VzW2ldID0gcHJldiArIChuZXh0VmVydGljZXNbaV0gLSBwcmV2KSAqIHBlcmNlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHR2YXIgdmVydGV4QXR0YWNobWVudCA9IHNsb3RBdHRhY2htZW50O1xuXHRcdFx0XHRpZiAodmVydGV4QXR0YWNobWVudC5ib25lcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV0sIHNldHVwID0gc2V0dXBWZXJ0aWNlc1tpXTtcblx0XHRcdFx0XHRcdHZlcnRpY2VzW2ldID0gc2V0dXAgKyAocHJldiArIChuZXh0VmVydGljZXNbaV0gLSBwcmV2KSAqIHBlcmNlbnQgLSBzZXR1cCkgKiBhbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXTtcblx0XHRcdFx0XHRcdHZlcnRpY2VzW2ldID0gKHByZXYgKyAobmV4dFZlcnRpY2VzW2ldIC0gcHJldikgKiBwZXJjZW50KSAqIGFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2ldO1xuXHRcdFx0XHRcdHZlcnRpY2VzW2ldICs9IChwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXSAtIHByZXYpICogcGVyY2VudCAtIHZlcnRpY2VzW2ldKSAqIGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRGVmb3JtVGltZWxpbmU7XG5cdH0oQ3VydmVUaW1lbGluZSkpO1xuXHRzcGluZS5EZWZvcm1UaW1lbGluZSA9IERlZm9ybVRpbWVsaW5lO1xuXHR2YXIgRXZlbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gRXZlbnRUaW1lbGluZShmcmFtZUNvdW50KSB7XG5cdFx0XHR0aGlzLmZyYW1lcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCk7XG5cdFx0XHR0aGlzLmV2ZW50cyA9IG5ldyBBcnJheShmcmFtZUNvdW50KTtcblx0XHR9XG5cdFx0RXZlbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBUaW1lbGluZVR5cGUuZXZlbnQgPDwgMjQ7XG5cdFx0fTtcblx0XHRFdmVudFRpbWVsaW5lLnByb3RvdHlwZS5nZXRGcmFtZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcblx0XHR9O1xuXHRcdEV2ZW50VGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIGV2ZW50KSB7XG5cdFx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IGV2ZW50LnRpbWU7XG5cdFx0XHR0aGlzLmV2ZW50c1tmcmFtZUluZGV4XSA9IGV2ZW50O1xuXHRcdH07XG5cdFx0RXZlbnRUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIHBvc2UsIGRpcmVjdGlvbikge1xuXHRcdFx0aWYgKGZpcmVkRXZlbnRzID09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBmcmFtZUNvdW50ID0gdGhpcy5mcmFtZXMubGVuZ3RoO1xuXHRcdFx0aWYgKGxhc3RUaW1lID4gdGltZSkge1xuXHRcdFx0XHR0aGlzLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgTnVtYmVyLk1BWF9WQUxVRSwgZmlyZWRFdmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pO1xuXHRcdFx0XHRsYXN0VGltZSA9IC0xO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobGFzdFRpbWUgPj0gZnJhbWVzW2ZyYW1lQ291bnQgLSAxXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBmcmFtZSA9IDA7XG5cdFx0XHRpZiAobGFzdFRpbWUgPCBmcmFtZXNbMF0pXG5cdFx0XHRcdGZyYW1lID0gMDtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCBsYXN0VGltZSk7XG5cdFx0XHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xuXHRcdFx0XHR3aGlsZSAoZnJhbWUgPiAwKSB7XG5cdFx0XHRcdFx0aWYgKGZyYW1lc1tmcmFtZSAtIDFdICE9IGZyYW1lVGltZSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGZyYW1lLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoOyBmcmFtZSA8IGZyYW1lQ291bnQgJiYgdGltZSA+PSBmcmFtZXNbZnJhbWVdOyBmcmFtZSsrKVxuXHRcdFx0XHRmaXJlZEV2ZW50cy5wdXNoKHRoaXMuZXZlbnRzW2ZyYW1lXSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gRXZlbnRUaW1lbGluZTtcblx0fSgpKTtcblx0c3BpbmUuRXZlbnRUaW1lbGluZSA9IEV2ZW50VGltZWxpbmU7XG5cdHZhciBEcmF3T3JkZXJUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gRHJhd09yZGVyVGltZWxpbmUoZnJhbWVDb3VudCkge1xuXHRcdFx0dGhpcy5mcmFtZXMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQpO1xuXHRcdFx0dGhpcy5kcmF3T3JkZXJzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xuXHRcdH1cblx0XHREcmF3T3JkZXJUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBUaW1lbGluZVR5cGUuZHJhd09yZGVyIDw8IDI0O1xuXHRcdH07XG5cdFx0RHJhd09yZGVyVGltZWxpbmUucHJvdG90eXBlLmdldEZyYW1lQ291bnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoO1xuXHRcdH07XG5cdFx0RHJhd09yZGVyVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIGRyYXdPcmRlcikge1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdFx0dGhpcy5kcmF3T3JkZXJzW2ZyYW1lSW5kZXhdID0gZHJhd09yZGVyO1xuXHRcdH07XG5cdFx0RHJhd09yZGVyVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBkcmF3T3JkZXIgPSBza2VsZXRvbi5kcmF3T3JkZXI7XG5cdFx0XHR2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcblx0XHRcdGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm91dCAmJiBwb3NlID09IE1peFBvc2Uuc2V0dXApIHtcblx0XHRcdFx0c3BpbmUuVXRpbHMuYXJyYXlDb3B5KHNrZWxldG9uLnNsb3RzLCAwLCBza2VsZXRvbi5kcmF3T3JkZXIsIDAsIHNrZWxldG9uLnNsb3RzLmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdGlmIChwb3NlID09IE1peFBvc2Uuc2V0dXApXG5cdFx0XHRcdFx0c3BpbmUuVXRpbHMuYXJyYXlDb3B5KHNrZWxldG9uLnNsb3RzLCAwLCBza2VsZXRvbi5kcmF3T3JkZXIsIDAsIHNrZWxldG9uLnNsb3RzLmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBmcmFtZSA9IDA7XG5cdFx0XHRpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRmcmFtZSA9IGZyYW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lKSAtIDE7XG5cdFx0XHR2YXIgZHJhd09yZGVyVG9TZXR1cEluZGV4ID0gdGhpcy5kcmF3T3JkZXJzW2ZyYW1lXTtcblx0XHRcdGlmIChkcmF3T3JkZXJUb1NldHVwSW5kZXggPT0gbnVsbClcblx0XHRcdFx0c3BpbmUuVXRpbHMuYXJyYXlDb3B5KHNsb3RzLCAwLCBkcmF3T3JkZXIsIDAsIHNsb3RzLmxlbmd0aCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBkcmF3T3JkZXJUb1NldHVwSW5kZXgubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHRcdGRyYXdPcmRlcltpXSA9IHNsb3RzW2RyYXdPcmRlclRvU2V0dXBJbmRleFtpXV07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRHJhd09yZGVyVGltZWxpbmU7XG5cdH0oKSk7XG5cdHNwaW5lLkRyYXdPcmRlclRpbWVsaW5lID0gRHJhd09yZGVyVGltZWxpbmU7XG5cdHZhciBJa0NvbnN0cmFpbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKElrQ29uc3RyYWludFRpbWVsaW5lLCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIElrQ29uc3RyYWludFRpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpO1xuXHRcdFx0dGhpcy5mcmFtZXMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTKTtcblx0XHR9XG5cdFx0SWtDb25zdHJhaW50VGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gKFRpbWVsaW5lVHlwZS5pa0NvbnN0cmFpbnQgPDwgMjQpICsgdGhpcy5pa0NvbnN0cmFpbnRJbmRleDtcblx0XHR9O1xuXHRcdElrQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBtaXgsIGJlbmREaXJlY3Rpb24pIHtcblx0XHRcdGZyYW1lSW5kZXggKj0gSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5NSVhdID0gbWl4O1xuXHRcdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIElrQ29uc3RyYWludFRpbWVsaW5lLkJFTkRfRElSRUNUSU9OXSA9IGJlbmREaXJlY3Rpb247XG5cdFx0fTtcblx0XHRJa0NvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIHBvc2UsIGRpcmVjdGlvbikge1xuXHRcdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5pa0NvbnN0cmFpbnRzW3RoaXMuaWtDb25zdHJhaW50SW5kZXhdO1xuXHRcdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcblx0XHRcdFx0c3dpdGNoIChwb3NlKSB7XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLnNldHVwOlxuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5taXggPSBjb25zdHJhaW50LmRhdGEubWl4O1xuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gY29uc3RyYWludC5kYXRhLmJlbmREaXJlY3Rpb247XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLmN1cnJlbnQ6XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50Lm1peCArPSAoY29uc3RyYWludC5kYXRhLm1peCAtIGNvbnN0cmFpbnQubWl4KSAqIGFscGhhO1xuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gY29uc3RyYWludC5kYXRhLmJlbmREaXJlY3Rpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSkge1xuXHRcdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKSB7XG5cdFx0XHRcdFx0Y29uc3RyYWludC5taXggPSBjb25zdHJhaW50LmRhdGEubWl4ICsgKGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVhdIC0gY29uc3RyYWludC5kYXRhLm1peCkgKiBhbHBoYTtcblx0XHRcdFx0XHRjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm91dCA/IGNvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uXG5cdFx0XHRcdFx0XHQ6IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9CRU5EX0RJUkVDVElPTl07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3RyYWludC5taXggKz0gKGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVhdIC0gY29uc3RyYWludC5taXgpICogYWxwaGE7XG5cdFx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PSBNaXhEaXJlY3Rpb24uaW4pXG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQkVORF9ESVJFQ1RJT05dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTKTtcblx0XHRcdHZhciBtaXggPSBmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX01JWF07XG5cdFx0XHR2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcblx0XHRcdHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRpZiAocG9zZSA9PSBNaXhQb3NlLnNldHVwKSB7XG5cdFx0XHRcdGNvbnN0cmFpbnQubWl4ID0gY29uc3RyYWludC5kYXRhLm1peCArIChtaXggKyAoZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuTUlYXSAtIG1peCkgKiBwZXJjZW50IC0gY29uc3RyYWludC5kYXRhLm1peCkgKiBhbHBoYTtcblx0XHRcdFx0Y29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5vdXQgPyBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbiA6IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQkVORF9ESVJFQ1RJT05dO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnN0cmFpbnQubWl4ICs9IChtaXggKyAoZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuTUlYXSAtIG1peCkgKiBwZXJjZW50IC0gY29uc3RyYWludC5taXgpICogYWxwaGE7XG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLmluKVxuXHRcdFx0XHRcdGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQkVORF9ESVJFQ1RJT05dO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0SWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUyA9IDM7XG5cdFx0SWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9USU1FID0gLTM7XG5cdFx0SWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVggPSAtMjtcblx0XHRJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OID0gLTE7XG5cdFx0SWtDb25zdHJhaW50VGltZWxpbmUuTUlYID0gMTtcblx0XHRJa0NvbnN0cmFpbnRUaW1lbGluZS5CRU5EX0RJUkVDVElPTiA9IDI7XG5cdFx0cmV0dXJuIElrQ29uc3RyYWludFRpbWVsaW5lO1xuXHR9KEN1cnZlVGltZWxpbmUpKTtcblx0c3BpbmUuSWtDb25zdHJhaW50VGltZWxpbmUgPSBJa0NvbnN0cmFpbnRUaW1lbGluZTtcblx0dmFyIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZSwgX3N1cGVyKTtcblx0XHRmdW5jdGlvbiBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUoZnJhbWVDb3VudCkge1xuXHRcdFx0X3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCk7XG5cdFx0XHR0aGlzLmZyYW1lcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTKTtcblx0XHR9XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIChUaW1lbGluZVR5cGUudHJhbnNmb3JtQ29uc3RyYWludCA8PCAyNCkgKyB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRJbmRleDtcblx0XHR9O1xuXHRcdFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgcm90YXRlTWl4LCB0cmFuc2xhdGVNaXgsIHNjYWxlTWl4LCBzaGVhck1peCkge1xuXHRcdFx0ZnJhbWVJbmRleCAqPSBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUk9UQVRFXSA9IHJvdGF0ZU1peDtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuVFJBTlNMQVRFXSA9IHRyYW5zbGF0ZU1peDtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0NBTEVdID0gc2NhbGVNaXg7XG5cdFx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNIRUFSXSA9IHNoZWFyTWl4O1xuXHRcdH07XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSwgcG9zZSwgZGlyZWN0aW9uKSB7XG5cdFx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0XHR2YXIgY29uc3RyYWludCA9IHNrZWxldG9uLnRyYW5zZm9ybUNvbnN0cmFpbnRzW3RoaXMudHJhbnNmb3JtQ29uc3RyYWludEluZGV4XTtcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY29uc3RyYWludC5kYXRhO1xuXHRcdFx0XHRzd2l0Y2ggKHBvc2UpIHtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2Uuc2V0dXA6XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4O1xuXHRcdFx0XHRcdFx0Y29uc3RyYWludC50cmFuc2xhdGVNaXggPSBkYXRhLnRyYW5zbGF0ZU1peDtcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuc2NhbGVNaXggPSBkYXRhLnNjYWxlTWl4O1xuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5zaGVhck1peCA9IGRhdGEuc2hlYXJNaXg7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSBNaXhQb3NlLmN1cnJlbnQ6XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LnJvdGF0ZU1peCArPSAoZGF0YS5yb3RhdGVNaXggLSBjb25zdHJhaW50LnJvdGF0ZU1peCkgKiBhbHBoYTtcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ICs9IChkYXRhLnRyYW5zbGF0ZU1peCAtIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5zY2FsZU1peCArPSAoZGF0YS5zY2FsZU1peCAtIGNvbnN0cmFpbnQuc2NhbGVNaXgpICogYWxwaGE7XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LnNoZWFyTWl4ICs9IChkYXRhLnNoZWFyTWl4IC0gY29uc3RyYWludC5zaGVhck1peCkgKiBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcm90YXRlID0gMCwgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAwLCBzaGVhciA9IDA7XG5cdFx0XHRpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSkge1xuXHRcdFx0XHR2YXIgaSA9IGZyYW1lcy5sZW5ndGg7XG5cdFx0XHRcdHJvdGF0ZSA9IGZyYW1lc1tpICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfUk9UQVRFXTtcblx0XHRcdFx0dHJhbnNsYXRlID0gZnJhbWVzW2kgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9UUkFOU0xBVEVdO1xuXHRcdFx0XHRzY2FsZSA9IGZyYW1lc1tpICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0NBTEVdO1xuXHRcdFx0XHRzaGVhciA9IGZyYW1lc1tpICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0hFQVJdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUyk7XG5cdFx0XHRcdHJvdGF0ZSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1JPVEFURV07XG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RSQU5TTEFURV07XG5cdFx0XHRcdHNjYWxlID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0NBTEVdO1xuXHRcdFx0XHRzaGVhciA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NIRUFSXTtcblx0XHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcblx0XHRcdFx0cm90YXRlICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUk9UQVRFXSAtIHJvdGF0ZSkgKiBwZXJjZW50O1xuXHRcdFx0XHR0cmFuc2xhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5UUkFOU0xBVEVdIC0gdHJhbnNsYXRlKSAqIHBlcmNlbnQ7XG5cdFx0XHRcdHNjYWxlICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0NBTEVdIC0gc2NhbGUpICogcGVyY2VudDtcblx0XHRcdFx0c2hlYXIgKz0gKGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5TSEVBUl0gLSBzaGVhcikgKiBwZXJjZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbnN0cmFpbnQuZGF0YTtcblx0XHRcdFx0Y29uc3RyYWludC5yb3RhdGVNaXggPSBkYXRhLnJvdGF0ZU1peCArIChyb3RhdGUgLSBkYXRhLnJvdGF0ZU1peCkgKiBhbHBoYTtcblx0XHRcdFx0Y29uc3RyYWludC50cmFuc2xhdGVNaXggPSBkYXRhLnRyYW5zbGF0ZU1peCArICh0cmFuc2xhdGUgLSBkYXRhLnRyYW5zbGF0ZU1peCkgKiBhbHBoYTtcblx0XHRcdFx0Y29uc3RyYWludC5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXggKyAoc2NhbGUgLSBkYXRhLnNjYWxlTWl4KSAqIGFscGhhO1xuXHRcdFx0XHRjb25zdHJhaW50LnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peCArIChzaGVhciAtIGRhdGEuc2hlYXJNaXgpICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29uc3RyYWludC5yb3RhdGVNaXggKz0gKHJvdGF0ZSAtIGNvbnN0cmFpbnQucm90YXRlTWl4KSAqIGFscGhhO1xuXHRcdFx0XHRjb25zdHJhaW50LnRyYW5zbGF0ZU1peCArPSAodHJhbnNsYXRlIC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XG5cdFx0XHRcdGNvbnN0cmFpbnQuc2NhbGVNaXggKz0gKHNjYWxlIC0gY29uc3RyYWludC5zY2FsZU1peCkgKiBhbHBoYTtcblx0XHRcdFx0Y29uc3RyYWludC5zaGVhck1peCArPSAoc2hlYXIgLSBjb25zdHJhaW50LnNoZWFyTWl4KSAqIGFscGhhO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMgPSA1O1xuXHRcdFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RJTUUgPSAtNTtcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9ST1RBVEUgPSAtNDtcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9UUkFOU0xBVEUgPSAtMztcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9TQ0FMRSA9IC0yO1xuXHRcdFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NIRUFSID0gLTE7XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlJPVEFURSA9IDE7XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlRSQU5TTEFURSA9IDI7XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNDQUxFID0gMztcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0hFQVIgPSA0O1xuXHRcdHJldHVybiBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmU7XG5cdH0oQ3VydmVUaW1lbGluZSkpO1xuXHRzcGluZS5UcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUgPSBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmU7XG5cdHZhciBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpO1xuXHRcdFx0dGhpcy5mcmFtZXMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFUyk7XG5cdFx0fVxuXHRcdFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnBhdGhDb25zdHJhaW50UG9zaXRpb24gPDwgMjQpICsgdGhpcy5wYXRoQ29uc3RyYWludEluZGV4O1xuXHRcdH07XG5cdFx0UGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB2YWx1ZSkge1xuXHRcdFx0ZnJhbWVJbmRleCAqPSBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFUztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuVkFMVUVdID0gdmFsdWU7XG5cdFx0fTtcblx0XHRQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBwb3NlLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRcdHZhciBjb25zdHJhaW50ID0gc2tlbGV0b24ucGF0aENvbnN0cmFpbnRzW3RoaXMucGF0aENvbnN0cmFpbnRJbmRleF07XG5cdFx0XHRpZiAodGltZSA8IGZyYW1lc1swXSkge1xuXHRcdFx0XHRzd2l0Y2ggKHBvc2UpIHtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2Uuc2V0dXA6XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LnBvc2l0aW9uID0gY29uc3RyYWludC5kYXRhLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5jdXJyZW50OlxuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5wb3NpdGlvbiArPSAoY29uc3RyYWludC5kYXRhLnBvc2l0aW9uIC0gY29uc3RyYWludC5wb3NpdGlvbikgKiBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcG9zaXRpb24gPSAwO1xuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFU10pXG5cdFx0XHRcdHBvc2l0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuUFJFVl9WQUxVRV07XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTKTtcblx0XHRcdFx0cG9zaXRpb24gPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuUFJFVl9WQUxVRV07XG5cdFx0XHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xuXHRcdFx0XHR2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IChmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuVkFMVUVdIC0gcG9zaXRpb24pICogcGVyY2VudDtcblx0XHRcdH1cblx0XHRcdGlmIChwb3NlID09IE1peFBvc2Uuc2V0dXApXG5cdFx0XHRcdGNvbnN0cmFpbnQucG9zaXRpb24gPSBjb25zdHJhaW50LmRhdGEucG9zaXRpb24gKyAocG9zaXRpb24gLSBjb25zdHJhaW50LmRhdGEucG9zaXRpb24pICogYWxwaGE7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNvbnN0cmFpbnQucG9zaXRpb24gKz0gKHBvc2l0aW9uIC0gY29uc3RyYWludC5wb3NpdGlvbikgKiBhbHBoYTtcblx0XHR9O1xuXHRcdFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTID0gMjtcblx0XHRQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuUFJFVl9USU1FID0gLTI7XG5cdFx0UGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVkFMVUUgPSAtMTtcblx0XHRQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuVkFMVUUgPSAxO1xuXHRcdHJldHVybiBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmU7XG5cdH0oQ3VydmVUaW1lbGluZSkpO1xuXHRzcGluZS5QYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUgPSBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmU7XG5cdHZhciBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lKGZyYW1lQ291bnQpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpO1xuXHRcdH1cblx0XHRQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnBhdGhDb25zdHJhaW50U3BhY2luZyA8PCAyNCkgKyB0aGlzLnBhdGhDb25zdHJhaW50SW5kZXg7XG5cdFx0fTtcblx0XHRQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIHBvc2UsIGRpcmVjdGlvbikge1xuXHRcdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5wYXRoQ29uc3RyYWludHNbdGhpcy5wYXRoQ29uc3RyYWludEluZGV4XTtcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdHN3aXRjaCAocG9zZSkge1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5zZXR1cDpcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuc3BhY2luZyA9IGNvbnN0cmFpbnQuZGF0YS5zcGFjaW5nO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5jdXJyZW50OlxuXHRcdFx0XHRcdFx0Y29uc3RyYWludC5zcGFjaW5nICs9IChjb25zdHJhaW50LmRhdGEuc3BhY2luZyAtIGNvbnN0cmFpbnQuc3BhY2luZykgKiBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3BhY2luZyA9IDA7XG5cdFx0XHRpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLkVOVFJJRVNdKVxuXHRcdFx0XHRzcGFjaW5nID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5QUkVWX1ZBTFVFXTtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUuRU5UUklFUyk7XG5cdFx0XHRcdHNwYWNpbmcgPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5QUkVWX1ZBTFVFXTtcblx0XHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XG5cdFx0XHRcdHNwYWNpbmcgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLlZBTFVFXSAtIHNwYWNpbmcpICogcGVyY2VudDtcblx0XHRcdH1cblx0XHRcdGlmIChwb3NlID09IE1peFBvc2Uuc2V0dXApXG5cdFx0XHRcdGNvbnN0cmFpbnQuc3BhY2luZyA9IGNvbnN0cmFpbnQuZGF0YS5zcGFjaW5nICsgKHNwYWNpbmcgLSBjb25zdHJhaW50LmRhdGEuc3BhY2luZykgKiBhbHBoYTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Y29uc3RyYWludC5zcGFjaW5nICs9IChzcGFjaW5nIC0gY29uc3RyYWludC5zcGFjaW5nKSAqIGFscGhhO1xuXHRcdH07XG5cdFx0cmV0dXJuIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lO1xuXHR9KFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZSkpO1xuXHRzcGluZS5QYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSA9IFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lO1xuXHR2YXIgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZShmcmFtZUNvdW50KSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KTtcblx0XHRcdHRoaXMuZnJhbWVzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTKTtcblx0XHR9XG5cdFx0UGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAoVGltZWxpbmVUeXBlLnBhdGhDb25zdHJhaW50TWl4IDw8IDI0KSArIHRoaXMucGF0aENvbnN0cmFpbnRJbmRleDtcblx0XHR9O1xuXHRcdFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4KSB7XG5cdFx0XHRmcmFtZUluZGV4ICo9IFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUztcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlJPVEFURV0gPSByb3RhdGVNaXg7XG5cdFx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5UUkFOU0xBVEVdID0gdHJhbnNsYXRlTWl4O1xuXHRcdH07XG5cdFx0UGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIHBvc2UsIGRpcmVjdGlvbikge1xuXHRcdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5wYXRoQ29uc3RyYWludHNbdGhpcy5wYXRoQ29uc3RyYWludEluZGV4XTtcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdHN3aXRjaCAocG9zZSkge1xuXHRcdFx0XHRcdGNhc2UgTWl4UG9zZS5zZXR1cDpcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQucm90YXRlTWl4ID0gY29uc3RyYWludC5kYXRhLnJvdGF0ZU1peDtcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gY29uc3RyYWludC5kYXRhLnRyYW5zbGF0ZU1peDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlIE1peFBvc2UuY3VycmVudDpcblx0XHRcdFx0XHRcdGNvbnN0cmFpbnQucm90YXRlTWl4ICs9IChjb25zdHJhaW50LmRhdGEucm90YXRlTWl4IC0gY29uc3RyYWludC5yb3RhdGVNaXgpICogYWxwaGE7XG5cdFx0XHRcdFx0XHRjb25zdHJhaW50LnRyYW5zbGF0ZU1peCArPSAoY29uc3RyYWludC5kYXRhLnRyYW5zbGF0ZU1peCAtIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciByb3RhdGUgPSAwLCB0cmFuc2xhdGUgPSAwO1xuXHRcdFx0aWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVNdKSB7XG5cdFx0XHRcdHJvdGF0ZSA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1JPVEFURV07XG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1RSQU5TTEFURV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUyk7XG5cdFx0XHRcdHJvdGF0ZSA9IGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9ST1RBVEVdO1xuXHRcdFx0XHR0cmFuc2xhdGUgPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfVFJBTlNMQVRFXTtcblx0XHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xuXHRcdFx0XHRyb3RhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUk9UQVRFXSAtIHJvdGF0ZSkgKiBwZXJjZW50O1xuXHRcdFx0XHR0cmFuc2xhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuVFJBTlNMQVRFXSAtIHRyYW5zbGF0ZSkgKiBwZXJjZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvc2UgPT0gTWl4UG9zZS5zZXR1cCkge1xuXHRcdFx0XHRjb25zdHJhaW50LnJvdGF0ZU1peCA9IGNvbnN0cmFpbnQuZGF0YS5yb3RhdGVNaXggKyAocm90YXRlIC0gY29uc3RyYWludC5kYXRhLnJvdGF0ZU1peCkgKiBhbHBoYTtcblx0XHRcdFx0Y29uc3RyYWludC50cmFuc2xhdGVNaXggPSBjb25zdHJhaW50LmRhdGEudHJhbnNsYXRlTWl4ICsgKHRyYW5zbGF0ZSAtIGNvbnN0cmFpbnQuZGF0YS50cmFuc2xhdGVNaXgpICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29uc3RyYWludC5yb3RhdGVNaXggKz0gKHJvdGF0ZSAtIGNvbnN0cmFpbnQucm90YXRlTWl4KSAqIGFscGhhO1xuXHRcdFx0XHRjb25zdHJhaW50LnRyYW5zbGF0ZU1peCArPSAodHJhbnNsYXRlIC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVMgPSAzO1xuXHRcdFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9USU1FID0gLTM7XG5cdFx0UGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1JPVEFURSA9IC0yO1xuXHRcdFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9UUkFOU0xBVEUgPSAtMTtcblx0XHRQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlJPVEFURSA9IDE7XG5cdFx0UGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5UUkFOU0xBVEUgPSAyO1xuXHRcdHJldHVybiBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lO1xuXHR9KEN1cnZlVGltZWxpbmUpKTtcblx0c3BpbmUuUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZSA9IFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmU7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgQW5pbWF0aW9uU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlKGRhdGEpIHtcblx0XHRcdHRoaXMudHJhY2tzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmV2ZW50cyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMucXVldWUgPSBuZXcgRXZlbnRRdWV1ZSh0aGlzKTtcblx0XHRcdHRoaXMucHJvcGVydHlJRHMgPSBuZXcgc3BpbmUuSW50U2V0KCk7XG5cdFx0XHR0aGlzLm1peGluZ1RvID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLnRyYWNrRW50cnlQb29sID0gbmV3IHNwaW5lLlBvb2woZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFRyYWNrRW50cnkoKTsgfSk7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdH1cblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG5cdFx0XHRkZWx0YSAqPSB0aGlzLnRpbWVTY2FsZTtcblx0XHRcdHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY3VycmVudCA9IHRyYWNrc1tpXTtcblx0XHRcdFx0aWYgKGN1cnJlbnQgPT0gbnVsbClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0Y3VycmVudC5hbmltYXRpb25MYXN0ID0gY3VycmVudC5uZXh0QW5pbWF0aW9uTGFzdDtcblx0XHRcdFx0Y3VycmVudC50cmFja0xhc3QgPSBjdXJyZW50Lm5leHRUcmFja0xhc3Q7XG5cdFx0XHRcdHZhciBjdXJyZW50RGVsdGEgPSBkZWx0YSAqIGN1cnJlbnQudGltZVNjYWxlO1xuXHRcdFx0XHRpZiAoY3VycmVudC5kZWxheSA+IDApIHtcblx0XHRcdFx0XHRjdXJyZW50LmRlbGF5IC09IGN1cnJlbnREZWx0YTtcblx0XHRcdFx0XHRpZiAoY3VycmVudC5kZWxheSA+IDApXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRjdXJyZW50RGVsdGEgPSAtY3VycmVudC5kZWxheTtcblx0XHRcdFx0XHRjdXJyZW50LmRlbGF5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbmV4dCA9IGN1cnJlbnQubmV4dDtcblx0XHRcdFx0aWYgKG5leHQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBuZXh0VGltZSA9IGN1cnJlbnQudHJhY2tMYXN0IC0gbmV4dC5kZWxheTtcblx0XHRcdFx0XHRpZiAobmV4dFRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0bmV4dC5kZWxheSA9IDA7XG5cdFx0XHRcdFx0XHRuZXh0LnRyYWNrVGltZSA9IG5leHRUaW1lICsgZGVsdGEgKiBuZXh0LnRpbWVTY2FsZTtcblx0XHRcdFx0XHRcdGN1cnJlbnQudHJhY2tUaW1lICs9IGN1cnJlbnREZWx0YTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0Q3VycmVudChpLCBuZXh0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHdoaWxlIChuZXh0Lm1peGluZ0Zyb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRuZXh0Lm1peFRpbWUgKz0gY3VycmVudERlbHRhO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5taXhpbmdGcm9tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGN1cnJlbnQudHJhY2tMYXN0ID49IGN1cnJlbnQudHJhY2tFbmQgJiYgY3VycmVudC5taXhpbmdGcm9tID09IG51bGwpIHtcblx0XHRcdFx0XHR0cmFja3NbaV0gPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMucXVldWUuZW5kKGN1cnJlbnQpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcG9zZU5leHQoY3VycmVudCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN1cnJlbnQubWl4aW5nRnJvbSAhPSBudWxsICYmIHRoaXMudXBkYXRlTWl4aW5nRnJvbShjdXJyZW50LCBkZWx0YSkpIHtcblx0XHRcdFx0XHR2YXIgZnJvbSA9IGN1cnJlbnQubWl4aW5nRnJvbTtcblx0XHRcdFx0XHRjdXJyZW50Lm1peGluZ0Zyb20gPSBudWxsO1xuXHRcdFx0XHRcdHdoaWxlIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHRoaXMucXVldWUuZW5kKGZyb20pO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20ubWl4aW5nRnJvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VycmVudC50cmFja1RpbWUgKz0gY3VycmVudERlbHRhO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5xdWV1ZS5kcmFpbigpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnVwZGF0ZU1peGluZ0Zyb20gPSBmdW5jdGlvbiAodG8sIGRlbHRhKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRvLm1peGluZ0Zyb207XG5cdFx0XHRpZiAoZnJvbSA9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHZhciBmaW5pc2hlZCA9IHRoaXMudXBkYXRlTWl4aW5nRnJvbShmcm9tLCBkZWx0YSk7XG5cdFx0XHRpZiAodG8ubWl4VGltZSA+IDAgJiYgKHRvLm1peFRpbWUgPj0gdG8ubWl4RHVyYXRpb24gfHwgdG8udGltZVNjYWxlID09IDApKSB7XG5cdFx0XHRcdGlmIChmcm9tLnRvdGFsQWxwaGEgPT0gMCkge1xuXHRcdFx0XHRcdHRvLm1peGluZ0Zyb20gPSBmcm9tLm1peGluZ0Zyb207XG5cdFx0XHRcdFx0dG8uaW50ZXJydXB0QWxwaGEgPSBmcm9tLmludGVycnVwdEFscGhhO1xuXHRcdFx0XHRcdHRoaXMucXVldWUuZW5kKGZyb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmaW5pc2hlZDtcblx0XHRcdH1cblx0XHRcdGZyb20uYW5pbWF0aW9uTGFzdCA9IGZyb20ubmV4dEFuaW1hdGlvbkxhc3Q7XG5cdFx0XHRmcm9tLnRyYWNrTGFzdCA9IGZyb20ubmV4dFRyYWNrTGFzdDtcblx0XHRcdGZyb20udHJhY2tUaW1lICs9IGRlbHRhICogZnJvbS50aW1lU2NhbGU7XG5cdFx0XHR0by5taXhUaW1lICs9IGRlbHRhICogdG8udGltZVNjYWxlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uKSB7XG5cdFx0XHRpZiAoc2tlbGV0b24gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKHRoaXMuYW5pbWF0aW9uc0NoYW5nZWQpXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnNDaGFuZ2VkKCk7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG5cdFx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG5cdFx0XHR2YXIgYXBwbGllZCA9IGZhbHNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50ID0gdHJhY2tzW2ldO1xuXHRcdFx0XHRpZiAoY3VycmVudCA9PSBudWxsIHx8IGN1cnJlbnQuZGVsYXkgPiAwKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRhcHBsaWVkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGN1cnJlbnRQb3NlID0gaSA9PSAwID8gc3BpbmUuTWl4UG9zZS5jdXJyZW50IDogc3BpbmUuTWl4UG9zZS5jdXJyZW50TGF5ZXJlZDtcblx0XHRcdFx0dmFyIG1peCA9IGN1cnJlbnQuYWxwaGE7XG5cdFx0XHRcdGlmIChjdXJyZW50Lm1peGluZ0Zyb20gIT0gbnVsbClcblx0XHRcdFx0XHRtaXggKj0gdGhpcy5hcHBseU1peGluZ0Zyb20oY3VycmVudCwgc2tlbGV0b24sIGN1cnJlbnRQb3NlKTtcblx0XHRcdFx0ZWxzZSBpZiAoY3VycmVudC50cmFja1RpbWUgPj0gY3VycmVudC50cmFja0VuZCAmJiBjdXJyZW50Lm5leHQgPT0gbnVsbClcblx0XHRcdFx0XHRtaXggPSAwO1xuXHRcdFx0XHR2YXIgYW5pbWF0aW9uTGFzdCA9IGN1cnJlbnQuYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSA9IGN1cnJlbnQuZ2V0QW5pbWF0aW9uVGltZSgpO1xuXHRcdFx0XHR2YXIgdGltZWxpbmVDb3VudCA9IGN1cnJlbnQuYW5pbWF0aW9uLnRpbWVsaW5lcy5sZW5ndGg7XG5cdFx0XHRcdHZhciB0aW1lbGluZXMgPSBjdXJyZW50LmFuaW1hdGlvbi50aW1lbGluZXM7XG5cdFx0XHRcdGlmIChtaXggPT0gMSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCB0aW1lbGluZUNvdW50OyBpaSsrKVxuXHRcdFx0XHRcdFx0dGltZWxpbmVzW2lpXS5hcHBseShza2VsZXRvbiwgYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSwgZXZlbnRzLCAxLCBzcGluZS5NaXhQb3NlLnNldHVwLCBzcGluZS5NaXhEaXJlY3Rpb24uaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciB0aW1lbGluZURhdGEgPSBjdXJyZW50LnRpbWVsaW5lRGF0YTtcblx0XHRcdFx0XHR2YXIgZmlyc3RGcmFtZSA9IGN1cnJlbnQudGltZWxpbmVzUm90YXRpb24ubGVuZ3RoID09IDA7XG5cdFx0XHRcdFx0aWYgKGZpcnN0RnJhbWUpXG5cdFx0XHRcdFx0XHRzcGluZS5VdGlscy5zZXRBcnJheVNpemUoY3VycmVudC50aW1lbGluZXNSb3RhdGlvbiwgdGltZWxpbmVDb3VudCA8PCAxLCBudWxsKTtcblx0XHRcdFx0XHR2YXIgdGltZWxpbmVzUm90YXRpb24gPSBjdXJyZW50LnRpbWVsaW5lc1JvdGF0aW9uO1xuXHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCB0aW1lbGluZUNvdW50OyBpaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSB0aW1lbGluZXNbaWldO1xuXHRcdFx0XHRcdFx0dmFyIHBvc2UgPSB0aW1lbGluZURhdGFbaWldID49IEFuaW1hdGlvblN0YXRlLkZJUlNUID8gc3BpbmUuTWl4UG9zZS5zZXR1cCA6IGN1cnJlbnRQb3NlO1xuXHRcdFx0XHRcdFx0aWYgKHRpbWVsaW5lIGluc3RhbmNlb2Ygc3BpbmUuUm90YXRlVGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hcHBseVJvdGF0ZVRpbWVsaW5lKHRpbWVsaW5lLCBza2VsZXRvbiwgYW5pbWF0aW9uVGltZSwgbWl4LCBwb3NlLCB0aW1lbGluZXNSb3RhdGlvbiwgaWkgPDwgMSwgZmlyc3RGcmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lLmFwcGx5KHNrZWxldG9uLCBhbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lLCBldmVudHMsIG1peCwgcG9zZSwgc3BpbmUuTWl4RGlyZWN0aW9uLmluKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5xdWV1ZUV2ZW50cyhjdXJyZW50LCBhbmltYXRpb25UaW1lKTtcblx0XHRcdFx0ZXZlbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGN1cnJlbnQubmV4dEFuaW1hdGlvbkxhc3QgPSBhbmltYXRpb25UaW1lO1xuXHRcdFx0XHRjdXJyZW50Lm5leHRUcmFja0xhc3QgPSBjdXJyZW50LnRyYWNrVGltZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucXVldWUuZHJhaW4oKTtcblx0XHRcdHJldHVybiBhcHBsaWVkO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5TWl4aW5nRnJvbSA9IGZ1bmN0aW9uICh0bywgc2tlbGV0b24sIGN1cnJlbnRQb3NlKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRvLm1peGluZ0Zyb207XG5cdFx0XHRpZiAoZnJvbS5taXhpbmdGcm9tICE9IG51bGwpXG5cdFx0XHRcdHRoaXMuYXBwbHlNaXhpbmdGcm9tKGZyb20sIHNrZWxldG9uLCBjdXJyZW50UG9zZSk7XG5cdFx0XHR2YXIgbWl4ID0gMDtcblx0XHRcdGlmICh0by5taXhEdXJhdGlvbiA9PSAwKVxuXHRcdFx0XHRtaXggPSAxO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1peCA9IHRvLm1peFRpbWUgLyB0by5taXhEdXJhdGlvbjtcblx0XHRcdFx0aWYgKG1peCA+IDEpXG5cdFx0XHRcdFx0bWl4ID0gMTtcblx0XHRcdH1cblx0XHRcdHZhciBldmVudHMgPSBtaXggPCBmcm9tLmV2ZW50VGhyZXNob2xkID8gdGhpcy5ldmVudHMgOiBudWxsO1xuXHRcdFx0dmFyIGF0dGFjaG1lbnRzID0gbWl4IDwgZnJvbS5hdHRhY2htZW50VGhyZXNob2xkLCBkcmF3T3JkZXIgPSBtaXggPCBmcm9tLmRyYXdPcmRlclRocmVzaG9sZDtcblx0XHRcdHZhciBhbmltYXRpb25MYXN0ID0gZnJvbS5hbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lID0gZnJvbS5nZXRBbmltYXRpb25UaW1lKCk7XG5cdFx0XHR2YXIgdGltZWxpbmVDb3VudCA9IGZyb20uYW5pbWF0aW9uLnRpbWVsaW5lcy5sZW5ndGg7XG5cdFx0XHR2YXIgdGltZWxpbmVzID0gZnJvbS5hbmltYXRpb24udGltZWxpbmVzO1xuXHRcdFx0dmFyIHRpbWVsaW5lRGF0YSA9IGZyb20udGltZWxpbmVEYXRhO1xuXHRcdFx0dmFyIHRpbWVsaW5lRGlwTWl4ID0gZnJvbS50aW1lbGluZURpcE1peDtcblx0XHRcdHZhciBmaXJzdEZyYW1lID0gZnJvbS50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPT0gMDtcblx0XHRcdGlmIChmaXJzdEZyYW1lKVxuXHRcdFx0XHRzcGluZS5VdGlscy5zZXRBcnJheVNpemUoZnJvbS50aW1lbGluZXNSb3RhdGlvbiwgdGltZWxpbmVDb3VudCA8PCAxLCBudWxsKTtcblx0XHRcdHZhciB0aW1lbGluZXNSb3RhdGlvbiA9IGZyb20udGltZWxpbmVzUm90YXRpb247XG5cdFx0XHR2YXIgcG9zZTtcblx0XHRcdHZhciBhbHBoYURpcCA9IGZyb20uYWxwaGEgKiB0by5pbnRlcnJ1cHRBbHBoYSwgYWxwaGFNaXggPSBhbHBoYURpcCAqICgxIC0gbWl4KSwgYWxwaGEgPSAwO1xuXHRcdFx0ZnJvbS50b3RhbEFscGhhID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0aW1lbGluZSA9IHRpbWVsaW5lc1tpXTtcblx0XHRcdFx0c3dpdGNoICh0aW1lbGluZURhdGFbaV0pIHtcblx0XHRcdFx0XHRjYXNlIEFuaW1hdGlvblN0YXRlLlNVQlNFUVVFTlQ6XG5cdFx0XHRcdFx0XHRpZiAoIWF0dGFjaG1lbnRzICYmIHRpbWVsaW5lIGluc3RhbmNlb2Ygc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGlmICghZHJhd09yZGVyICYmIHRpbWVsaW5lIGluc3RhbmNlb2Ygc3BpbmUuRHJhd09yZGVyVGltZWxpbmUpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0cG9zZSA9IGN1cnJlbnRQb3NlO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhbHBoYU1peDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgQW5pbWF0aW9uU3RhdGUuRklSU1Q6XG5cdFx0XHRcdFx0XHRwb3NlID0gc3BpbmUuTWl4UG9zZS5zZXR1cDtcblx0XHRcdFx0XHRcdGFscGhhID0gYWxwaGFNaXg7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIEFuaW1hdGlvblN0YXRlLkRJUDpcblx0XHRcdFx0XHRcdHBvc2UgPSBzcGluZS5NaXhQb3NlLnNldHVwO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhbHBoYURpcDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRwb3NlID0gc3BpbmUuTWl4UG9zZS5zZXR1cDtcblx0XHRcdFx0XHRcdGFscGhhID0gYWxwaGFEaXA7XG5cdFx0XHRcdFx0XHR2YXIgZGlwTWl4ID0gdGltZWxpbmVEaXBNaXhbaV07XG5cdFx0XHRcdFx0XHRhbHBoYSAqPSBNYXRoLm1heCgwLCAxIC0gZGlwTWl4Lm1peFRpbWUgLyBkaXBNaXgubWl4RHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbS50b3RhbEFscGhhICs9IGFscGhhO1xuXHRcdFx0XHRpZiAodGltZWxpbmUgaW5zdGFuY2VvZiBzcGluZS5Sb3RhdGVUaW1lbGluZSlcblx0XHRcdFx0XHR0aGlzLmFwcGx5Um90YXRlVGltZWxpbmUodGltZWxpbmUsIHNrZWxldG9uLCBhbmltYXRpb25UaW1lLCBhbHBoYSwgcG9zZSwgdGltZWxpbmVzUm90YXRpb24sIGkgPDwgMSwgZmlyc3RGcmFtZSk7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRpbWVsaW5lLmFwcGx5KHNrZWxldG9uLCBhbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lLCBldmVudHMsIGFscGhhLCBwb3NlLCBzcGluZS5NaXhEaXJlY3Rpb24ub3V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRvLm1peER1cmF0aW9uID4gMClcblx0XHRcdFx0dGhpcy5xdWV1ZUV2ZW50cyhmcm9tLCBhbmltYXRpb25UaW1lKTtcblx0XHRcdHRoaXMuZXZlbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRmcm9tLm5leHRBbmltYXRpb25MYXN0ID0gYW5pbWF0aW9uVGltZTtcblx0XHRcdGZyb20ubmV4dFRyYWNrTGFzdCA9IGZyb20udHJhY2tUaW1lO1xuXHRcdFx0cmV0dXJuIG1peDtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hcHBseVJvdGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKHRpbWVsaW5lLCBza2VsZXRvbiwgdGltZSwgYWxwaGEsIHBvc2UsIHRpbWVsaW5lc1JvdGF0aW9uLCBpLCBmaXJzdEZyYW1lKSB7XG5cdFx0XHRpZiAoZmlyc3RGcmFtZSlcblx0XHRcdFx0dGltZWxpbmVzUm90YXRpb25baV0gPSAwO1xuXHRcdFx0aWYgKGFscGhhID09IDEpIHtcblx0XHRcdFx0dGltZWxpbmUuYXBwbHkoc2tlbGV0b24sIDAsIHRpbWUsIG51bGwsIDEsIHBvc2UsIHNwaW5lLk1peERpcmVjdGlvbi5pbik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciByb3RhdGVUaW1lbGluZSA9IHRpbWVsaW5lO1xuXHRcdFx0dmFyIGZyYW1lcyA9IHJvdGF0ZVRpbWVsaW5lLmZyYW1lcztcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbcm90YXRlVGltZWxpbmUuYm9uZUluZGV4XTtcblx0XHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XG5cdFx0XHRcdGlmIChwb3NlID09IHNwaW5lLk1peFBvc2Uuc2V0dXApXG5cdFx0XHRcdFx0Ym9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHIyID0gMDtcblx0XHRcdGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gc3BpbmUuUm90YXRlVGltZWxpbmUuRU5UUklFU10pXG5cdFx0XHRcdHIyID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBzcGluZS5Sb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OXTtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgZnJhbWUgPSBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgc3BpbmUuUm90YXRlVGltZWxpbmUuRU5UUklFUyk7XG5cdFx0XHRcdHZhciBwcmV2Um90YXRpb24gPSBmcmFtZXNbZnJhbWUgKyBzcGluZS5Sb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OXTtcblx0XHRcdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gcm90YXRlVGltZWxpbmUuZ2V0Q3VydmVQZXJjZW50KChmcmFtZSA+PiAxKSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgc3BpbmUuUm90YXRlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xuXHRcdFx0XHRyMiA9IGZyYW1lc1tmcmFtZSArIHNwaW5lLlJvdGF0ZVRpbWVsaW5lLlJPVEFUSU9OXSAtIHByZXZSb3RhdGlvbjtcblx0XHRcdFx0cjIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByMiAvIDM2MCkgfCAwKSkgKiAzNjA7XG5cdFx0XHRcdHIyID0gcHJldlJvdGF0aW9uICsgcjIgKiBwZXJjZW50ICsgYm9uZS5kYXRhLnJvdGF0aW9uO1xuXHRcdFx0XHRyMiAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIyIC8gMzYwKSB8IDApKSAqIDM2MDtcblx0XHRcdH1cblx0XHRcdHZhciByMSA9IHBvc2UgPT0gc3BpbmUuTWl4UG9zZS5zZXR1cCA/IGJvbmUuZGF0YS5yb3RhdGlvbiA6IGJvbmUucm90YXRpb247XG5cdFx0XHR2YXIgdG90YWwgPSAwLCBkaWZmID0gcjIgLSByMTtcblx0XHRcdGlmIChkaWZmID09IDApIHtcblx0XHRcdFx0dG90YWwgPSB0aW1lbGluZXNSb3RhdGlvbltpXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkaWZmIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gZGlmZiAvIDM2MCkgfCAwKSkgKiAzNjA7XG5cdFx0XHRcdHZhciBsYXN0VG90YWwgPSAwLCBsYXN0RGlmZiA9IDA7XG5cdFx0XHRcdGlmIChmaXJzdEZyYW1lKSB7XG5cdFx0XHRcdFx0bGFzdFRvdGFsID0gMDtcblx0XHRcdFx0XHRsYXN0RGlmZiA9IGRpZmY7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGFzdFRvdGFsID0gdGltZWxpbmVzUm90YXRpb25baV07XG5cdFx0XHRcdFx0bGFzdERpZmYgPSB0aW1lbGluZXNSb3RhdGlvbltpICsgMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBkaWZmID4gMCwgZGlyID0gbGFzdFRvdGFsID49IDA7XG5cdFx0XHRcdGlmIChzcGluZS5NYXRoVXRpbHMuc2lnbnVtKGxhc3REaWZmKSAhPSBzcGluZS5NYXRoVXRpbHMuc2lnbnVtKGRpZmYpICYmIE1hdGguYWJzKGxhc3REaWZmKSA8PSA5MCkge1xuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhsYXN0VG90YWwpID4gMTgwKVxuXHRcdFx0XHRcdFx0bGFzdFRvdGFsICs9IDM2MCAqIHNwaW5lLk1hdGhVdGlscy5zaWdudW0obGFzdFRvdGFsKTtcblx0XHRcdFx0XHRkaXIgPSBjdXJyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvdGFsID0gZGlmZiArIGxhc3RUb3RhbCAtIGxhc3RUb3RhbCAlIDM2MDtcblx0XHRcdFx0aWYgKGRpciAhPSBjdXJyZW50KVxuXHRcdFx0XHRcdHRvdGFsICs9IDM2MCAqIHNwaW5lLk1hdGhVdGlscy5zaWdudW0obGFzdFRvdGFsKTtcblx0XHRcdFx0dGltZWxpbmVzUm90YXRpb25baV0gPSB0b3RhbDtcblx0XHRcdH1cblx0XHRcdHRpbWVsaW5lc1JvdGF0aW9uW2kgKyAxXSA9IGRpZmY7XG5cdFx0XHRyMSArPSB0b3RhbCAqIGFscGhhO1xuXHRcdFx0Ym9uZS5yb3RhdGlvbiA9IHIxIC0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByMSAvIDM2MCkgfCAwKSkgKiAzNjA7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUucXVldWVFdmVudHMgPSBmdW5jdGlvbiAoZW50cnksIGFuaW1hdGlvblRpbWUpIHtcblx0XHRcdHZhciBhbmltYXRpb25TdGFydCA9IGVudHJ5LmFuaW1hdGlvblN0YXJ0LCBhbmltYXRpb25FbmQgPSBlbnRyeS5hbmltYXRpb25FbmQ7XG5cdFx0XHR2YXIgZHVyYXRpb24gPSBhbmltYXRpb25FbmQgLSBhbmltYXRpb25TdGFydDtcblx0XHRcdHZhciB0cmFja0xhc3RXcmFwcGVkID0gZW50cnkudHJhY2tMYXN0ICUgZHVyYXRpb247XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG5cdFx0XHR2YXIgaSA9IDAsIG4gPSBldmVudHMubGVuZ3RoO1xuXHRcdFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGV2ZW50XzEgPSBldmVudHNbaV07XG5cdFx0XHRcdGlmIChldmVudF8xLnRpbWUgPCB0cmFja0xhc3RXcmFwcGVkKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRpZiAoZXZlbnRfMS50aW1lID4gYW5pbWF0aW9uRW5kKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR0aGlzLnF1ZXVlLmV2ZW50KGVudHJ5LCBldmVudF8xKTtcblx0XHRcdH1cblx0XHRcdGlmIChlbnRyeS5sb29wID8gKHRyYWNrTGFzdFdyYXBwZWQgPiBlbnRyeS50cmFja1RpbWUgJSBkdXJhdGlvbilcblx0XHRcdFx0OiAoYW5pbWF0aW9uVGltZSA+PSBhbmltYXRpb25FbmQgJiYgZW50cnkuYW5pbWF0aW9uTGFzdCA8IGFuaW1hdGlvbkVuZCkpIHtcblx0XHRcdFx0dGhpcy5xdWV1ZS5jb21wbGV0ZShlbnRyeSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZXZlbnRfMiA9IGV2ZW50c1tpXTtcblx0XHRcdFx0aWYgKGV2ZW50XzIudGltZSA8IGFuaW1hdGlvblN0YXJ0KVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR0aGlzLnF1ZXVlLmV2ZW50KGVudHJ5LCBldmVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9sZERyYWluRGlzYWJsZWQgPSB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQ7XG5cdFx0XHR0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdHRoaXMuY2xlYXJUcmFjayhpKTtcblx0XHRcdHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSBvbGREcmFpbkRpc2FibGVkO1xuXHRcdFx0dGhpcy5xdWV1ZS5kcmFpbigpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tJbmRleCkge1xuXHRcdFx0aWYgKHRyYWNrSW5kZXggPj0gdGhpcy50cmFja3MubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgY3VycmVudCA9IHRoaXMudHJhY2tzW3RyYWNrSW5kZXhdO1xuXHRcdFx0aWYgKGN1cnJlbnQgPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhpcy5xdWV1ZS5lbmQoY3VycmVudCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VOZXh0KGN1cnJlbnQpO1xuXHRcdFx0dmFyIGVudHJ5ID0gY3VycmVudDtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHZhciBmcm9tID0gZW50cnkubWl4aW5nRnJvbTtcblx0XHRcdFx0aWYgKGZyb20gPT0gbnVsbClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0dGhpcy5xdWV1ZS5lbmQoZnJvbSk7XG5cdFx0XHRcdGVudHJ5Lm1peGluZ0Zyb20gPSBudWxsO1xuXHRcdFx0XHRlbnRyeSA9IGZyb207XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyYWNrc1tjdXJyZW50LnRyYWNrSW5kZXhdID0gbnVsbDtcblx0XHRcdHRoaXMucXVldWUuZHJhaW4oKTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRDdXJyZW50ID0gZnVuY3Rpb24gKGluZGV4LCBjdXJyZW50LCBpbnRlcnJ1cHQpIHtcblx0XHRcdHZhciBmcm9tID0gdGhpcy5leHBhbmRUb0luZGV4KGluZGV4KTtcblx0XHRcdHRoaXMudHJhY2tzW2luZGV4XSA9IGN1cnJlbnQ7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChpbnRlcnJ1cHQpXG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS5pbnRlcnJ1cHQoZnJvbSk7XG5cdFx0XHRcdGN1cnJlbnQubWl4aW5nRnJvbSA9IGZyb207XG5cdFx0XHRcdGN1cnJlbnQubWl4VGltZSA9IDA7XG5cdFx0XHRcdGlmIChmcm9tLm1peGluZ0Zyb20gIT0gbnVsbCAmJiBmcm9tLm1peER1cmF0aW9uID4gMClcblx0XHRcdFx0XHRjdXJyZW50LmludGVycnVwdEFscGhhICo9IE1hdGgubWluKDEsIGZyb20ubWl4VGltZSAvIGZyb20ubWl4RHVyYXRpb24pO1xuXHRcdFx0XHRmcm9tLnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnF1ZXVlLnN0YXJ0KGN1cnJlbnQpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xuXHRcdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIGFuaW1hdGlvbk5hbWUpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0QW5pbWF0aW9uV2l0aCh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3ApO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEFuaW1hdGlvbldpdGggPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImFuaW1hdGlvbiBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR2YXIgaW50ZXJydXB0ID0gdHJ1ZTtcblx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5leHBhbmRUb0luZGV4KHRyYWNrSW5kZXgpO1xuXHRcdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoY3VycmVudC5uZXh0VHJhY2tMYXN0ID09IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy50cmFja3NbdHJhY2tJbmRleF0gPSBjdXJyZW50Lm1peGluZ0Zyb207XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS5pbnRlcnJ1cHQoY3VycmVudCk7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS5lbmQoY3VycmVudCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwb3NlTmV4dChjdXJyZW50KTtcblx0XHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5taXhpbmdGcm9tO1xuXHRcdFx0XHRcdGludGVycnVwdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLmRpc3Bvc2VOZXh0KGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy50cmFja0VudHJ5KHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgY3VycmVudCk7XG5cdFx0XHR0aGlzLnNldEN1cnJlbnQodHJhY2tJbmRleCwgZW50cnksIGludGVycnVwdCk7XG5cdFx0XHR0aGlzLnF1ZXVlLmRyYWluKCk7XG5cdFx0XHRyZXR1cm4gZW50cnk7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbk5hbWUsIGxvb3AsIGRlbGF5KSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xuXHRcdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIGFuaW1hdGlvbk5hbWUpO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQW5pbWF0aW9uV2l0aCh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGRlbGF5KTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRBbmltYXRpb25XaXRoID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgZGVsYXkpIHtcblx0XHRcdGlmIChhbmltYXRpb24gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYW5pbWF0aW9uIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBsYXN0ID0gdGhpcy5leHBhbmRUb0luZGV4KHRyYWNrSW5kZXgpO1xuXHRcdFx0aWYgKGxhc3QgIT0gbnVsbCkge1xuXHRcdFx0XHR3aGlsZSAobGFzdC5uZXh0ICE9IG51bGwpXG5cdFx0XHRcdFx0bGFzdCA9IGxhc3QubmV4dDtcblx0XHRcdH1cblx0XHRcdHZhciBlbnRyeSA9IHRoaXMudHJhY2tFbnRyeSh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGxhc3QpO1xuXHRcdFx0aWYgKGxhc3QgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNldEN1cnJlbnQodHJhY2tJbmRleCwgZW50cnksIHRydWUpO1xuXHRcdFx0XHR0aGlzLnF1ZXVlLmRyYWluKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGFzdC5uZXh0ID0gZW50cnk7XG5cdFx0XHRcdGlmIChkZWxheSA8PSAwKSB7XG5cdFx0XHRcdFx0dmFyIGR1cmF0aW9uID0gbGFzdC5hbmltYXRpb25FbmQgLSBsYXN0LmFuaW1hdGlvblN0YXJ0O1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiAhPSAwKVxuXHRcdFx0XHRcdFx0ZGVsYXkgKz0gZHVyYXRpb24gKiAoMSArICgobGFzdC50cmFja1RpbWUgLyBkdXJhdGlvbikgfCAwKSkgLSB0aGlzLmRhdGEuZ2V0TWl4KGxhc3QuYW5pbWF0aW9uLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGRlbGF5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZW50cnkuZGVsYXkgPSBkZWxheTtcblx0XHRcdHJldHVybiBlbnRyeTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRFbXB0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBtaXhEdXJhdGlvbikge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5zZXRBbmltYXRpb25XaXRoKHRyYWNrSW5kZXgsIEFuaW1hdGlvblN0YXRlLmVtcHR5QW5pbWF0aW9uLCBmYWxzZSk7XG5cdFx0XHRlbnRyeS5taXhEdXJhdGlvbiA9IG1peER1cmF0aW9uO1xuXHRcdFx0ZW50cnkudHJhY2tFbmQgPSBtaXhEdXJhdGlvbjtcblx0XHRcdHJldHVybiBlbnRyeTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRFbXB0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBtaXhEdXJhdGlvbiwgZGVsYXkpIHtcblx0XHRcdGlmIChkZWxheSA8PSAwKVxuXHRcdFx0XHRkZWxheSAtPSBtaXhEdXJhdGlvbjtcblx0XHRcdHZhciBlbnRyeSA9IHRoaXMuYWRkQW5pbWF0aW9uV2l0aCh0cmFja0luZGV4LCBBbmltYXRpb25TdGF0ZS5lbXB0eUFuaW1hdGlvbiwgZmFsc2UsIGRlbGF5KTtcblx0XHRcdGVudHJ5Lm1peER1cmF0aW9uID0gbWl4RHVyYXRpb247XG5cdFx0XHRlbnRyeS50cmFja0VuZCA9IG1peER1cmF0aW9uO1xuXHRcdFx0cmV0dXJuIGVudHJ5O1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEVtcHR5QW5pbWF0aW9ucyA9IGZ1bmN0aW9uIChtaXhEdXJhdGlvbikge1xuXHRcdFx0dmFyIG9sZERyYWluRGlzYWJsZWQgPSB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQ7XG5cdFx0XHR0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLnRyYWNrc1tpXTtcblx0XHRcdFx0aWYgKGN1cnJlbnQgIT0gbnVsbClcblx0XHRcdFx0XHR0aGlzLnNldEVtcHR5QW5pbWF0aW9uKGN1cnJlbnQudHJhY2tJbmRleCwgbWl4RHVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5xdWV1ZS5kcmFpbkRpc2FibGVkID0gb2xkRHJhaW5EaXNhYmxlZDtcblx0XHRcdHRoaXMucXVldWUuZHJhaW4oKTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5leHBhbmRUb0luZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRpZiAoaW5kZXggPCB0aGlzLnRyYWNrcy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiB0aGlzLnRyYWNrc1tpbmRleF07XG5cdFx0XHRzcGluZS5VdGlscy5lbnN1cmVBcnJheUNhcGFjaXR5KHRoaXMudHJhY2tzLCBpbmRleCAtIHRoaXMudHJhY2tzLmxlbmd0aCArIDEsIG51bGwpO1xuXHRcdFx0dGhpcy50cmFja3MubGVuZ3RoID0gaW5kZXggKyAxO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUudHJhY2tFbnRyeSA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGxhc3QpIHtcblx0XHRcdHZhciBlbnRyeSA9IHRoaXMudHJhY2tFbnRyeVBvb2wub2J0YWluKCk7XG5cdFx0XHRlbnRyeS50cmFja0luZGV4ID0gdHJhY2tJbmRleDtcblx0XHRcdGVudHJ5LmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcblx0XHRcdGVudHJ5Lmxvb3AgPSBsb29wO1xuXHRcdFx0ZW50cnkuZXZlbnRUaHJlc2hvbGQgPSAwO1xuXHRcdFx0ZW50cnkuYXR0YWNobWVudFRocmVzaG9sZCA9IDA7XG5cdFx0XHRlbnRyeS5kcmF3T3JkZXJUaHJlc2hvbGQgPSAwO1xuXHRcdFx0ZW50cnkuYW5pbWF0aW9uU3RhcnQgPSAwO1xuXHRcdFx0ZW50cnkuYW5pbWF0aW9uRW5kID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXHRcdFx0ZW50cnkuYW5pbWF0aW9uTGFzdCA9IC0xO1xuXHRcdFx0ZW50cnkubmV4dEFuaW1hdGlvbkxhc3QgPSAtMTtcblx0XHRcdGVudHJ5LmRlbGF5ID0gMDtcblx0XHRcdGVudHJ5LnRyYWNrVGltZSA9IDA7XG5cdFx0XHRlbnRyeS50cmFja0xhc3QgPSAtMTtcblx0XHRcdGVudHJ5Lm5leHRUcmFja0xhc3QgPSAtMTtcblx0XHRcdGVudHJ5LnRyYWNrRW5kID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdGVudHJ5LnRpbWVTY2FsZSA9IDE7XG5cdFx0XHRlbnRyeS5hbHBoYSA9IDE7XG5cdFx0XHRlbnRyeS5pbnRlcnJ1cHRBbHBoYSA9IDE7XG5cdFx0XHRlbnRyeS5taXhUaW1lID0gMDtcblx0XHRcdGVudHJ5Lm1peER1cmF0aW9uID0gbGFzdCA9PSBudWxsID8gMCA6IHRoaXMuZGF0YS5nZXRNaXgobGFzdC5hbmltYXRpb24sIGFuaW1hdGlvbik7XG5cdFx0XHRyZXR1cm4gZW50cnk7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuZGlzcG9zZU5leHQgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHRcdHZhciBuZXh0ID0gZW50cnkubmV4dDtcblx0XHRcdHdoaWxlIChuZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5xdWV1ZS5kaXNwb3NlKG5leHQpO1xuXHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0fVxuXHRcdFx0ZW50cnkubmV4dCA9IG51bGw7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuX2FuaW1hdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5hbmltYXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0dmFyIHByb3BlcnR5SURzID0gdGhpcy5wcm9wZXJ0eUlEcztcblx0XHRcdHByb3BlcnR5SURzLmNsZWFyKCk7XG5cdFx0XHR2YXIgbWl4aW5nVG8gPSB0aGlzLm1peGluZ1RvO1xuXHRcdFx0dmFyIGxhc3RFbnRyeSA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMudHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZW50cnkgPSB0aGlzLnRyYWNrc1tpXTtcblx0XHRcdFx0aWYgKGVudHJ5ICE9IG51bGwpIHtcblx0XHRcdFx0XHRlbnRyeS5zZXRUaW1lbGluZURhdGEobGFzdEVudHJ5LCBtaXhpbmdUbywgcHJvcGVydHlJRHMpO1xuXHRcdFx0XHRcdGxhc3RFbnRyeSA9IGVudHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICh0cmFja0luZGV4KSB7XG5cdFx0XHRpZiAodHJhY2tJbmRleCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhY2tzW3RyYWNrSW5kZXhdO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAobGlzdGVuZXIgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibGlzdGVuZXIgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcblx0XHRcdHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRcdFx0aWYgKGluZGV4ID49IDApXG5cdFx0XHRcdHRoaXMubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuY2xlYXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmxpc3RlbmVycy5sZW5ndGggPSAwO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyTGlzdGVuZXJOb3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5xdWV1ZS5jbGVhcigpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGUuZW1wdHlBbmltYXRpb24gPSBuZXcgc3BpbmUuQW5pbWF0aW9uKFwiPGVtcHR5PlwiLCBbXSwgMCk7XG5cdFx0QW5pbWF0aW9uU3RhdGUuU1VCU0VRVUVOVCA9IDA7XG5cdFx0QW5pbWF0aW9uU3RhdGUuRklSU1QgPSAxO1xuXHRcdEFuaW1hdGlvblN0YXRlLkRJUCA9IDI7XG5cdFx0QW5pbWF0aW9uU3RhdGUuRElQX01JWCA9IDM7XG5cdFx0cmV0dXJuIEFuaW1hdGlvblN0YXRlO1xuXHR9KCkpO1xuXHRzcGluZS5BbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlO1xuXHR2YXIgVHJhY2tFbnRyeSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVHJhY2tFbnRyeSgpIHtcblx0XHRcdHRoaXMudGltZWxpbmVEYXRhID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnRpbWVsaW5lRGlwTWl4ID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnRpbWVsaW5lc1JvdGF0aW9uID0gbmV3IEFycmF5KCk7XG5cdFx0fVxuXHRcdFRyYWNrRW50cnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHRcdHRoaXMubWl4aW5nRnJvbSA9IG51bGw7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbDtcblx0XHRcdHRoaXMudGltZWxpbmVEYXRhLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLnRpbWVsaW5lRGlwTWl4Lmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9IDA7XG5cdFx0fTtcblx0XHRUcmFja0VudHJ5LnByb3RvdHlwZS5zZXRUaW1lbGluZURhdGEgPSBmdW5jdGlvbiAodG8sIG1peGluZ1RvQXJyYXksIHByb3BlcnR5SURzKSB7XG5cdFx0XHRpZiAodG8gIT0gbnVsbClcblx0XHRcdFx0bWl4aW5nVG9BcnJheS5wdXNoKHRvKTtcblx0XHRcdHZhciBsYXN0RW50cnkgPSB0aGlzLm1peGluZ0Zyb20gIT0gbnVsbCA/IHRoaXMubWl4aW5nRnJvbS5zZXRUaW1lbGluZURhdGEodGhpcywgbWl4aW5nVG9BcnJheSwgcHJvcGVydHlJRHMpIDogdGhpcztcblx0XHRcdGlmICh0byAhPSBudWxsKVxuXHRcdFx0XHRtaXhpbmdUb0FycmF5LnBvcCgpO1xuXHRcdFx0dmFyIG1peGluZ1RvID0gbWl4aW5nVG9BcnJheTtcblx0XHRcdHZhciBtaXhpbmdUb0xhc3QgPSBtaXhpbmdUb0FycmF5Lmxlbmd0aCAtIDE7XG5cdFx0XHR2YXIgdGltZWxpbmVzID0gdGhpcy5hbmltYXRpb24udGltZWxpbmVzO1xuXHRcdFx0dmFyIHRpbWVsaW5lc0NvdW50ID0gdGhpcy5hbmltYXRpb24udGltZWxpbmVzLmxlbmd0aDtcblx0XHRcdHZhciB0aW1lbGluZURhdGEgPSBzcGluZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy50aW1lbGluZURhdGEsIHRpbWVsaW5lc0NvdW50KTtcblx0XHRcdHRoaXMudGltZWxpbmVEaXBNaXgubGVuZ3RoID0gMDtcblx0XHRcdHZhciB0aW1lbGluZURpcE1peCA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLnRpbWVsaW5lRGlwTWl4LCB0aW1lbGluZXNDb3VudCk7XG5cdFx0XHRvdXRlcjogZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZXNDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRpbWVsaW5lc1tpXS5nZXRQcm9wZXJ0eUlkKCk7XG5cdFx0XHRcdGlmICghcHJvcGVydHlJRHMuYWRkKGlkKSlcblx0XHRcdFx0XHR0aW1lbGluZURhdGFbaV0gPSBBbmltYXRpb25TdGF0ZS5TVUJTRVFVRU5UO1xuXHRcdFx0XHRlbHNlIGlmICh0byA9PSBudWxsIHx8ICF0by5oYXNUaW1lbGluZShpZCkpXG5cdFx0XHRcdFx0dGltZWxpbmVEYXRhW2ldID0gQW5pbWF0aW9uU3RhdGUuRklSU1Q7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGlpID0gbWl4aW5nVG9MYXN0OyBpaSA+PSAwOyBpaS0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgZW50cnkgPSBtaXhpbmdUb1tpaV07XG5cdFx0XHRcdFx0XHRpZiAoIWVudHJ5Lmhhc1RpbWVsaW5lKGlkKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZW50cnkubWl4RHVyYXRpb24gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGltZWxpbmVEYXRhW2ldID0gQW5pbWF0aW9uU3RhdGUuRElQX01JWDtcblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZURpcE1peFtpXSA9IGVudHJ5O1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlIG91dGVyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lRGF0YVtpXSA9IEFuaW1hdGlvblN0YXRlLkRJUDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxhc3RFbnRyeTtcblx0XHR9O1xuXHRcdFRyYWNrRW50cnkucHJvdG90eXBlLmhhc1RpbWVsaW5lID0gZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHR2YXIgdGltZWxpbmVzID0gdGhpcy5hbmltYXRpb24udGltZWxpbmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHRpZiAodGltZWxpbmVzW2ldLmdldFByb3BlcnR5SWQoKSA9PSBpZClcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFRyYWNrRW50cnkucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5sb29wKSB7XG5cdFx0XHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuYW5pbWF0aW9uRW5kIC0gdGhpcy5hbmltYXRpb25TdGFydDtcblx0XHRcdFx0aWYgKGR1cmF0aW9uID09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0aW9uU3RhcnQ7XG5cdFx0XHRcdHJldHVybiAodGhpcy50cmFja1RpbWUgJSBkdXJhdGlvbikgKyB0aGlzLmFuaW1hdGlvblN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1hdGgubWluKHRoaXMudHJhY2tUaW1lICsgdGhpcy5hbmltYXRpb25TdGFydCwgdGhpcy5hbmltYXRpb25FbmQpO1xuXHRcdH07XG5cdFx0VHJhY2tFbnRyeS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uTGFzdCA9IGZ1bmN0aW9uIChhbmltYXRpb25MYXN0KSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbkxhc3QgPSBhbmltYXRpb25MYXN0O1xuXHRcdFx0dGhpcy5uZXh0QW5pbWF0aW9uTGFzdCA9IGFuaW1hdGlvbkxhc3Q7XG5cdFx0fTtcblx0XHRUcmFja0VudHJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhY2tUaW1lID49IHRoaXMuYW5pbWF0aW9uRW5kIC0gdGhpcy5hbmltYXRpb25TdGFydDtcblx0XHR9O1xuXHRcdFRyYWNrRW50cnkucHJvdG90eXBlLnJlc2V0Um90YXRpb25EaXJlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPSAwO1xuXHRcdH07XG5cdFx0cmV0dXJuIFRyYWNrRW50cnk7XG5cdH0oKSk7XG5cdHNwaW5lLlRyYWNrRW50cnkgPSBUcmFja0VudHJ5O1xuXHR2YXIgRXZlbnRRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gRXZlbnRRdWV1ZShhbmltU3RhdGUpIHtcblx0XHRcdHRoaXMub2JqZWN0cyA9IFtdO1xuXHRcdFx0dGhpcy5kcmFpbkRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmFuaW1TdGF0ZSA9IGFuaW1TdGF0ZTtcblx0XHR9XG5cdFx0RXZlbnRRdWV1ZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5zdGFydCk7XG5cdFx0XHR0aGlzLm9iamVjdHMucHVzaChlbnRyeSk7XG5cdFx0XHR0aGlzLmFuaW1TdGF0ZS5hbmltYXRpb25zQ2hhbmdlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRFdmVudFF1ZXVlLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5pbnRlcnJ1cHQpO1xuXHRcdFx0dGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xuXHRcdH07XG5cdFx0RXZlbnRRdWV1ZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0XHR0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuZW5kKTtcblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcblx0XHRcdHRoaXMuYW5pbVN0YXRlLmFuaW1hdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcblx0XHR9O1xuXHRcdEV2ZW50UXVldWUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5kaXNwb3NlKTtcblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcblx0XHR9O1xuXHRcdEV2ZW50UXVldWUucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0XHR0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuY29tcGxldGUpO1xuXHRcdFx0dGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xuXHRcdH07XG5cdFx0RXZlbnRRdWV1ZS5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbiAoZW50cnksIGV2ZW50KSB7XG5cdFx0XHR0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuZXZlbnQpO1xuXHRcdFx0dGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xuXHRcdFx0dGhpcy5vYmplY3RzLnB1c2goZXZlbnQpO1xuXHRcdH07XG5cdFx0RXZlbnRRdWV1ZS5wcm90b3R5cGUuZHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5kcmFpbkRpc2FibGVkKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGlzLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0dmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5hbmltU3RhdGUubGlzdGVuZXJzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gb2JqZWN0c1tpXTtcblx0XHRcdFx0dmFyIGVudHJ5ID0gb2JqZWN0c1tpICsgMV07XG5cdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgRXZlbnRUeXBlLnN0YXJ0OlxuXHRcdFx0XHRcdFx0aWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuc3RhcnQpXG5cdFx0XHRcdFx0XHRcdGVudHJ5Lmxpc3RlbmVyLnN0YXJ0KGVudHJ5KTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxuXHRcdFx0XHRcdFx0XHRpZiAobGlzdGVuZXJzW2lpXS5zdGFydClcblx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaWldLnN0YXJ0KGVudHJ5KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgRXZlbnRUeXBlLmludGVycnVwdDpcblx0XHRcdFx0XHRcdGlmIChlbnRyeS5saXN0ZW5lciAhPSBudWxsICYmIGVudHJ5Lmxpc3RlbmVyLmludGVycnVwdClcblx0XHRcdFx0XHRcdFx0ZW50cnkubGlzdGVuZXIuaW50ZXJydXB0KGVudHJ5KTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxuXHRcdFx0XHRcdFx0XHRpZiAobGlzdGVuZXJzW2lpXS5pbnRlcnJ1cHQpXG5cdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2lpXS5pbnRlcnJ1cHQoZW50cnkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBFdmVudFR5cGUuZW5kOlxuXHRcdFx0XHRcdFx0aWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuZW5kKVxuXHRcdFx0XHRcdFx0XHRlbnRyeS5saXN0ZW5lci5lbmQoZW50cnkpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXG5cdFx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lcnNbaWldLmVuZClcblx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaWldLmVuZChlbnRyeSk7XG5cdFx0XHRcdFx0Y2FzZSBFdmVudFR5cGUuZGlzcG9zZTpcblx0XHRcdFx0XHRcdGlmIChlbnRyeS5saXN0ZW5lciAhPSBudWxsICYmIGVudHJ5Lmxpc3RlbmVyLmRpc3Bvc2UpXG5cdFx0XHRcdFx0XHRcdGVudHJ5Lmxpc3RlbmVyLmRpc3Bvc2UoZW50cnkpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXG5cdFx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lcnNbaWldLmRpc3Bvc2UpXG5cdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2lpXS5kaXNwb3NlKGVudHJ5KTtcblx0XHRcdFx0XHRcdHRoaXMuYW5pbVN0YXRlLnRyYWNrRW50cnlQb29sLmZyZWUoZW50cnkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBFdmVudFR5cGUuY29tcGxldGU6XG5cdFx0XHRcdFx0XHRpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5jb21wbGV0ZSlcblx0XHRcdFx0XHRcdFx0ZW50cnkubGlzdGVuZXIuY29tcGxldGUoZW50cnkpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXG5cdFx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lcnNbaWldLmNvbXBsZXRlKVxuXHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpaV0uY29tcGxldGUoZW50cnkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBFdmVudFR5cGUuZXZlbnQ6XG5cdFx0XHRcdFx0XHR2YXIgZXZlbnRfMyA9IG9iamVjdHNbaSsrICsgMl07XG5cdFx0XHRcdFx0XHRpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5ldmVudClcblx0XHRcdFx0XHRcdFx0ZW50cnkubGlzdGVuZXIuZXZlbnQoZW50cnksIGV2ZW50XzMpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXG5cdFx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lcnNbaWldLmV2ZW50KVxuXHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpaV0uZXZlbnQoZW50cnksIGV2ZW50XzMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuY2xlYXIoKTtcblx0XHRcdHRoaXMuZHJhaW5EaXNhYmxlZCA9IGZhbHNlO1xuXHRcdH07XG5cdFx0RXZlbnRRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLm9iamVjdHMubGVuZ3RoID0gMDtcblx0XHR9O1xuXHRcdHJldHVybiBFdmVudFF1ZXVlO1xuXHR9KCkpO1xuXHRzcGluZS5FdmVudFF1ZXVlID0gRXZlbnRRdWV1ZTtcblx0KGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcblx0XHRFdmVudFR5cGVbRXZlbnRUeXBlW1wic3RhcnRcIl0gPSAwXSA9IFwic3RhcnRcIjtcblx0XHRFdmVudFR5cGVbRXZlbnRUeXBlW1wiaW50ZXJydXB0XCJdID0gMV0gPSBcImludGVycnVwdFwiO1xuXHRcdEV2ZW50VHlwZVtFdmVudFR5cGVbXCJlbmRcIl0gPSAyXSA9IFwiZW5kXCI7XG5cdFx0RXZlbnRUeXBlW0V2ZW50VHlwZVtcImRpc3Bvc2VcIl0gPSAzXSA9IFwiZGlzcG9zZVwiO1xuXHRcdEV2ZW50VHlwZVtFdmVudFR5cGVbXCJjb21wbGV0ZVwiXSA9IDRdID0gXCJjb21wbGV0ZVwiO1xuXHRcdEV2ZW50VHlwZVtFdmVudFR5cGVbXCJldmVudFwiXSA9IDVdID0gXCJldmVudFwiO1xuXHR9KShzcGluZS5FdmVudFR5cGUgfHwgKHNwaW5lLkV2ZW50VHlwZSA9IHt9KSk7XG5cdHZhciBFdmVudFR5cGUgPSBzcGluZS5FdmVudFR5cGU7XG5cdHZhciBBbmltYXRpb25TdGF0ZUFkYXB0ZXIyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBBbmltYXRpb25TdGF0ZUFkYXB0ZXIyKCkge1xuXHRcdH1cblx0XHRBbmltYXRpb25TdGF0ZUFkYXB0ZXIyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChlbnRyeSkge1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uU3RhdGVBZGFwdGVyMi5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZUFkYXB0ZXIyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlQWRhcHRlcjIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZW50cnkpIHtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlQWRhcHRlcjIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZUFkYXB0ZXIyLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uIChlbnRyeSwgZXZlbnQpIHtcblx0XHR9O1xuXHRcdHJldHVybiBBbmltYXRpb25TdGF0ZUFkYXB0ZXIyO1xuXHR9KCkpO1xuXHRzcGluZS5BbmltYXRpb25TdGF0ZUFkYXB0ZXIyID0gQW5pbWF0aW9uU3RhdGVBZGFwdGVyMjtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBBbmltYXRpb25TdGF0ZURhdGEgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGF0YShza2VsZXRvbkRhdGEpIHtcblx0XHRcdHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lID0ge307XG5cdFx0XHR0aGlzLmRlZmF1bHRNaXggPSAwO1xuXHRcdFx0aWYgKHNrZWxldG9uRGF0YSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbkRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dGhpcy5za2VsZXRvbkRhdGEgPSBza2VsZXRvbkRhdGE7XG5cdFx0fVxuXHRcdEFuaW1hdGlvblN0YXRlRGF0YS5wcm90b3R5cGUuc2V0TWl4ID0gZnVuY3Rpb24gKGZyb21OYW1lLCB0b05hbWUsIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRoaXMuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oZnJvbU5hbWUpO1xuXHRcdFx0aWYgKGZyb20gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBmcm9tTmFtZSk7XG5cdFx0XHR2YXIgdG8gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKHRvTmFtZSk7XG5cdFx0XHRpZiAodG8gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyB0b05hbWUpO1xuXHRcdFx0dGhpcy5zZXRNaXhXaXRoKGZyb20sIHRvLCBkdXJhdGlvbik7XG5cdFx0fTtcblx0XHRBbmltYXRpb25TdGF0ZURhdGEucHJvdG90eXBlLnNldE1peFdpdGggPSBmdW5jdGlvbiAoZnJvbSwgdG8sIGR1cmF0aW9uKSB7XG5cdFx0XHRpZiAoZnJvbSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJmcm9tIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdGlmICh0byA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0byBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR2YXIga2V5ID0gZnJvbS5uYW1lICsgdG8ubmFtZTtcblx0XHRcdHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lW2tleV0gPSBkdXJhdGlvbjtcblx0XHR9O1xuXHRcdEFuaW1hdGlvblN0YXRlRGF0YS5wcm90b3R5cGUuZ2V0TWl4ID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG5cdFx0XHR2YXIga2V5ID0gZnJvbS5uYW1lICsgdG8ubmFtZTtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lW2tleV07XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdE1peCA6IHZhbHVlO1xuXHRcdH07XG5cdFx0cmV0dXJuIEFuaW1hdGlvblN0YXRlRGF0YTtcblx0fSgpKTtcblx0c3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhID0gQW5pbWF0aW9uU3RhdGVEYXRhO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIEFzc2V0TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gQXNzZXRNYW5hZ2VyKHRleHR1cmVMb2FkZXIsIHBhdGhQcmVmaXgpIHtcblx0XHRcdGlmIChwYXRoUHJlZml4ID09PSB2b2lkIDApIHsgcGF0aFByZWZpeCA9IFwiXCI7IH1cblx0XHRcdHRoaXMuYXNzZXRzID0ge307XG5cdFx0XHR0aGlzLmVycm9ycyA9IHt9O1xuXHRcdFx0dGhpcy50b0xvYWQgPSAwO1xuXHRcdFx0dGhpcy5sb2FkZWQgPSAwO1xuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gdGV4dHVyZUxvYWRlcjtcblx0XHRcdHRoaXMucGF0aFByZWZpeCA9IHBhdGhQcmVmaXg7XG5cdFx0fVxuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUubG9hZFRleHQgPSBmdW5jdGlvbiAocGF0aCwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRpZiAoc3VjY2VzcyA9PT0gdm9pZCAwKSB7IHN1Y2Nlc3MgPSBudWxsOyB9XG5cdFx0XHRpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cblx0XHRcdHBhdGggPSB0aGlzLnBhdGhQcmVmaXggKyBwYXRoO1xuXHRcdFx0dGhpcy50b0xvYWQrKztcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG5cdFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDMwMCkge1xuXHRcdFx0XHRcdFx0X3RoaXMuYXNzZXRzW3BhdGhdID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRpZiAoc3VjY2Vzcylcblx0XHRcdFx0XHRcdFx0c3VjY2VzcyhwYXRoLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X3RoaXMuZXJyb3JzW3BhdGhdID0gXCJDb3VsZG4ndCBsb2FkIHRleHQgXCIgKyBwYXRoICsgXCI6IHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIsIFwiICsgcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRpZiAoZXJyb3IpXG5cdFx0XHRcdFx0XHRcdGVycm9yKHBhdGgsIFwiQ291bGRuJ3QgbG9hZCB0ZXh0IFwiICsgcGF0aCArIFwiOiBzdGF0dXMgXCIgKyByZXF1ZXN0LnN0YXR1cyArIFwiLCBcIiArIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3RoaXMudG9Mb2FkLS07XG5cdFx0XHRcdFx0X3RoaXMubG9hZGVkKys7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcGF0aCwgdHJ1ZSk7XG5cdFx0XHRyZXF1ZXN0LnNlbmQoKTtcblx0XHR9O1xuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUubG9hZFRleHR1cmUgPSBmdW5jdGlvbiAocGF0aCwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRpZiAoc3VjY2VzcyA9PT0gdm9pZCAwKSB7IHN1Y2Nlc3MgPSBudWxsOyB9XG5cdFx0XHRpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cblx0XHRcdHBhdGggPSB0aGlzLnBhdGhQcmVmaXggKyBwYXRoO1xuXHRcdFx0dGhpcy50b0xvYWQrKztcblx0XHRcdHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG5cdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gX3RoaXMudGV4dHVyZUxvYWRlcihpbWcpO1xuXHRcdFx0XHRfdGhpcy5hc3NldHNbcGF0aF0gPSB0ZXh0dXJlO1xuXHRcdFx0XHRfdGhpcy50b0xvYWQtLTtcblx0XHRcdFx0X3RoaXMubG9hZGVkKys7XG5cdFx0XHRcdGlmIChzdWNjZXNzKVxuXHRcdFx0XHRcdHN1Y2Nlc3MocGF0aCwgaW1nKTtcblx0XHRcdH07XG5cdFx0XHRpbWcub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHRfdGhpcy5lcnJvcnNbcGF0aF0gPSBcIkNvdWxkbid0IGxvYWQgaW1hZ2UgXCIgKyBwYXRoO1xuXHRcdFx0XHRfdGhpcy50b0xvYWQtLTtcblx0XHRcdFx0X3RoaXMubG9hZGVkKys7XG5cdFx0XHRcdGlmIChlcnJvcilcblx0XHRcdFx0XHRlcnJvcihwYXRoLCBcIkNvdWxkbid0IGxvYWQgaW1hZ2UgXCIgKyBwYXRoKTtcblx0XHRcdH07XG5cdFx0XHRpbWcuc3JjID0gcGF0aDtcblx0XHR9O1xuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUubG9hZFRleHR1cmVEYXRhID0gZnVuY3Rpb24gKHBhdGgsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0aWYgKHN1Y2Nlc3MgPT09IHZvaWQgMCkgeyBzdWNjZXNzID0gbnVsbDsgfVxuXHRcdFx0aWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBudWxsOyB9XG5cdFx0XHRwYXRoID0gdGhpcy5wYXRoUHJlZml4ICsgcGF0aDtcblx0XHRcdHRoaXMudG9Mb2FkKys7XG5cdFx0XHR2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gX3RoaXMudGV4dHVyZUxvYWRlcihpbWcpO1xuXHRcdFx0XHRfdGhpcy5hc3NldHNbcGF0aF0gPSB0ZXh0dXJlO1xuXHRcdFx0XHRfdGhpcy50b0xvYWQtLTtcblx0XHRcdFx0X3RoaXMubG9hZGVkKys7XG5cdFx0XHRcdGlmIChzdWNjZXNzKVxuXHRcdFx0XHRcdHN1Y2Nlc3MocGF0aCwgaW1nKTtcblx0XHRcdH07XG5cdFx0XHRpbWcub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHRfdGhpcy5lcnJvcnNbcGF0aF0gPSBcIkNvdWxkbid0IGxvYWQgaW1hZ2UgXCIgKyBwYXRoO1xuXHRcdFx0XHRfdGhpcy50b0xvYWQtLTtcblx0XHRcdFx0X3RoaXMubG9hZGVkKys7XG5cdFx0XHRcdGlmIChlcnJvcilcblx0XHRcdFx0XHRlcnJvcihwYXRoLCBcIkNvdWxkbid0IGxvYWQgaW1hZ2UgXCIgKyBwYXRoKTtcblx0XHRcdH07XG5cdFx0XHRpbWcuc3JjID0gZGF0YTtcblx0XHR9O1xuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdHBhdGggPSB0aGlzLnBhdGhQcmVmaXggKyBwYXRoO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXNzZXRzW3BhdGhdO1xuXHRcdH07XG5cdFx0QXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0cGF0aCA9IHRoaXMucGF0aFByZWZpeCArIHBhdGg7XG5cdFx0XHR2YXIgYXNzZXQgPSB0aGlzLmFzc2V0c1twYXRoXTtcblx0XHRcdGlmIChhc3NldC5kaXNwb3NlKVxuXHRcdFx0XHRhc3NldC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmFzc2V0c1twYXRoXSA9IG51bGw7XG5cdFx0fTtcblx0XHRBc3NldE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB0aGlzLmFzc2V0cykge1xuXHRcdFx0XHR2YXIgYXNzZXQgPSB0aGlzLmFzc2V0c1trZXldO1xuXHRcdFx0XHRpZiAoYXNzZXQuZGlzcG9zZSlcblx0XHRcdFx0XHRhc3NldC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFzc2V0cyA9IHt9O1xuXHRcdH07XG5cdFx0QXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5pc0xvYWRpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvTG9hZCA9PSAwO1xuXHRcdH07XG5cdFx0QXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRUb0xvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b0xvYWQ7XG5cdFx0fTtcblx0XHRBc3NldE1hbmFnZXIucHJvdG90eXBlLmdldExvYWRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmxvYWRlZDtcblx0XHR9O1xuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucmVtb3ZlQWxsKCk7XG5cdFx0fTtcblx0XHRBc3NldE1hbmFnZXIucHJvdG90eXBlLmhhc0Vycm9ycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmVycm9ycykubGVuZ3RoID4gMDtcblx0XHR9O1xuXHRcdEFzc2V0TWFuYWdlci5wcm90b3R5cGUuZ2V0RXJyb3JzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZXJyb3JzO1xuXHRcdH07XG5cdFx0cmV0dXJuIEFzc2V0TWFuYWdlcjtcblx0fSgpKTtcblx0c3BpbmUuQXNzZXRNYW5hZ2VyID0gQXNzZXRNYW5hZ2VyO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIEF0bGFzQXR0YWNobWVudExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gQXRsYXNBdHRhY2htZW50TG9hZGVyKGF0bGFzKSB7XG5cdFx0XHR0aGlzLmF0bGFzID0gYXRsYXM7XG5cdFx0fVxuXHRcdEF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUubmV3UmVnaW9uQXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKSB7XG5cdFx0XHR2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xuXHRcdFx0aWYgKHJlZ2lvbiA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb24gbm90IGZvdW5kIGluIGF0bGFzOiBcIiArIHBhdGggKyBcIiAocmVnaW9uIGF0dGFjaG1lbnQ6IFwiICsgbmFtZSArIFwiKVwiKTtcblx0XHRcdHJlZ2lvbi5yZW5kZXJPYmplY3QgPSByZWdpb247XG5cdFx0XHR2YXIgYXR0YWNobWVudCA9IG5ldyBzcGluZS5SZWdpb25BdHRhY2htZW50KG5hbWUpO1xuXHRcdFx0YXR0YWNobWVudC5zZXRSZWdpb24ocmVnaW9uKTtcblx0XHRcdHJldHVybiBhdHRhY2htZW50O1xuXHRcdH07XG5cdFx0QXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdNZXNoQXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKSB7XG5cdFx0XHR2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xuXHRcdFx0aWYgKHJlZ2lvbiA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb24gbm90IGZvdW5kIGluIGF0bGFzOiBcIiArIHBhdGggKyBcIiAobWVzaCBhdHRhY2htZW50OiBcIiArIG5hbWUgKyBcIilcIik7XG5cdFx0XHRyZWdpb24ucmVuZGVyT2JqZWN0ID0gcmVnaW9uO1xuXHRcdFx0dmFyIGF0dGFjaG1lbnQgPSBuZXcgc3BpbmUuTWVzaEF0dGFjaG1lbnQobmFtZSk7XG5cdFx0XHRhdHRhY2htZW50LnJlZ2lvbiA9IHJlZ2lvbjtcblx0XHRcdHJldHVybiBhdHRhY2htZW50O1xuXHRcdH07XG5cdFx0QXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdCb3VuZGluZ0JveEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2tpbiwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBzcGluZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQobmFtZSk7XG5cdFx0fTtcblx0XHRBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld1BhdGhBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUpIHtcblx0XHRcdHJldHVybiBuZXcgc3BpbmUuUGF0aEF0dGFjaG1lbnQobmFtZSk7XG5cdFx0fTtcblx0XHRBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld1BvaW50QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHNwaW5lLlBvaW50QXR0YWNobWVudChuYW1lKTtcblx0XHR9O1xuXHRcdEF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUubmV3Q2xpcHBpbmdBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUpIHtcblx0XHRcdHJldHVybiBuZXcgc3BpbmUuQ2xpcHBpbmdBdHRhY2htZW50KG5hbWUpO1xuXHRcdH07XG5cdFx0cmV0dXJuIEF0bGFzQXR0YWNobWVudExvYWRlcjtcblx0fSgpKTtcblx0c3BpbmUuQXRsYXNBdHRhY2htZW50TG9hZGVyID0gQXRsYXNBdHRhY2htZW50TG9hZGVyO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEF0dGFjaG1lbnQobmFtZSkge1xuXHRcdFx0aWYgKG5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdH1cblx0XHRyZXR1cm4gQXR0YWNobWVudDtcblx0fSgpKTtcblx0c3BpbmUuQXR0YWNobWVudCA9IEF0dGFjaG1lbnQ7XG5cdHZhciBWZXJ0ZXhBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoVmVydGV4QXR0YWNobWVudCwgX3N1cGVyKTtcblx0XHRmdW5jdGlvbiBWZXJ0ZXhBdHRhY2htZW50KG5hbWUpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuXHRcdFx0dGhpcy5pZCA9IChWZXJ0ZXhBdHRhY2htZW50Lm5leHRJRCsrICYgNjU1MzUpIDw8IDExO1xuXHRcdFx0dGhpcy53b3JsZFZlcnRpY2VzTGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0VmVydGV4QXR0YWNobWVudC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbiAoc2xvdCwgc3RhcnQsIGNvdW50LCB3b3JsZFZlcnRpY2VzLCBvZmZzZXQsIHN0cmlkZSkge1xuXHRcdFx0Y291bnQgPSBvZmZzZXQgKyAoY291bnQgPj4gMSkgKiBzdHJpZGU7XG5cdFx0XHR2YXIgc2tlbGV0b24gPSBzbG90LmJvbmUuc2tlbGV0b247XG5cdFx0XHR2YXIgZGVmb3JtQXJyYXkgPSBzbG90LmF0dGFjaG1lbnRWZXJ0aWNlcztcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0aWYgKGJvbmVzID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGRlZm9ybUFycmF5Lmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0dmVydGljZXMgPSBkZWZvcm1BcnJheTtcblx0XHRcdFx0dmFyIGJvbmUgPSBzbG90LmJvbmU7XG5cdFx0XHRcdHZhciB4ID0gYm9uZS53b3JsZFg7XG5cdFx0XHRcdHZhciB5ID0gYm9uZS53b3JsZFk7XG5cdFx0XHRcdHZhciBhID0gYm9uZS5hLCBiID0gYm9uZS5iLCBjID0gYm9uZS5jLCBkID0gYm9uZS5kO1xuXHRcdFx0XHRmb3IgKHZhciB2XzEgPSBzdGFydCwgdyA9IG9mZnNldDsgdyA8IGNvdW50OyB2XzEgKz0gMiwgdyArPSBzdHJpZGUpIHtcblx0XHRcdFx0XHR2YXIgdnggPSB2ZXJ0aWNlc1t2XzFdLCB2eSA9IHZlcnRpY2VzW3ZfMSArIDFdO1xuXHRcdFx0XHRcdHdvcmxkVmVydGljZXNbd10gPSB2eCAqIGEgKyB2eSAqIGIgKyB4O1xuXHRcdFx0XHRcdHdvcmxkVmVydGljZXNbdyArIDFdID0gdnggKiBjICsgdnkgKiBkICsgeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdiA9IDAsIHNraXAgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydDsgaSArPSAyKSB7XG5cdFx0XHRcdHZhciBuID0gYm9uZXNbdl07XG5cdFx0XHRcdHYgKz0gbiArIDE7XG5cdFx0XHRcdHNraXAgKz0gbjtcblx0XHRcdH1cblx0XHRcdHZhciBza2VsZXRvbkJvbmVzID0gc2tlbGV0b24uYm9uZXM7XG5cdFx0XHRpZiAoZGVmb3JtQXJyYXkubGVuZ3RoID09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgdyA9IG9mZnNldCwgYiA9IHNraXAgKiAzOyB3IDwgY291bnQ7IHcgKz0gc3RyaWRlKSB7XG5cdFx0XHRcdFx0dmFyIHd4ID0gMCwgd3kgPSAwO1xuXHRcdFx0XHRcdHZhciBuID0gYm9uZXNbdisrXTtcblx0XHRcdFx0XHRuICs9IHY7XG5cdFx0XHRcdFx0Zm9yICg7IHYgPCBuOyB2KyssIGIgKz0gMykge1xuXHRcdFx0XHRcdFx0dmFyIGJvbmUgPSBza2VsZXRvbkJvbmVzW2JvbmVzW3ZdXTtcblx0XHRcdFx0XHRcdHZhciB2eCA9IHZlcnRpY2VzW2JdLCB2eSA9IHZlcnRpY2VzW2IgKyAxXSwgd2VpZ2h0ID0gdmVydGljZXNbYiArIDJdO1xuXHRcdFx0XHRcdFx0d3ggKz0gKHZ4ICogYm9uZS5hICsgdnkgKiBib25lLmIgKyBib25lLndvcmxkWCkgKiB3ZWlnaHQ7XG5cdFx0XHRcdFx0XHR3eSArPSAodnggKiBib25lLmMgKyB2eSAqIGJvbmUuZCArIGJvbmUud29ybGRZKSAqIHdlaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d29ybGRWZXJ0aWNlc1t3XSA9IHd4O1xuXHRcdFx0XHRcdHdvcmxkVmVydGljZXNbdyArIDFdID0gd3k7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgZGVmb3JtID0gZGVmb3JtQXJyYXk7XG5cdFx0XHRcdGZvciAodmFyIHcgPSBvZmZzZXQsIGIgPSBza2lwICogMywgZiA9IHNraXAgPDwgMTsgdyA8IGNvdW50OyB3ICs9IHN0cmlkZSkge1xuXHRcdFx0XHRcdHZhciB3eCA9IDAsIHd5ID0gMDtcblx0XHRcdFx0XHR2YXIgbiA9IGJvbmVzW3YrK107XG5cdFx0XHRcdFx0biArPSB2O1xuXHRcdFx0XHRcdGZvciAoOyB2IDwgbjsgdisrLCBiICs9IDMsIGYgKz0gMikge1xuXHRcdFx0XHRcdFx0dmFyIGJvbmUgPSBza2VsZXRvbkJvbmVzW2JvbmVzW3ZdXTtcblx0XHRcdFx0XHRcdHZhciB2eCA9IHZlcnRpY2VzW2JdICsgZGVmb3JtW2ZdLCB2eSA9IHZlcnRpY2VzW2IgKyAxXSArIGRlZm9ybVtmICsgMV0sIHdlaWdodCA9IHZlcnRpY2VzW2IgKyAyXTtcblx0XHRcdFx0XHRcdHd4ICs9ICh2eCAqIGJvbmUuYSArIHZ5ICogYm9uZS5iICsgYm9uZS53b3JsZFgpICogd2VpZ2h0O1xuXHRcdFx0XHRcdFx0d3kgKz0gKHZ4ICogYm9uZS5jICsgdnkgKiBib25lLmQgKyBib25lLndvcmxkWSkgKiB3ZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdvcmxkVmVydGljZXNbd10gPSB3eDtcblx0XHRcdFx0XHR3b3JsZFZlcnRpY2VzW3cgKyAxXSA9IHd5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRWZXJ0ZXhBdHRhY2htZW50LnByb3RvdHlwZS5hcHBseURlZm9ybSA9IGZ1bmN0aW9uIChzb3VyY2VBdHRhY2htZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcyA9PSBzb3VyY2VBdHRhY2htZW50O1xuXHRcdH07XG5cdFx0VmVydGV4QXR0YWNobWVudC5uZXh0SUQgPSAwO1xuXHRcdHJldHVybiBWZXJ0ZXhBdHRhY2htZW50O1xuXHR9KEF0dGFjaG1lbnQpKTtcblx0c3BpbmUuVmVydGV4QXR0YWNobWVudCA9IFZlcnRleEF0dGFjaG1lbnQ7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHQoZnVuY3Rpb24gKEF0dGFjaG1lbnRUeXBlKSB7XG5cdFx0QXR0YWNobWVudFR5cGVbQXR0YWNobWVudFR5cGVbXCJSZWdpb25cIl0gPSAwXSA9IFwiUmVnaW9uXCI7XG5cdFx0QXR0YWNobWVudFR5cGVbQXR0YWNobWVudFR5cGVbXCJCb3VuZGluZ0JveFwiXSA9IDFdID0gXCJCb3VuZGluZ0JveFwiO1xuXHRcdEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiTWVzaFwiXSA9IDJdID0gXCJNZXNoXCI7XG5cdFx0QXR0YWNobWVudFR5cGVbQXR0YWNobWVudFR5cGVbXCJMaW5rZWRNZXNoXCJdID0gM10gPSBcIkxpbmtlZE1lc2hcIjtcblx0XHRBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIlBhdGhcIl0gPSA0XSA9IFwiUGF0aFwiO1xuXHRcdEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiUG9pbnRcIl0gPSA1XSA9IFwiUG9pbnRcIjtcblx0fSkoc3BpbmUuQXR0YWNobWVudFR5cGUgfHwgKHNwaW5lLkF0dGFjaG1lbnRUeXBlID0ge30pKTtcblx0dmFyIEF0dGFjaG1lbnRUeXBlID0gc3BpbmUuQXR0YWNobWVudFR5cGU7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgQm91bmRpbmdCb3hBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoQm91bmRpbmdCb3hBdHRhY2htZW50LCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIEJvdW5kaW5nQm94QXR0YWNobWVudChuYW1lKSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMSwgMSwgMSwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiBCb3VuZGluZ0JveEF0dGFjaG1lbnQ7XG5cdH0oc3BpbmUuVmVydGV4QXR0YWNobWVudCkpO1xuXHRzcGluZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQgPSBCb3VuZGluZ0JveEF0dGFjaG1lbnQ7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgQ2xpcHBpbmdBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoQ2xpcHBpbmdBdHRhY2htZW50LCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIENsaXBwaW5nQXR0YWNobWVudChuYW1lKSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMC4yMjc1LCAwLjIyNzUsIDAuODA3OCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiBDbGlwcGluZ0F0dGFjaG1lbnQ7XG5cdH0oc3BpbmUuVmVydGV4QXR0YWNobWVudCkpO1xuXHRzcGluZS5DbGlwcGluZ0F0dGFjaG1lbnQgPSBDbGlwcGluZ0F0dGFjaG1lbnQ7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgTWVzaEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhNZXNoQXR0YWNobWVudCwgX3N1cGVyKTtcblx0XHRmdW5jdGlvbiBNZXNoQXR0YWNobWVudChuYW1lKSB7XG5cdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMSwgMSwgMSwgMSk7XG5cdFx0XHR0aGlzLmluaGVyaXREZWZvcm0gPSBmYWxzZTtcblx0XHRcdHRoaXMudGVtcENvbG9yID0gbmV3IHNwaW5lLkNvbG9yKDAsIDAsIDAsIDApO1xuXHRcdH1cblx0XHRNZXNoQXR0YWNobWVudC5wcm90b3R5cGUudXBkYXRlVVZzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHUgPSAwLCB2ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xuXHRcdFx0aWYgKHRoaXMucmVnaW9uID09IG51bGwpIHtcblx0XHRcdFx0dSA9IHYgPSAwO1xuXHRcdFx0XHR3aWR0aCA9IGhlaWdodCA9IDE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dSA9IHRoaXMucmVnaW9uLnU7XG5cdFx0XHRcdHYgPSB0aGlzLnJlZ2lvbi52O1xuXHRcdFx0XHR3aWR0aCA9IHRoaXMucmVnaW9uLnUyIC0gdTtcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5yZWdpb24udjIgLSB2O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlZ2lvblVWcyA9IHRoaXMucmVnaW9uVVZzO1xuXHRcdFx0aWYgKHRoaXMudXZzID09IG51bGwgfHwgdGhpcy51dnMubGVuZ3RoICE9IHJlZ2lvblVWcy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMudXZzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheShyZWdpb25VVnMubGVuZ3RoKTtcblx0XHRcdHZhciB1dnMgPSB0aGlzLnV2cztcblx0XHRcdGlmICh0aGlzLnJlZ2lvbi5yb3RhdGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB1dnMubGVuZ3RoOyBpIDwgbjsgaSArPSAyKSB7XG5cdFx0XHRcdFx0dXZzW2ldID0gdSArIHJlZ2lvblVWc1tpICsgMV0gKiB3aWR0aDtcblx0XHRcdFx0XHR1dnNbaSArIDFdID0gdiArIGhlaWdodCAtIHJlZ2lvblVWc1tpXSAqIGhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdXZzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuXHRcdFx0XHRcdHV2c1tpXSA9IHUgKyByZWdpb25VVnNbaV0gKiB3aWR0aDtcblx0XHRcdFx0XHR1dnNbaSArIDFdID0gdiArIHJlZ2lvblVWc1tpICsgMV0gKiBoZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdE1lc2hBdHRhY2htZW50LnByb3RvdHlwZS5hcHBseURlZm9ybSA9IGZ1bmN0aW9uIChzb3VyY2VBdHRhY2htZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcyA9PSBzb3VyY2VBdHRhY2htZW50IHx8ICh0aGlzLmluaGVyaXREZWZvcm0gJiYgdGhpcy5wYXJlbnRNZXNoID09IHNvdXJjZUF0dGFjaG1lbnQpO1xuXHRcdH07XG5cdFx0TWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLmdldFBhcmVudE1lc2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRNZXNoO1xuXHRcdH07XG5cdFx0TWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLnNldFBhcmVudE1lc2ggPSBmdW5jdGlvbiAocGFyZW50TWVzaCkge1xuXHRcdFx0dGhpcy5wYXJlbnRNZXNoID0gcGFyZW50TWVzaDtcblx0XHRcdGlmIChwYXJlbnRNZXNoICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5ib25lcyA9IHBhcmVudE1lc2guYm9uZXM7XG5cdFx0XHRcdHRoaXMudmVydGljZXMgPSBwYXJlbnRNZXNoLnZlcnRpY2VzO1xuXHRcdFx0XHR0aGlzLndvcmxkVmVydGljZXNMZW5ndGggPSBwYXJlbnRNZXNoLndvcmxkVmVydGljZXNMZW5ndGg7XG5cdFx0XHRcdHRoaXMucmVnaW9uVVZzID0gcGFyZW50TWVzaC5yZWdpb25VVnM7XG5cdFx0XHRcdHRoaXMudHJpYW5nbGVzID0gcGFyZW50TWVzaC50cmlhbmdsZXM7XG5cdFx0XHRcdHRoaXMuaHVsbExlbmd0aCA9IHBhcmVudE1lc2guaHVsbExlbmd0aDtcblx0XHRcdFx0dGhpcy53b3JsZFZlcnRpY2VzTGVuZ3RoID0gcGFyZW50TWVzaC53b3JsZFZlcnRpY2VzTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE1lc2hBdHRhY2htZW50O1xuXHR9KHNwaW5lLlZlcnRleEF0dGFjaG1lbnQpKTtcblx0c3BpbmUuTWVzaEF0dGFjaG1lbnQgPSBNZXNoQXR0YWNobWVudDtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBQYXRoQXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKFBhdGhBdHRhY2htZW50LCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIFBhdGhBdHRhY2htZW50KG5hbWUpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuXHRcdFx0dGhpcy5jbG9zZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuY29uc3RhbnRTcGVlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBzcGluZS5Db2xvcigxLCAxLCAxLCAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIFBhdGhBdHRhY2htZW50O1xuXHR9KHNwaW5lLlZlcnRleEF0dGFjaG1lbnQpKTtcblx0c3BpbmUuUGF0aEF0dGFjaG1lbnQgPSBQYXRoQXR0YWNobWVudDtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBQb2ludEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhQb2ludEF0dGFjaG1lbnQsIF9zdXBlcik7XG5cdFx0ZnVuY3Rpb24gUG9pbnRBdHRhY2htZW50KG5hbWUpIHtcblx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBzcGluZS5Db2xvcigwLjM4LCAwLjk0LCAwLCAxKTtcblx0XHR9XG5cdFx0UG9pbnRBdHRhY2htZW50LnByb3RvdHlwZS5jb21wdXRlV29ybGRQb3NpdGlvbiA9IGZ1bmN0aW9uIChib25lLCBwb2ludCkge1xuXHRcdFx0cG9pbnQueCA9IHRoaXMueCAqIGJvbmUuYSArIHRoaXMueSAqIGJvbmUuYiArIGJvbmUud29ybGRYO1xuXHRcdFx0cG9pbnQueSA9IHRoaXMueCAqIGJvbmUuYyArIHRoaXMueSAqIGJvbmUuZCArIGJvbmUud29ybGRZO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH07XG5cdFx0UG9pbnRBdHRhY2htZW50LnByb3RvdHlwZS5jb21wdXRlV29ybGRSb3RhdGlvbiA9IGZ1bmN0aW9uIChib25lKSB7XG5cdFx0XHR2YXIgY29zID0gc3BpbmUuTWF0aFV0aWxzLmNvc0RlZyh0aGlzLnJvdGF0aW9uKSwgc2luID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyh0aGlzLnJvdGF0aW9uKTtcblx0XHRcdHZhciB4ID0gY29zICogYm9uZS5hICsgc2luICogYm9uZS5iO1xuXHRcdFx0dmFyIHkgPSBjb3MgKiBib25lLmMgKyBzaW4gKiBib25lLmQ7XG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWc7XG5cdFx0fTtcblx0XHRyZXR1cm4gUG9pbnRBdHRhY2htZW50O1xuXHR9KHNwaW5lLlZlcnRleEF0dGFjaG1lbnQpKTtcblx0c3BpbmUuUG9pbnRBdHRhY2htZW50ID0gUG9pbnRBdHRhY2htZW50O1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFJlZ2lvbkF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhSZWdpb25BdHRhY2htZW50LCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIFJlZ2lvbkF0dGFjaG1lbnQobmFtZSkge1xuXHRcdFx0X3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG5cdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdHRoaXMuc2NhbGVYID0gMTtcblx0XHRcdHRoaXMuc2NhbGVZID0gMTtcblx0XHRcdHRoaXMucm90YXRpb24gPSAwO1xuXHRcdFx0dGhpcy53aWR0aCA9IDA7XG5cdFx0XHR0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IHNwaW5lLkNvbG9yKDEsIDEsIDEsIDEpO1xuXHRcdFx0dGhpcy5vZmZzZXQgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KDgpO1xuXHRcdFx0dGhpcy51dnMgPSBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KDgpO1xuXHRcdFx0dGhpcy50ZW1wQ29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMSwgMSwgMSwgMSk7XG5cdFx0fVxuXHRcdFJlZ2lvbkF0dGFjaG1lbnQucHJvdG90eXBlLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByZWdpb25TY2FsZVggPSB0aGlzLndpZHRoIC8gdGhpcy5yZWdpb24ub3JpZ2luYWxXaWR0aCAqIHRoaXMuc2NhbGVYO1xuXHRcdFx0dmFyIHJlZ2lvblNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gdGhpcy5yZWdpb24ub3JpZ2luYWxIZWlnaHQgKiB0aGlzLnNjYWxlWTtcblx0XHRcdHZhciBsb2NhbFggPSAtdGhpcy53aWR0aCAvIDIgKiB0aGlzLnNjYWxlWCArIHRoaXMucmVnaW9uLm9mZnNldFggKiByZWdpb25TY2FsZVg7XG5cdFx0XHR2YXIgbG9jYWxZID0gLXRoaXMuaGVpZ2h0IC8gMiAqIHRoaXMuc2NhbGVZICsgdGhpcy5yZWdpb24ub2Zmc2V0WSAqIHJlZ2lvblNjYWxlWTtcblx0XHRcdHZhciBsb2NhbFgyID0gbG9jYWxYICsgdGhpcy5yZWdpb24ud2lkdGggKiByZWdpb25TY2FsZVg7XG5cdFx0XHR2YXIgbG9jYWxZMiA9IGxvY2FsWSArIHRoaXMucmVnaW9uLmhlaWdodCAqIHJlZ2lvblNjYWxlWTtcblx0XHRcdHZhciByYWRpYW5zID0gdGhpcy5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG5cdFx0XHR2YXIgbG9jYWxYQ29zID0gbG9jYWxYICogY29zICsgdGhpcy54O1xuXHRcdFx0dmFyIGxvY2FsWFNpbiA9IGxvY2FsWCAqIHNpbjtcblx0XHRcdHZhciBsb2NhbFlDb3MgPSBsb2NhbFkgKiBjb3MgKyB0aGlzLnk7XG5cdFx0XHR2YXIgbG9jYWxZU2luID0gbG9jYWxZICogc2luO1xuXHRcdFx0dmFyIGxvY2FsWDJDb3MgPSBsb2NhbFgyICogY29zICsgdGhpcy54O1xuXHRcdFx0dmFyIGxvY2FsWDJTaW4gPSBsb2NhbFgyICogc2luO1xuXHRcdFx0dmFyIGxvY2FsWTJDb3MgPSBsb2NhbFkyICogY29zICsgdGhpcy55O1xuXHRcdFx0dmFyIGxvY2FsWTJTaW4gPSBsb2NhbFkyICogc2luO1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXHRcdFx0b2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gxXSA9IGxvY2FsWENvcyAtIGxvY2FsWVNpbjtcblx0XHRcdG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZMV0gPSBsb2NhbFlDb3MgKyBsb2NhbFhTaW47XG5cdFx0XHRvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDJdID0gbG9jYWxYQ29zIC0gbG9jYWxZMlNpbjtcblx0XHRcdG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZMl0gPSBsb2NhbFkyQ29zICsgbG9jYWxYU2luO1xuXHRcdFx0b2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gzXSA9IGxvY2FsWDJDb3MgLSBsb2NhbFkyU2luO1xuXHRcdFx0b2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kzXSA9IGxvY2FsWTJDb3MgKyBsb2NhbFgyU2luO1xuXHRcdFx0b2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1g0XSA9IGxvY2FsWDJDb3MgLSBsb2NhbFlTaW47XG5cdFx0XHRvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTRdID0gbG9jYWxZQ29zICsgbG9jYWxYMlNpbjtcblx0XHR9O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24pIHtcblx0XHRcdHRoaXMucmVnaW9uID0gcmVnaW9uO1xuXHRcdFx0dmFyIHV2cyA9IHRoaXMudXZzO1xuXHRcdFx0aWYgKHJlZ2lvbi5yb3RhdGUpIHtcblx0XHRcdFx0dXZzWzJdID0gcmVnaW9uLnU7XG5cdFx0XHRcdHV2c1szXSA9IHJlZ2lvbi52Mjtcblx0XHRcdFx0dXZzWzRdID0gcmVnaW9uLnU7XG5cdFx0XHRcdHV2c1s1XSA9IHJlZ2lvbi52O1xuXHRcdFx0XHR1dnNbNl0gPSByZWdpb24udTI7XG5cdFx0XHRcdHV2c1s3XSA9IHJlZ2lvbi52O1xuXHRcdFx0XHR1dnNbMF0gPSByZWdpb24udTI7XG5cdFx0XHRcdHV2c1sxXSA9IHJlZ2lvbi52Mjtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR1dnNbMF0gPSByZWdpb24udTtcblx0XHRcdFx0dXZzWzFdID0gcmVnaW9uLnYyO1xuXHRcdFx0XHR1dnNbMl0gPSByZWdpb24udTtcblx0XHRcdFx0dXZzWzNdID0gcmVnaW9uLnY7XG5cdFx0XHRcdHV2c1s0XSA9IHJlZ2lvbi51Mjtcblx0XHRcdFx0dXZzWzVdID0gcmVnaW9uLnY7XG5cdFx0XHRcdHV2c1s2XSA9IHJlZ2lvbi51Mjtcblx0XHRcdFx0dXZzWzddID0gcmVnaW9uLnYyO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UmVnaW9uQXR0YWNobWVudC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbiAoYm9uZSwgd29ybGRWZXJ0aWNlcywgb2Zmc2V0LCBzdHJpZGUpIHtcblx0XHRcdHZhciB2ZXJ0ZXhPZmZzZXQgPSB0aGlzLm9mZnNldDtcblx0XHRcdHZhciB4ID0gYm9uZS53b3JsZFgsIHkgPSBib25lLndvcmxkWTtcblx0XHRcdHZhciBhID0gYm9uZS5hLCBiID0gYm9uZS5iLCBjID0gYm9uZS5jLCBkID0gYm9uZS5kO1xuXHRcdFx0dmFyIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMDtcblx0XHRcdG9mZnNldFggPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDFdO1xuXHRcdFx0b2Zmc2V0WSA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZMV07XG5cdFx0XHR3b3JsZFZlcnRpY2VzW29mZnNldF0gPSBvZmZzZXRYICogYSArIG9mZnNldFkgKiBiICsgeDtcblx0XHRcdHdvcmxkVmVydGljZXNbb2Zmc2V0ICsgMV0gPSBvZmZzZXRYICogYyArIG9mZnNldFkgKiBkICsgeTtcblx0XHRcdG9mZnNldCArPSBzdHJpZGU7XG5cdFx0XHRvZmZzZXRYID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gyXTtcblx0XHRcdG9mZnNldFkgPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTJdO1xuXHRcdFx0d29ybGRWZXJ0aWNlc1tvZmZzZXRdID0gb2Zmc2V0WCAqIGEgKyBvZmZzZXRZICogYiArIHg7XG5cdFx0XHR3b3JsZFZlcnRpY2VzW29mZnNldCArIDFdID0gb2Zmc2V0WCAqIGMgKyBvZmZzZXRZICogZCArIHk7XG5cdFx0XHRvZmZzZXQgKz0gc3RyaWRlO1xuXHRcdFx0b2Zmc2V0WCA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YM107XG5cdFx0XHRvZmZzZXRZID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kzXTtcblx0XHRcdHdvcmxkVmVydGljZXNbb2Zmc2V0XSA9IG9mZnNldFggKiBhICsgb2Zmc2V0WSAqIGIgKyB4O1xuXHRcdFx0d29ybGRWZXJ0aWNlc1tvZmZzZXQgKyAxXSA9IG9mZnNldFggKiBjICsgb2Zmc2V0WSAqIGQgKyB5O1xuXHRcdFx0b2Zmc2V0ICs9IHN0cmlkZTtcblx0XHRcdG9mZnNldFggPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDRdO1xuXHRcdFx0b2Zmc2V0WSA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZNF07XG5cdFx0XHR3b3JsZFZlcnRpY2VzW29mZnNldF0gPSBvZmZzZXRYICogYSArIG9mZnNldFkgKiBiICsgeDtcblx0XHRcdHdvcmxkVmVydGljZXNbb2Zmc2V0ICsgMV0gPSBvZmZzZXRYICogYyArIG9mZnNldFkgKiBkICsgeTtcblx0XHR9O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuT1gxID0gMDtcblx0XHRSZWdpb25BdHRhY2htZW50Lk9ZMSA9IDE7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5PWDIgPSAyO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuT1kyID0gMztcblx0XHRSZWdpb25BdHRhY2htZW50Lk9YMyA9IDQ7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5PWTMgPSA1O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuT1g0ID0gNjtcblx0XHRSZWdpb25BdHRhY2htZW50Lk9ZNCA9IDc7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5YMSA9IDA7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5ZMSA9IDE7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5DMVIgPSAyO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzFHID0gMztcblx0XHRSZWdpb25BdHRhY2htZW50LkMxQiA9IDQ7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5DMUEgPSA1O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuVTEgPSA2O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuVjEgPSA3O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuWDIgPSA4O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuWTIgPSA5O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzJSID0gMTA7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5DMkcgPSAxMTtcblx0XHRSZWdpb25BdHRhY2htZW50LkMyQiA9IDEyO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzJBID0gMTM7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5VMiA9IDE0O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuVjIgPSAxNTtcblx0XHRSZWdpb25BdHRhY2htZW50LlgzID0gMTY7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5ZMyA9IDE3O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzNSID0gMTg7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5DM0cgPSAxOTtcblx0XHRSZWdpb25BdHRhY2htZW50LkMzQiA9IDIwO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzNBID0gMjE7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5VMyA9IDIyO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuVjMgPSAyMztcblx0XHRSZWdpb25BdHRhY2htZW50Llg0ID0gMjQ7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5ZNCA9IDI1O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzRSID0gMjY7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5DNEcgPSAyNztcblx0XHRSZWdpb25BdHRhY2htZW50LkM0QiA9IDI4O1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuQzRBID0gMjk7XG5cdFx0UmVnaW9uQXR0YWNobWVudC5VNCA9IDMwO1xuXHRcdFJlZ2lvbkF0dGFjaG1lbnQuVjQgPSAzMTtcblx0XHRyZXR1cm4gUmVnaW9uQXR0YWNobWVudDtcblx0fShzcGluZS5BdHRhY2htZW50KSk7XG5cdHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQgPSBSZWdpb25BdHRhY2htZW50O1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0KGZ1bmN0aW9uIChCbGVuZE1vZGUpIHtcblx0XHRCbGVuZE1vZGVbQmxlbmRNb2RlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xuXHRcdEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJBZGRpdGl2ZVwiXSA9IDFdID0gXCJBZGRpdGl2ZVwiO1xuXHRcdEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJNdWx0aXBseVwiXSA9IDJdID0gXCJNdWx0aXBseVwiO1xuXHRcdEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJTY3JlZW5cIl0gPSAzXSA9IFwiU2NyZWVuXCI7XG5cdH0pKHNwaW5lLkJsZW5kTW9kZSB8fCAoc3BpbmUuQmxlbmRNb2RlID0ge30pKTtcblx0dmFyIEJsZW5kTW9kZSA9IHNwaW5lLkJsZW5kTW9kZTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBCb25lID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBCb25lKGRhdGEsIHNrZWxldG9uLCBwYXJlbnQpIHtcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0XHR0aGlzLnNjYWxlWCA9IDA7XG5cdFx0XHR0aGlzLnNjYWxlWSA9IDA7XG5cdFx0XHR0aGlzLnNoZWFyWCA9IDA7XG5cdFx0XHR0aGlzLnNoZWFyWSA9IDA7XG5cdFx0XHR0aGlzLmF4ID0gMDtcblx0XHRcdHRoaXMuYXkgPSAwO1xuXHRcdFx0dGhpcy5hcm90YXRpb24gPSAwO1xuXHRcdFx0dGhpcy5hc2NhbGVYID0gMDtcblx0XHRcdHRoaXMuYXNjYWxlWSA9IDA7XG5cdFx0XHR0aGlzLmFzaGVhclggPSAwO1xuXHRcdFx0dGhpcy5hc2hlYXJZID0gMDtcblx0XHRcdHRoaXMuYXBwbGllZFZhbGlkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmEgPSAwO1xuXHRcdFx0dGhpcy5iID0gMDtcblx0XHRcdHRoaXMud29ybGRYID0gMDtcblx0XHRcdHRoaXMuYyA9IDA7XG5cdFx0XHR0aGlzLmQgPSAwO1xuXHRcdFx0dGhpcy53b3JsZFkgPSAwO1xuXHRcdFx0dGhpcy5zb3J0ZWQgPSBmYWxzZTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKHNrZWxldG9uID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0XHRcdHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcblx0XHR9XG5cdFx0Qm9uZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgodGhpcy54LCB0aGlzLnksIHRoaXMucm90YXRpb24sIHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSwgdGhpcy5zaGVhclgsIHRoaXMuc2hlYXJZKTtcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLnVwZGF0ZVdvcmxkVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgodGhpcy54LCB0aGlzLnksIHRoaXMucm90YXRpb24sIHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSwgdGhpcy5zaGVhclgsIHRoaXMuc2hlYXJZKTtcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCA9IGZ1bmN0aW9uICh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVksIHNoZWFyWCwgc2hlYXJZKSB7XG5cdFx0XHR0aGlzLmF4ID0geDtcblx0XHRcdHRoaXMuYXkgPSB5O1xuXHRcdFx0dGhpcy5hcm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdHRoaXMuYXNjYWxlWCA9IHNjYWxlWDtcblx0XHRcdHRoaXMuYXNjYWxlWSA9IHNjYWxlWTtcblx0XHRcdHRoaXMuYXNoZWFyWCA9IHNoZWFyWDtcblx0XHRcdHRoaXMuYXNoZWFyWSA9IHNoZWFyWTtcblx0XHRcdHRoaXMuYXBwbGllZFZhbGlkID0gdHJ1ZTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblx0XHRcdGlmIChwYXJlbnQgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcm90YXRpb25ZID0gcm90YXRpb24gKyA5MCArIHNoZWFyWTtcblx0XHRcdFx0dmFyIGxhID0gc3BpbmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XG5cdFx0XHRcdHZhciBsYiA9IHNwaW5lLk1hdGhVdGlscy5jb3NEZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcblx0XHRcdFx0dmFyIGxjID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XG5cdFx0XHRcdHZhciBsZCA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcblx0XHRcdFx0dmFyIHNrZWxldG9uID0gdGhpcy5za2VsZXRvbjtcblx0XHRcdFx0aWYgKHNrZWxldG9uLmZsaXBYKSB7XG5cdFx0XHRcdFx0eCA9IC14O1xuXHRcdFx0XHRcdGxhID0gLWxhO1xuXHRcdFx0XHRcdGxiID0gLWxiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChza2VsZXRvbi5mbGlwWSkge1xuXHRcdFx0XHRcdHkgPSAteTtcblx0XHRcdFx0XHRsYyA9IC1sYztcblx0XHRcdFx0XHRsZCA9IC1sZDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmEgPSBsYTtcblx0XHRcdFx0dGhpcy5iID0gbGI7XG5cdFx0XHRcdHRoaXMuYyA9IGxjO1xuXHRcdFx0XHR0aGlzLmQgPSBsZDtcblx0XHRcdFx0dGhpcy53b3JsZFggPSB4ICsgc2tlbGV0b24ueDtcblx0XHRcdFx0dGhpcy53b3JsZFkgPSB5ICsgc2tlbGV0b24ueTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhID0gcGFyZW50LmEsIHBiID0gcGFyZW50LmIsIHBjID0gcGFyZW50LmMsIHBkID0gcGFyZW50LmQ7XG5cdFx0XHR0aGlzLndvcmxkWCA9IHBhICogeCArIHBiICogeSArIHBhcmVudC53b3JsZFg7XG5cdFx0XHR0aGlzLndvcmxkWSA9IHBjICogeCArIHBkICogeSArIHBhcmVudC53b3JsZFk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuZGF0YS50cmFuc2Zvcm1Nb2RlKSB7XG5cdFx0XHRcdGNhc2Ugc3BpbmUuVHJhbnNmb3JtTW9kZS5Ob3JtYWw6IHtcblx0XHRcdFx0XHR2YXIgcm90YXRpb25ZID0gcm90YXRpb24gKyA5MCArIHNoZWFyWTtcblx0XHRcdFx0XHR2YXIgbGEgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uICsgc2hlYXJYKSAqIHNjYWxlWDtcblx0XHRcdFx0XHR2YXIgbGIgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uWSkgKiBzY2FsZVk7XG5cdFx0XHRcdFx0dmFyIGxjID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XG5cdFx0XHRcdFx0dmFyIGxkID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvblkpICogc2NhbGVZO1xuXHRcdFx0XHRcdHRoaXMuYSA9IHBhICogbGEgKyBwYiAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuYiA9IHBhICogbGIgKyBwYiAqIGxkO1xuXHRcdFx0XHRcdHRoaXMuYyA9IHBjICogbGEgKyBwZCAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuZCA9IHBjICogbGIgKyBwZCAqIGxkO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIHNwaW5lLlRyYW5zZm9ybU1vZGUuT25seVRyYW5zbGF0aW9uOiB7XG5cdFx0XHRcdFx0dmFyIHJvdGF0aW9uWSA9IHJvdGF0aW9uICsgOTAgKyBzaGVhclk7XG5cdFx0XHRcdFx0dGhpcy5hID0gc3BpbmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XG5cdFx0XHRcdFx0dGhpcy5iID0gc3BpbmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvblkpICogc2NhbGVZO1xuXHRcdFx0XHRcdHRoaXMuYyA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYO1xuXHRcdFx0XHRcdHRoaXMuZCA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIHNwaW5lLlRyYW5zZm9ybU1vZGUuTm9Sb3RhdGlvbk9yUmVmbGVjdGlvbjoge1xuXHRcdFx0XHRcdHZhciBzID0gcGEgKiBwYSArIHBjICogcGM7XG5cdFx0XHRcdFx0dmFyIHByeCA9IDA7XG5cdFx0XHRcdFx0aWYgKHMgPiAwLjAwMDEpIHtcblx0XHRcdFx0XHRcdHMgPSBNYXRoLmFicyhwYSAqIHBkIC0gcGIgKiBwYykgLyBzO1xuXHRcdFx0XHRcdFx0cGIgPSBwYyAqIHM7XG5cdFx0XHRcdFx0XHRwZCA9IHBhICogcztcblx0XHRcdFx0XHRcdHByeCA9IE1hdGguYXRhbjIocGMsIHBhKSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cGEgPSAwO1xuXHRcdFx0XHRcdFx0cGMgPSAwO1xuXHRcdFx0XHRcdFx0cHJ4ID0gOTAgLSBNYXRoLmF0YW4yKHBkLCBwYikgKiBzcGluZS5NYXRoVXRpbHMucmFkRGVnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgcnggPSByb3RhdGlvbiArIHNoZWFyWCAtIHByeDtcblx0XHRcdFx0XHR2YXIgcnkgPSByb3RhdGlvbiArIHNoZWFyWSAtIHByeCArIDkwO1xuXHRcdFx0XHRcdHZhciBsYSA9IHNwaW5lLk1hdGhVdGlscy5jb3NEZWcocngpICogc2NhbGVYO1xuXHRcdFx0XHRcdHZhciBsYiA9IHNwaW5lLk1hdGhVdGlscy5jb3NEZWcocnkpICogc2NhbGVZO1xuXHRcdFx0XHRcdHZhciBsYyA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcocngpICogc2NhbGVYO1xuXHRcdFx0XHRcdHZhciBsZCA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcocnkpICogc2NhbGVZO1xuXHRcdFx0XHRcdHRoaXMuYSA9IHBhICogbGEgLSBwYiAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuYiA9IHBhICogbGIgLSBwYiAqIGxkO1xuXHRcdFx0XHRcdHRoaXMuYyA9IHBjICogbGEgKyBwZCAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuZCA9IHBjICogbGIgKyBwZCAqIGxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2Ugc3BpbmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlOlxuXHRcdFx0XHRjYXNlIHNwaW5lLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbjoge1xuXHRcdFx0XHRcdHZhciBjb3MgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uKTtcblx0XHRcdFx0XHR2YXIgc2luID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvbik7XG5cdFx0XHRcdFx0dmFyIHphID0gcGEgKiBjb3MgKyBwYiAqIHNpbjtcblx0XHRcdFx0XHR2YXIgemMgPSBwYyAqIGNvcyArIHBkICogc2luO1xuXHRcdFx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KHphICogemEgKyB6YyAqIHpjKTtcblx0XHRcdFx0XHRpZiAocyA+IDAuMDAwMDEpXG5cdFx0XHRcdFx0XHRzID0gMSAvIHM7XG5cdFx0XHRcdFx0emEgKj0gcztcblx0XHRcdFx0XHR6YyAqPSBzO1xuXHRcdFx0XHRcdHMgPSBNYXRoLnNxcnQoemEgKiB6YSArIHpjICogemMpO1xuXHRcdFx0XHRcdHZhciByID0gTWF0aC5QSSAvIDIgKyBNYXRoLmF0YW4yKHpjLCB6YSk7XG5cdFx0XHRcdFx0dmFyIHpiID0gTWF0aC5jb3MocikgKiBzO1xuXHRcdFx0XHRcdHZhciB6ZCA9IE1hdGguc2luKHIpICogcztcblx0XHRcdFx0XHR2YXIgbGEgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKHNoZWFyWCkgKiBzY2FsZVg7XG5cdFx0XHRcdFx0dmFyIGxiID0gc3BpbmUuTWF0aFV0aWxzLmNvc0RlZyg5MCArIHNoZWFyWSkgKiBzY2FsZVk7XG5cdFx0XHRcdFx0dmFyIGxjID0gc3BpbmUuTWF0aFV0aWxzLnNpbkRlZyhzaGVhclgpICogc2NhbGVYO1xuXHRcdFx0XHRcdHZhciBsZCA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcoOTAgKyBzaGVhclkpICogc2NhbGVZO1xuXHRcdFx0XHRcdHRoaXMuYSA9IHphICogbGEgKyB6YiAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuYiA9IHphICogbGIgKyB6YiAqIGxkO1xuXHRcdFx0XHRcdHRoaXMuYyA9IHpjICogbGEgKyB6ZCAqIGxjO1xuXHRcdFx0XHRcdHRoaXMuZCA9IHpjICogbGIgKyB6ZCAqIGxkO1xuXHRcdFx0XHRcdGlmICh0aGlzLmRhdGEudHJhbnNmb3JtTW9kZSAhPSBzcGluZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGVPclJlZmxlY3Rpb24gPyBwYSAqIHBkIC0gcGIgKiBwYyA8IDAgOiB0aGlzLnNrZWxldG9uLmZsaXBYICE9IHRoaXMuc2tlbGV0b24uZmxpcFkpIHtcblx0XHRcdFx0XHRcdHRoaXMuYiA9IC10aGlzLmI7XG5cdFx0XHRcdFx0XHR0aGlzLmQgPSAtdGhpcy5kO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnNrZWxldG9uLmZsaXBYKSB7XG5cdFx0XHRcdHRoaXMuYSA9IC10aGlzLmE7XG5cdFx0XHRcdHRoaXMuYiA9IC10aGlzLmI7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5za2VsZXRvbi5mbGlwWSkge1xuXHRcdFx0XHR0aGlzLmMgPSAtdGhpcy5jO1xuXHRcdFx0XHR0aGlzLmQgPSAtdGhpcy5kO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Qm9uZS5wcm90b3R5cGUuc2V0VG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRcdHRoaXMueCA9IGRhdGEueDtcblx0XHRcdHRoaXMueSA9IGRhdGEueTtcblx0XHRcdHRoaXMucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuXHRcdFx0dGhpcy5zY2FsZVggPSBkYXRhLnNjYWxlWDtcblx0XHRcdHRoaXMuc2NhbGVZID0gZGF0YS5zY2FsZVk7XG5cdFx0XHR0aGlzLnNoZWFyWCA9IGRhdGEuc2hlYXJYO1xuXHRcdFx0dGhpcy5zaGVhclkgPSBkYXRhLnNoZWFyWTtcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb25YID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jLCB0aGlzLmEpICogc3BpbmUuTWF0aFV0aWxzLnJhZERlZztcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb25ZID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5kLCB0aGlzLmIpICogc3BpbmUuTWF0aFV0aWxzLnJhZERlZztcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLmdldFdvcmxkU2NhbGVYID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmMgKiB0aGlzLmMpO1xuXHRcdH07XG5cdFx0Qm9uZS5wcm90b3R5cGUuZ2V0V29ybGRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuYiAqIHRoaXMuYiArIHRoaXMuZCAqIHRoaXMuZCk7XG5cdFx0fTtcblx0XHRCb25lLnByb3RvdHlwZS51cGRhdGVBcHBsaWVkVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5hcHBsaWVkVmFsaWQgPSB0cnVlO1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuYXggPSB0aGlzLndvcmxkWDtcblx0XHRcdFx0dGhpcy5heSA9IHRoaXMud29ybGRZO1xuXHRcdFx0XHR0aGlzLmFyb3RhdGlvbiA9IE1hdGguYXRhbjIodGhpcy5jLCB0aGlzLmEpICogc3BpbmUuTWF0aFV0aWxzLnJhZERlZztcblx0XHRcdFx0dGhpcy5hc2NhbGVYID0gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYyAqIHRoaXMuYyk7XG5cdFx0XHRcdHRoaXMuYXNjYWxlWSA9IE1hdGguc3FydCh0aGlzLmIgKiB0aGlzLmIgKyB0aGlzLmQgKiB0aGlzLmQpO1xuXHRcdFx0XHR0aGlzLmFzaGVhclggPSAwO1xuXHRcdFx0XHR0aGlzLmFzaGVhclkgPSBNYXRoLmF0YW4yKHRoaXMuYSAqIHRoaXMuYiArIHRoaXMuYyAqIHRoaXMuZCwgdGhpcy5hICogdGhpcy5kIC0gdGhpcy5iICogdGhpcy5jKSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWc7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBwYSA9IHBhcmVudC5hLCBwYiA9IHBhcmVudC5iLCBwYyA9IHBhcmVudC5jLCBwZCA9IHBhcmVudC5kO1xuXHRcdFx0dmFyIHBpZCA9IDEgLyAocGEgKiBwZCAtIHBiICogcGMpO1xuXHRcdFx0dmFyIGR4ID0gdGhpcy53b3JsZFggLSBwYXJlbnQud29ybGRYLCBkeSA9IHRoaXMud29ybGRZIC0gcGFyZW50LndvcmxkWTtcblx0XHRcdHRoaXMuYXggPSAoZHggKiBwZCAqIHBpZCAtIGR5ICogcGIgKiBwaWQpO1xuXHRcdFx0dGhpcy5heSA9IChkeSAqIHBhICogcGlkIC0gZHggKiBwYyAqIHBpZCk7XG5cdFx0XHR2YXIgaWEgPSBwaWQgKiBwZDtcblx0XHRcdHZhciBpZCA9IHBpZCAqIHBhO1xuXHRcdFx0dmFyIGliID0gcGlkICogcGI7XG5cdFx0XHR2YXIgaWMgPSBwaWQgKiBwYztcblx0XHRcdHZhciByYSA9IGlhICogdGhpcy5hIC0gaWIgKiB0aGlzLmM7XG5cdFx0XHR2YXIgcmIgPSBpYSAqIHRoaXMuYiAtIGliICogdGhpcy5kO1xuXHRcdFx0dmFyIHJjID0gaWQgKiB0aGlzLmMgLSBpYyAqIHRoaXMuYTtcblx0XHRcdHZhciByZCA9IGlkICogdGhpcy5kIC0gaWMgKiB0aGlzLmI7XG5cdFx0XHR0aGlzLmFzaGVhclggPSAwO1xuXHRcdFx0dGhpcy5hc2NhbGVYID0gTWF0aC5zcXJ0KHJhICogcmEgKyByYyAqIHJjKTtcblx0XHRcdGlmICh0aGlzLmFzY2FsZVggPiAwLjAwMDEpIHtcblx0XHRcdFx0dmFyIGRldCA9IHJhICogcmQgLSByYiAqIHJjO1xuXHRcdFx0XHR0aGlzLmFzY2FsZVkgPSBkZXQgLyB0aGlzLmFzY2FsZVg7XG5cdFx0XHRcdHRoaXMuYXNoZWFyWSA9IE1hdGguYXRhbjIocmEgKiByYiArIHJjICogcmQsIGRldCkgKiBzcGluZS5NYXRoVXRpbHMucmFkRGVnO1xuXHRcdFx0XHR0aGlzLmFyb3RhdGlvbiA9IE1hdGguYXRhbjIocmMsIHJhKSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5hc2NhbGVYID0gMDtcblx0XHRcdFx0dGhpcy5hc2NhbGVZID0gTWF0aC5zcXJ0KHJiICogcmIgKyByZCAqIHJkKTtcblx0XHRcdFx0dGhpcy5hc2hlYXJZID0gMDtcblx0XHRcdFx0dGhpcy5hcm90YXRpb24gPSA5MCAtIE1hdGguYXRhbjIocmQsIHJiKSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRCb25lLnByb3RvdHlwZS53b3JsZFRvTG9jYWwgPSBmdW5jdGlvbiAod29ybGQpIHtcblx0XHRcdHZhciBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jLCBkID0gdGhpcy5kO1xuXHRcdFx0dmFyIGludkRldCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG5cdFx0XHR2YXIgeCA9IHdvcmxkLnggLSB0aGlzLndvcmxkWCwgeSA9IHdvcmxkLnkgLSB0aGlzLndvcmxkWTtcblx0XHRcdHdvcmxkLnggPSAoeCAqIGQgKiBpbnZEZXQgLSB5ICogYiAqIGludkRldCk7XG5cdFx0XHR3b3JsZC55ID0gKHkgKiBhICogaW52RGV0IC0geCAqIGMgKiBpbnZEZXQpO1xuXHRcdFx0cmV0dXJuIHdvcmxkO1xuXHRcdH07XG5cdFx0Qm9uZS5wcm90b3R5cGUubG9jYWxUb1dvcmxkID0gZnVuY3Rpb24gKGxvY2FsKSB7XG5cdFx0XHR2YXIgeCA9IGxvY2FsLngsIHkgPSBsb2NhbC55O1xuXHRcdFx0bG9jYWwueCA9IHggKiB0aGlzLmEgKyB5ICogdGhpcy5iICsgdGhpcy53b3JsZFg7XG5cdFx0XHRsb2NhbC55ID0geCAqIHRoaXMuYyArIHkgKiB0aGlzLmQgKyB0aGlzLndvcmxkWTtcblx0XHRcdHJldHVybiBsb2NhbDtcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLndvcmxkVG9Mb2NhbFJvdGF0aW9uID0gZnVuY3Rpb24gKHdvcmxkUm90YXRpb24pIHtcblx0XHRcdHZhciBzaW4gPSBzcGluZS5NYXRoVXRpbHMuc2luRGVnKHdvcmxkUm90YXRpb24pLCBjb3MgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKHdvcmxkUm90YXRpb24pO1xuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5hICogc2luIC0gdGhpcy5jICogY29zLCB0aGlzLmQgKiBjb3MgLSB0aGlzLmIgKiBzaW4pICogc3BpbmUuTWF0aFV0aWxzLnJhZERlZztcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLmxvY2FsVG9Xb3JsZFJvdGF0aW9uID0gZnVuY3Rpb24gKGxvY2FsUm90YXRpb24pIHtcblx0XHRcdHZhciBzaW4gPSBzcGluZS5NYXRoVXRpbHMuc2luRGVnKGxvY2FsUm90YXRpb24pLCBjb3MgPSBzcGluZS5NYXRoVXRpbHMuY29zRGVnKGxvY2FsUm90YXRpb24pO1xuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoY29zICogdGhpcy5jICsgc2luICogdGhpcy5kLCBjb3MgKiB0aGlzLmEgKyBzaW4gKiB0aGlzLmIpICogc3BpbmUuTWF0aFV0aWxzLnJhZERlZztcblx0XHR9O1xuXHRcdEJvbmUucHJvdG90eXBlLnJvdGF0ZVdvcmxkID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHRcdHZhciBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jLCBkID0gdGhpcy5kO1xuXHRcdFx0dmFyIGNvcyA9IHNwaW5lLk1hdGhVdGlscy5jb3NEZWcoZGVncmVlcyksIHNpbiA9IHNwaW5lLk1hdGhVdGlscy5zaW5EZWcoZGVncmVlcyk7XG5cdFx0XHR0aGlzLmEgPSBjb3MgKiBhIC0gc2luICogYztcblx0XHRcdHRoaXMuYiA9IGNvcyAqIGIgLSBzaW4gKiBkO1xuXHRcdFx0dGhpcy5jID0gc2luICogYSArIGNvcyAqIGM7XG5cdFx0XHR0aGlzLmQgPSBzaW4gKiBiICsgY29zICogZDtcblx0XHRcdHRoaXMuYXBwbGllZFZhbGlkID0gZmFsc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gQm9uZTtcblx0fSgpKTtcblx0c3BpbmUuQm9uZSA9IEJvbmU7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgQm9uZURhdGEgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEJvbmVEYXRhKGluZGV4LCBuYW1lLCBwYXJlbnQpIHtcblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0XHR0aGlzLnNjYWxlWCA9IDE7XG5cdFx0XHR0aGlzLnNjYWxlWSA9IDE7XG5cdFx0XHR0aGlzLnNoZWFyWCA9IDA7XG5cdFx0XHR0aGlzLnNoZWFyWSA9IDA7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybU1vZGUgPSBUcmFuc2Zvcm1Nb2RlLk5vcm1hbDtcblx0XHRcdGlmIChpbmRleCA8IDApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImluZGV4IG11c3QgYmUgPj0gMC5cIik7XG5cdFx0XHRpZiAobmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIEJvbmVEYXRhO1xuXHR9KCkpO1xuXHRzcGluZS5Cb25lRGF0YSA9IEJvbmVEYXRhO1xuXHQoZnVuY3Rpb24gKFRyYW5zZm9ybU1vZGUpIHtcblx0XHRUcmFuc2Zvcm1Nb2RlW1RyYW5zZm9ybU1vZGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XG5cdFx0VHJhbnNmb3JtTW9kZVtUcmFuc2Zvcm1Nb2RlW1wiT25seVRyYW5zbGF0aW9uXCJdID0gMV0gPSBcIk9ubHlUcmFuc2xhdGlvblwiO1xuXHRcdFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vUm90YXRpb25PclJlZmxlY3Rpb25cIl0gPSAyXSA9IFwiTm9Sb3RhdGlvbk9yUmVmbGVjdGlvblwiO1xuXHRcdFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vU2NhbGVcIl0gPSAzXSA9IFwiTm9TY2FsZVwiO1xuXHRcdFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vU2NhbGVPclJlZmxlY3Rpb25cIl0gPSA0XSA9IFwiTm9TY2FsZU9yUmVmbGVjdGlvblwiO1xuXHR9KShzcGluZS5UcmFuc2Zvcm1Nb2RlIHx8IChzcGluZS5UcmFuc2Zvcm1Nb2RlID0ge30pKTtcblx0dmFyIFRyYW5zZm9ybU1vZGUgPSBzcGluZS5UcmFuc2Zvcm1Nb2RlO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBFdmVudCh0aW1lLCBkYXRhKSB7XG5cdFx0XHRpZiAoZGF0YSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdH1cblx0XHRyZXR1cm4gRXZlbnQ7XG5cdH0oKSk7XG5cdHNwaW5lLkV2ZW50ID0gRXZlbnQ7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgRXZlbnREYXRhID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBFdmVudERhdGEobmFtZSkge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIEV2ZW50RGF0YTtcblx0fSgpKTtcblx0c3BpbmUuRXZlbnREYXRhID0gRXZlbnREYXRhO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIElrQ29uc3RyYWludCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gSWtDb25zdHJhaW50KGRhdGEsIHNrZWxldG9uKSB7XG5cdFx0XHR0aGlzLm1peCA9IDE7XG5cdFx0XHR0aGlzLmJlbmREaXJlY3Rpb24gPSAwO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHRpZiAoc2tlbGV0b24gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdHRoaXMubWl4ID0gZGF0YS5taXg7XG5cdFx0XHR0aGlzLmJlbmREaXJlY3Rpb24gPSBkYXRhLmJlbmREaXJlY3Rpb247XG5cdFx0XHR0aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYm9uZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHRoaXMuYm9uZXMucHVzaChza2VsZXRvbi5maW5kQm9uZShkYXRhLmJvbmVzW2ldLm5hbWUpKTtcblx0XHRcdHRoaXMudGFyZ2V0ID0gc2tlbGV0b24uZmluZEJvbmUoZGF0YS50YXJnZXQubmFtZSk7XG5cdFx0fVxuXHRcdElrQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0T3JkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLm9yZGVyO1xuXHRcdH07XG5cdFx0SWtDb25zdHJhaW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0XHRJa0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRzd2l0Y2ggKGJvbmVzLmxlbmd0aCkge1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dGhpcy5hcHBseTEoYm9uZXNbMF0sIHRhcmdldC53b3JsZFgsIHRhcmdldC53b3JsZFksIHRoaXMubWl4KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHRoaXMuYXBwbHkyKGJvbmVzWzBdLCBib25lc1sxXSwgdGFyZ2V0LndvcmxkWCwgdGFyZ2V0LndvcmxkWSwgdGhpcy5iZW5kRGlyZWN0aW9uLCB0aGlzLm1peCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRJa0NvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5MSA9IGZ1bmN0aW9uIChib25lLCB0YXJnZXRYLCB0YXJnZXRZLCBhbHBoYSkge1xuXHRcdFx0aWYgKCFib25lLmFwcGxpZWRWYWxpZClcblx0XHRcdFx0Ym9uZS51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XG5cdFx0XHR2YXIgcCA9IGJvbmUucGFyZW50O1xuXHRcdFx0dmFyIGlkID0gMSAvIChwLmEgKiBwLmQgLSBwLmIgKiBwLmMpO1xuXHRcdFx0dmFyIHggPSB0YXJnZXRYIC0gcC53b3JsZFgsIHkgPSB0YXJnZXRZIC0gcC53b3JsZFk7XG5cdFx0XHR2YXIgdHggPSAoeCAqIHAuZCAtIHkgKiBwLmIpICogaWQgLSBib25lLmF4LCB0eSA9ICh5ICogcC5hIC0geCAqIHAuYykgKiBpZCAtIGJvbmUuYXk7XG5cdFx0XHR2YXIgcm90YXRpb25JSyA9IE1hdGguYXRhbjIodHksIHR4KSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWcgLSBib25lLmFzaGVhclggLSBib25lLmFyb3RhdGlvbjtcblx0XHRcdGlmIChib25lLmFzY2FsZVggPCAwKVxuXHRcdFx0XHRyb3RhdGlvbklLICs9IDE4MDtcblx0XHRcdGlmIChyb3RhdGlvbklLID4gMTgwKVxuXHRcdFx0XHRyb3RhdGlvbklLIC09IDM2MDtcblx0XHRcdGVsc2UgaWYgKHJvdGF0aW9uSUsgPCAtMTgwKVxuXHRcdFx0XHRyb3RhdGlvbklLICs9IDM2MDtcblx0XHRcdGJvbmUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKGJvbmUuYXgsIGJvbmUuYXksIGJvbmUuYXJvdGF0aW9uICsgcm90YXRpb25JSyAqIGFscGhhLCBib25lLmFzY2FsZVgsIGJvbmUuYXNjYWxlWSwgYm9uZS5hc2hlYXJYLCBib25lLmFzaGVhclkpO1xuXHRcdH07XG5cdFx0SWtDb25zdHJhaW50LnByb3RvdHlwZS5hcHBseTIgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdGFyZ2V0WCwgdGFyZ2V0WSwgYmVuZERpciwgYWxwaGEpIHtcblx0XHRcdGlmIChhbHBoYSA9PSAwKSB7XG5cdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICghcGFyZW50LmFwcGxpZWRWYWxpZClcblx0XHRcdFx0cGFyZW50LnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcblx0XHRcdGlmICghY2hpbGQuYXBwbGllZFZhbGlkKVxuXHRcdFx0XHRjaGlsZC51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XG5cdFx0XHR2YXIgcHggPSBwYXJlbnQuYXgsIHB5ID0gcGFyZW50LmF5LCBwc3ggPSBwYXJlbnQuYXNjYWxlWCwgcHN5ID0gcGFyZW50LmFzY2FsZVksIGNzeCA9IGNoaWxkLmFzY2FsZVg7XG5cdFx0XHR2YXIgb3MxID0gMCwgb3MyID0gMCwgczIgPSAwO1xuXHRcdFx0aWYgKHBzeCA8IDApIHtcblx0XHRcdFx0cHN4ID0gLXBzeDtcblx0XHRcdFx0b3MxID0gMTgwO1xuXHRcdFx0XHRzMiA9IC0xO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG9zMSA9IDA7XG5cdFx0XHRcdHMyID0gMTtcblx0XHRcdH1cblx0XHRcdGlmIChwc3kgPCAwKSB7XG5cdFx0XHRcdHBzeSA9IC1wc3k7XG5cdFx0XHRcdHMyID0gLXMyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNzeCA8IDApIHtcblx0XHRcdFx0Y3N4ID0gLWNzeDtcblx0XHRcdFx0b3MyID0gMTgwO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvczIgPSAwO1xuXHRcdFx0dmFyIGN4ID0gY2hpbGQuYXgsIGN5ID0gMCwgY3d4ID0gMCwgY3d5ID0gMCwgYSA9IHBhcmVudC5hLCBiID0gcGFyZW50LmIsIGMgPSBwYXJlbnQuYywgZCA9IHBhcmVudC5kO1xuXHRcdFx0dmFyIHUgPSBNYXRoLmFicyhwc3ggLSBwc3kpIDw9IDAuMDAwMTtcblx0XHRcdGlmICghdSkge1xuXHRcdFx0XHRjeSA9IDA7XG5cdFx0XHRcdGN3eCA9IGEgKiBjeCArIHBhcmVudC53b3JsZFg7XG5cdFx0XHRcdGN3eSA9IGMgKiBjeCArIHBhcmVudC53b3JsZFk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y3kgPSBjaGlsZC5heTtcblx0XHRcdFx0Y3d4ID0gYSAqIGN4ICsgYiAqIGN5ICsgcGFyZW50LndvcmxkWDtcblx0XHRcdFx0Y3d5ID0gYyAqIGN4ICsgZCAqIGN5ICsgcGFyZW50LndvcmxkWTtcblx0XHRcdH1cblx0XHRcdHZhciBwcCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0XHRhID0gcHAuYTtcblx0XHRcdGIgPSBwcC5iO1xuXHRcdFx0YyA9IHBwLmM7XG5cdFx0XHRkID0gcHAuZDtcblx0XHRcdHZhciBpZCA9IDEgLyAoYSAqIGQgLSBiICogYyksIHggPSB0YXJnZXRYIC0gcHAud29ybGRYLCB5ID0gdGFyZ2V0WSAtIHBwLndvcmxkWTtcblx0XHRcdHZhciB0eCA9ICh4ICogZCAtIHkgKiBiKSAqIGlkIC0gcHgsIHR5ID0gKHkgKiBhIC0geCAqIGMpICogaWQgLSBweTtcblx0XHRcdHggPSBjd3ggLSBwcC53b3JsZFg7XG5cdFx0XHR5ID0gY3d5IC0gcHAud29ybGRZO1xuXHRcdFx0dmFyIGR4ID0gKHggKiBkIC0geSAqIGIpICogaWQgLSBweCwgZHkgPSAoeSAqIGEgLSB4ICogYykgKiBpZCAtIHB5O1xuXHRcdFx0dmFyIGwxID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgbDIgPSBjaGlsZC5kYXRhLmxlbmd0aCAqIGNzeCwgYTEgPSAwLCBhMiA9IDA7XG5cdFx0XHRvdXRlcjogaWYgKHUpIHtcblx0XHRcdFx0bDIgKj0gcHN4O1xuXHRcdFx0XHR2YXIgY29zID0gKHR4ICogdHggKyB0eSAqIHR5IC0gbDEgKiBsMSAtIGwyICogbDIpIC8gKDIgKiBsMSAqIGwyKTtcblx0XHRcdFx0aWYgKGNvcyA8IC0xKVxuXHRcdFx0XHRcdGNvcyA9IC0xO1xuXHRcdFx0XHRlbHNlIGlmIChjb3MgPiAxKVxuXHRcdFx0XHRcdGNvcyA9IDE7XG5cdFx0XHRcdGEyID0gTWF0aC5hY29zKGNvcykgKiBiZW5kRGlyO1xuXHRcdFx0XHRhID0gbDEgKyBsMiAqIGNvcztcblx0XHRcdFx0YiA9IGwyICogTWF0aC5zaW4oYTIpO1xuXHRcdFx0XHRhMSA9IE1hdGguYXRhbjIodHkgKiBhIC0gdHggKiBiLCB0eCAqIGEgKyB0eSAqIGIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGEgPSBwc3ggKiBsMjtcblx0XHRcdFx0YiA9IHBzeSAqIGwyO1xuXHRcdFx0XHR2YXIgYWEgPSBhICogYSwgYmIgPSBiICogYiwgZGQgPSB0eCAqIHR4ICsgdHkgKiB0eSwgdGEgPSBNYXRoLmF0YW4yKHR5LCB0eCk7XG5cdFx0XHRcdGMgPSBiYiAqIGwxICogbDEgKyBhYSAqIGRkIC0gYWEgKiBiYjtcblx0XHRcdFx0dmFyIGMxID0gLTIgKiBiYiAqIGwxLCBjMiA9IGJiIC0gYWE7XG5cdFx0XHRcdGQgPSBjMSAqIGMxIC0gNCAqIGMyICogYztcblx0XHRcdFx0aWYgKGQgPj0gMCkge1xuXHRcdFx0XHRcdHZhciBxID0gTWF0aC5zcXJ0KGQpO1xuXHRcdFx0XHRcdGlmIChjMSA8IDApXG5cdFx0XHRcdFx0XHRxID0gLXE7XG5cdFx0XHRcdFx0cSA9IC0oYzEgKyBxKSAvIDI7XG5cdFx0XHRcdFx0dmFyIHIwID0gcSAvIGMyLCByMSA9IGMgLyBxO1xuXHRcdFx0XHRcdHZhciByID0gTWF0aC5hYnMocjApIDwgTWF0aC5hYnMocjEpID8gcjAgOiByMTtcblx0XHRcdFx0XHRpZiAociAqIHIgPD0gZGQpIHtcblx0XHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoZGQgLSByICogcikgKiBiZW5kRGlyO1xuXHRcdFx0XHRcdFx0YTEgPSB0YSAtIE1hdGguYXRhbjIoeSwgcik7XG5cdFx0XHRcdFx0XHRhMiA9IE1hdGguYXRhbjIoeSAvIHBzeSwgKHIgLSBsMSkgLyBwc3gpO1xuXHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBtaW5BbmdsZSA9IHNwaW5lLk1hdGhVdGlscy5QSSwgbWluWCA9IGwxIC0gYSwgbWluRGlzdCA9IG1pblggKiBtaW5YLCBtaW5ZID0gMDtcblx0XHRcdFx0dmFyIG1heEFuZ2xlID0gMCwgbWF4WCA9IGwxICsgYSwgbWF4RGlzdCA9IG1heFggKiBtYXhYLCBtYXhZID0gMDtcblx0XHRcdFx0YyA9IC1hICogbDEgLyAoYWEgLSBiYik7XG5cdFx0XHRcdGlmIChjID49IC0xICYmIGMgPD0gMSkge1xuXHRcdFx0XHRcdGMgPSBNYXRoLmFjb3MoYyk7XG5cdFx0XHRcdFx0eCA9IGEgKiBNYXRoLmNvcyhjKSArIGwxO1xuXHRcdFx0XHRcdHkgPSBiICogTWF0aC5zaW4oYyk7XG5cdFx0XHRcdFx0ZCA9IHggKiB4ICsgeSAqIHk7XG5cdFx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0XHRtaW5BbmdsZSA9IGM7XG5cdFx0XHRcdFx0XHRtaW5EaXN0ID0gZDtcblx0XHRcdFx0XHRcdG1pblggPSB4O1xuXHRcdFx0XHRcdFx0bWluWSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkID4gbWF4RGlzdCkge1xuXHRcdFx0XHRcdFx0bWF4QW5nbGUgPSBjO1xuXHRcdFx0XHRcdFx0bWF4RGlzdCA9IGQ7XG5cdFx0XHRcdFx0XHRtYXhYID0geDtcblx0XHRcdFx0XHRcdG1heFkgPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGQgPD0gKG1pbkRpc3QgKyBtYXhEaXN0KSAvIDIpIHtcblx0XHRcdFx0XHRhMSA9IHRhIC0gTWF0aC5hdGFuMihtaW5ZICogYmVuZERpciwgbWluWCk7XG5cdFx0XHRcdFx0YTIgPSBtaW5BbmdsZSAqIGJlbmREaXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YTEgPSB0YSAtIE1hdGguYXRhbjIobWF4WSAqIGJlbmREaXIsIG1heFgpO1xuXHRcdFx0XHRcdGEyID0gbWF4QW5nbGUgKiBiZW5kRGlyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3MgPSBNYXRoLmF0YW4yKGN5LCBjeCkgKiBzMjtcblx0XHRcdHZhciByb3RhdGlvbiA9IHBhcmVudC5hcm90YXRpb247XG5cdFx0XHRhMSA9IChhMSAtIG9zKSAqIHNwaW5lLk1hdGhVdGlscy5yYWREZWcgKyBvczEgLSByb3RhdGlvbjtcblx0XHRcdGlmIChhMSA+IDE4MClcblx0XHRcdFx0YTEgLT0gMzYwO1xuXHRcdFx0ZWxzZSBpZiAoYTEgPCAtMTgwKVxuXHRcdFx0XHRhMSArPSAzNjA7XG5cdFx0XHRwYXJlbnQudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHB4LCBweSwgcm90YXRpb24gKyBhMSAqIGFscGhhLCBwYXJlbnQuYXNjYWxlWCwgcGFyZW50LmFzY2FsZVksIDAsIDApO1xuXHRcdFx0cm90YXRpb24gPSBjaGlsZC5hcm90YXRpb247XG5cdFx0XHRhMiA9ICgoYTIgKyBvcykgKiBzcGluZS5NYXRoVXRpbHMucmFkRGVnIC0gY2hpbGQuYXNoZWFyWCkgKiBzMiArIG9zMiAtIHJvdGF0aW9uO1xuXHRcdFx0aWYgKGEyID4gMTgwKVxuXHRcdFx0XHRhMiAtPSAzNjA7XG5cdFx0XHRlbHNlIGlmIChhMiA8IC0xODApXG5cdFx0XHRcdGEyICs9IDM2MDtcblx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aChjeCwgY3ksIHJvdGF0aW9uICsgYTIgKiBhbHBoYSwgY2hpbGQuYXNjYWxlWCwgY2hpbGQuYXNjYWxlWSwgY2hpbGQuYXNoZWFyWCwgY2hpbGQuYXNoZWFyWSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gSWtDb25zdHJhaW50O1xuXHR9KCkpO1xuXHRzcGluZS5Ja0NvbnN0cmFpbnQgPSBJa0NvbnN0cmFpbnQ7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgSWtDb25zdHJhaW50RGF0YSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gSWtDb25zdHJhaW50RGF0YShuYW1lKSB7XG5cdFx0XHR0aGlzLm9yZGVyID0gMDtcblx0XHRcdHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuYmVuZERpcmVjdGlvbiA9IDE7XG5cdFx0XHR0aGlzLm1peCA9IDE7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdH1cblx0XHRyZXR1cm4gSWtDb25zdHJhaW50RGF0YTtcblx0fSgpKTtcblx0c3BpbmUuSWtDb25zdHJhaW50RGF0YSA9IElrQ29uc3RyYWludERhdGE7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgUGF0aENvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50KGRhdGEsIHNrZWxldG9uKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gMDtcblx0XHRcdHRoaXMuc3BhY2luZyA9IDA7XG5cdFx0XHR0aGlzLnJvdGF0ZU1peCA9IDA7XG5cdFx0XHR0aGlzLnRyYW5zbGF0ZU1peCA9IDA7XG5cdFx0XHR0aGlzLnNwYWNlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5wb3NpdGlvbnMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMud29ybGQgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuY3VydmVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmxlbmd0aHMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuc2VnbWVudHMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKHNrZWxldG9uID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR0aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEuYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHR0aGlzLmJvbmVzLnB1c2goc2tlbGV0b24uZmluZEJvbmUoZGF0YS5ib25lc1tpXS5uYW1lKSk7XG5cdFx0XHR0aGlzLnRhcmdldCA9IHNrZWxldG9uLmZpbmRTbG90KGRhdGEudGFyZ2V0Lm5hbWUpO1xuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IGRhdGEucG9zaXRpb247XG5cdFx0XHR0aGlzLnNwYWNpbmcgPSBkYXRhLnNwYWNpbmc7XG5cdFx0XHR0aGlzLnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4O1xuXHRcdFx0dGhpcy50cmFuc2xhdGVNaXggPSBkYXRhLnRyYW5zbGF0ZU1peDtcblx0XHR9XG5cdFx0UGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHRcdFBhdGhDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXR0YWNobWVudCA9IHRoaXMudGFyZ2V0LmdldEF0dGFjaG1lbnQoKTtcblx0XHRcdGlmICghKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5QYXRoQXR0YWNobWVudCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXg7XG5cdFx0XHR2YXIgdHJhbnNsYXRlID0gdHJhbnNsYXRlTWl4ID4gMCwgcm90YXRlID0gcm90YXRlTWl4ID4gMDtcblx0XHRcdGlmICghdHJhbnNsYXRlICYmICFyb3RhdGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdFx0dmFyIHNwYWNpbmdNb2RlID0gZGF0YS5zcGFjaW5nTW9kZTtcblx0XHRcdHZhciBsZW5ndGhTcGFjaW5nID0gc3BhY2luZ01vZGUgPT0gc3BpbmUuU3BhY2luZ01vZGUuTGVuZ3RoO1xuXHRcdFx0dmFyIHJvdGF0ZU1vZGUgPSBkYXRhLnJvdGF0ZU1vZGU7XG5cdFx0XHR2YXIgdGFuZ2VudHMgPSByb3RhdGVNb2RlID09IHNwaW5lLlJvdGF0ZU1vZGUuVGFuZ2VudCwgc2NhbGUgPSByb3RhdGVNb2RlID09IHNwaW5lLlJvdGF0ZU1vZGUuQ2hhaW5TY2FsZTtcblx0XHRcdHZhciBib25lQ291bnQgPSB0aGlzLmJvbmVzLmxlbmd0aCwgc3BhY2VzQ291bnQgPSB0YW5nZW50cyA/IGJvbmVDb3VudCA6IGJvbmVDb3VudCArIDE7XG5cdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0dmFyIHNwYWNlcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLnNwYWNlcywgc3BhY2VzQ291bnQpLCBsZW5ndGhzID0gbnVsbDtcblx0XHRcdHZhciBzcGFjaW5nID0gdGhpcy5zcGFjaW5nO1xuXHRcdFx0aWYgKHNjYWxlIHx8IGxlbmd0aFNwYWNpbmcpIHtcblx0XHRcdFx0aWYgKHNjYWxlKVxuXHRcdFx0XHRcdGxlbmd0aHMgPSBzcGluZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy5sZW5ndGhzLCBib25lQ291bnQpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNwYWNlc0NvdW50IC0gMTsgaSA8IG47KSB7XG5cdFx0XHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdFx0XHR2YXIgc2V0dXBMZW5ndGggPSBib25lLmRhdGEubGVuZ3RoLCB4ID0gc2V0dXBMZW5ndGggKiBib25lLmEsIHkgPSBzZXR1cExlbmd0aCAqIGJvbmUuYztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoXzEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdFx0aWYgKHNjYWxlKVxuXHRcdFx0XHRcdFx0bGVuZ3Roc1tpXSA9IGxlbmd0aF8xO1xuXHRcdFx0XHRcdHNwYWNlc1srK2ldID0gKGxlbmd0aFNwYWNpbmcgPyBzZXR1cExlbmd0aCArIHNwYWNpbmcgOiBzcGFjaW5nKSAqIGxlbmd0aF8xIC8gc2V0dXBMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHNwYWNlc0NvdW50OyBpKyspXG5cdFx0XHRcdFx0c3BhY2VzW2ldID0gc3BhY2luZztcblx0XHRcdH1cblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmNvbXB1dGVXb3JsZFBvc2l0aW9ucyhhdHRhY2htZW50LCBzcGFjZXNDb3VudCwgdGFuZ2VudHMsIGRhdGEucG9zaXRpb25Nb2RlID09IHNwaW5lLlBvc2l0aW9uTW9kZS5QZXJjZW50LCBzcGFjaW5nTW9kZSA9PSBzcGluZS5TcGFjaW5nTW9kZS5QZXJjZW50KTtcblx0XHRcdHZhciBib25lWCA9IHBvc2l0aW9uc1swXSwgYm9uZVkgPSBwb3NpdGlvbnNbMV0sIG9mZnNldFJvdGF0aW9uID0gZGF0YS5vZmZzZXRSb3RhdGlvbjtcblx0XHRcdHZhciB0aXAgPSBmYWxzZTtcblx0XHRcdGlmIChvZmZzZXRSb3RhdGlvbiA9PSAwKVxuXHRcdFx0XHR0aXAgPSByb3RhdGVNb2RlID09IHNwaW5lLlJvdGF0ZU1vZGUuQ2hhaW47XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGlwID0gZmFsc2U7XG5cdFx0XHRcdHZhciBwID0gdGhpcy50YXJnZXQuYm9uZTtcblx0XHRcdFx0b2Zmc2V0Um90YXRpb24gKj0gcC5hICogcC5kIC0gcC5iICogcC5jID4gMCA/IHNwaW5lLk1hdGhVdGlscy5kZWdSYWQgOiAtc3BpbmUuTWF0aFV0aWxzLmRlZ1JhZDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBwID0gMzsgaSA8IGJvbmVDb3VudDsgaSsrLCBwICs9IDMpIHtcblx0XHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdFx0Ym9uZS53b3JsZFggKz0gKGJvbmVYIC0gYm9uZS53b3JsZFgpICogdHJhbnNsYXRlTWl4O1xuXHRcdFx0XHRib25lLndvcmxkWSArPSAoYm9uZVkgLSBib25lLndvcmxkWSkgKiB0cmFuc2xhdGVNaXg7XG5cdFx0XHRcdHZhciB4ID0gcG9zaXRpb25zW3BdLCB5ID0gcG9zaXRpb25zW3AgKyAxXSwgZHggPSB4IC0gYm9uZVgsIGR5ID0geSAtIGJvbmVZO1xuXHRcdFx0XHRpZiAoc2NhbGUpIHtcblx0XHRcdFx0XHR2YXIgbGVuZ3RoXzIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdGlmIChsZW5ndGhfMiAhPSAwKSB7XG5cdFx0XHRcdFx0XHR2YXIgcyA9IChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gbGVuZ3RoXzIgLSAxKSAqIHJvdGF0ZU1peCArIDE7XG5cdFx0XHRcdFx0XHRib25lLmEgKj0gcztcblx0XHRcdFx0XHRcdGJvbmUuYyAqPSBzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRib25lWCA9IHg7XG5cdFx0XHRcdGJvbmVZID0geTtcblx0XHRcdFx0aWYgKHJvdGF0ZSkge1xuXHRcdFx0XHRcdHZhciBhID0gYm9uZS5hLCBiID0gYm9uZS5iLCBjID0gYm9uZS5jLCBkID0gYm9uZS5kLCByID0gMCwgY29zID0gMCwgc2luID0gMDtcblx0XHRcdFx0XHRpZiAodGFuZ2VudHMpXG5cdFx0XHRcdFx0XHRyID0gcG9zaXRpb25zW3AgLSAxXTtcblx0XHRcdFx0XHRlbHNlIGlmIChzcGFjZXNbaSArIDFdID09IDApXG5cdFx0XHRcdFx0XHRyID0gcG9zaXRpb25zW3AgKyAyXTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuXHRcdFx0XHRcdHIgLT0gTWF0aC5hdGFuMihjLCBhKTtcblx0XHRcdFx0XHRpZiAodGlwKSB7XG5cdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdFx0XHRcdFx0dmFyIGxlbmd0aF8zID0gYm9uZS5kYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdGJvbmVYICs9IChsZW5ndGhfMyAqIChjb3MgKiBhIC0gc2luICogYykgLSBkeCkgKiByb3RhdGVNaXg7XG5cdFx0XHRcdFx0XHRib25lWSArPSAobGVuZ3RoXzMgKiAoc2luICogYSArIGNvcyAqIGMpIC0gZHkpICogcm90YXRlTWl4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHIgKz0gb2Zmc2V0Um90YXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyID4gc3BpbmUuTWF0aFV0aWxzLlBJKVxuXHRcdFx0XHRcdFx0ciAtPSBzcGluZS5NYXRoVXRpbHMuUEkyO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHIgPCAtc3BpbmUuTWF0aFV0aWxzLlBJKVxuXHRcdFx0XHRcdFx0ciArPSBzcGluZS5NYXRoVXRpbHMuUEkyO1xuXHRcdFx0XHRcdHIgKj0gcm90YXRlTWl4O1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKHIpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdFx0XHRcdGJvbmUuYSA9IGNvcyAqIGEgLSBzaW4gKiBjO1xuXHRcdFx0XHRcdGJvbmUuYiA9IGNvcyAqIGIgLSBzaW4gKiBkO1xuXHRcdFx0XHRcdGJvbmUuYyA9IHNpbiAqIGEgKyBjb3MgKiBjO1xuXHRcdFx0XHRcdGJvbmUuZCA9IHNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJvbmUuYXBwbGllZFZhbGlkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkUG9zaXRpb25zID0gZnVuY3Rpb24gKHBhdGgsIHNwYWNlc0NvdW50LCB0YW5nZW50cywgcGVyY2VudFBvc2l0aW9uLCBwZXJjZW50U3BhY2luZykge1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcblx0XHRcdHZhciBzcGFjZXMgPSB0aGlzLnNwYWNlcywgb3V0ID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMucG9zaXRpb25zLCBzcGFjZXNDb3VudCAqIDMgKyAyKSwgd29ybGQgPSBudWxsO1xuXHRcdFx0dmFyIGNsb3NlZCA9IHBhdGguY2xvc2VkO1xuXHRcdFx0dmFyIHZlcnRpY2VzTGVuZ3RoID0gcGF0aC53b3JsZFZlcnRpY2VzTGVuZ3RoLCBjdXJ2ZUNvdW50ID0gdmVydGljZXNMZW5ndGggLyA2LCBwcmV2Q3VydmUgPSBQYXRoQ29uc3RyYWludC5OT05FO1xuXHRcdFx0aWYgKCFwYXRoLmNvbnN0YW50U3BlZWQpIHtcblx0XHRcdFx0dmFyIGxlbmd0aHMgPSBwYXRoLmxlbmd0aHM7XG5cdFx0XHRcdGN1cnZlQ291bnQgLT0gY2xvc2VkID8gMSA6IDI7XG5cdFx0XHRcdHZhciBwYXRoTGVuZ3RoXzEgPSBsZW5ndGhzW2N1cnZlQ291bnRdO1xuXHRcdFx0XHRpZiAocGVyY2VudFBvc2l0aW9uKVxuXHRcdFx0XHRcdHBvc2l0aW9uICo9IHBhdGhMZW5ndGhfMTtcblx0XHRcdFx0aWYgKHBlcmNlbnRTcGFjaW5nKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZXNDb3VudDsgaSsrKVxuXHRcdFx0XHRcdFx0c3BhY2VzW2ldICo9IHBhdGhMZW5ndGhfMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3b3JsZCA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLndvcmxkLCA4KTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG8gPSAwLCBjdXJ2ZSA9IDA7IGkgPCBzcGFjZXNDb3VudDsgaSsrLCBvICs9IDMpIHtcblx0XHRcdFx0XHR2YXIgc3BhY2UgPSBzcGFjZXNbaV07XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gc3BhY2U7XG5cdFx0XHRcdFx0dmFyIHAgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHRwICU9IHBhdGhMZW5ndGhfMTtcblx0XHRcdFx0XHRcdGlmIChwIDwgMClcblx0XHRcdFx0XHRcdFx0cCArPSBwYXRoTGVuZ3RoXzE7XG5cdFx0XHRcdFx0XHRjdXJ2ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHAgPCAwKSB7XG5cdFx0XHRcdFx0XHRpZiAocHJldkN1cnZlICE9IFBhdGhDb25zdHJhaW50LkJFRk9SRSkge1xuXHRcdFx0XHRcdFx0XHRwcmV2Q3VydmUgPSBQYXRoQ29uc3RyYWludC5CRUZPUkU7XG5cdFx0XHRcdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAyLCA0LCB3b3JsZCwgMCwgMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZEJlZm9yZVBvc2l0aW9uKHAsIHdvcmxkLCAwLCBvdXQsIG8pO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHAgPiBwYXRoTGVuZ3RoXzEpIHtcblx0XHRcdFx0XHRcdGlmIChwcmV2Q3VydmUgIT0gUGF0aENvbnN0cmFpbnQuQUZURVIpIHtcblx0XHRcdFx0XHRcdFx0cHJldkN1cnZlID0gUGF0aENvbnN0cmFpbnQuQUZURVI7XG5cdFx0XHRcdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCB2ZXJ0aWNlc0xlbmd0aCAtIDYsIDQsIHdvcmxkLCAwLCAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuYWRkQWZ0ZXJQb3NpdGlvbihwIC0gcGF0aExlbmd0aF8xLCB3b3JsZCwgMCwgb3V0LCBvKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKDs7IGN1cnZlKyspIHtcblx0XHRcdFx0XHRcdHZhciBsZW5ndGhfNCA9IGxlbmd0aHNbY3VydmVdO1xuXHRcdFx0XHRcdFx0aWYgKHAgPiBsZW5ndGhfNClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRpZiAoY3VydmUgPT0gMClcblx0XHRcdFx0XHRcdFx0cCAvPSBsZW5ndGhfNDtcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJldiA9IGxlbmd0aHNbY3VydmUgLSAxXTtcblx0XHRcdFx0XHRcdFx0cCA9IChwIC0gcHJldikgLyAobGVuZ3RoXzQgLSBwcmV2KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3VydmUgIT0gcHJldkN1cnZlKSB7XG5cdFx0XHRcdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHRcdFx0XHRcdGlmIChjbG9zZWQgJiYgY3VydmUgPT0gY3VydmVDb3VudCkge1xuXHRcdFx0XHRcdFx0XHRwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgdmVydGljZXNMZW5ndGggLSA0LCA0LCB3b3JsZCwgMCwgMik7XG5cdFx0XHRcdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAwLCA0LCB3b3JsZCwgNCwgMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCBjdXJ2ZSAqIDYgKyAyLCA4LCB3b3JsZCwgMCwgMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuYWRkQ3VydmVQb3NpdGlvbihwLCB3b3JsZFswXSwgd29ybGRbMV0sIHdvcmxkWzJdLCB3b3JsZFszXSwgd29ybGRbNF0sIHdvcmxkWzVdLCB3b3JsZFs2XSwgd29ybGRbN10sIG91dCwgbywgdGFuZ2VudHMgfHwgKGkgPiAwICYmIHNwYWNlID09IDApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3V0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHR2ZXJ0aWNlc0xlbmd0aCArPSAyO1xuXHRcdFx0XHR3b3JsZCA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLndvcmxkLCB2ZXJ0aWNlc0xlbmd0aCk7XG5cdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAyLCB2ZXJ0aWNlc0xlbmd0aCAtIDQsIHdvcmxkLCAwLCAyKTtcblx0XHRcdFx0cGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIDAsIDIsIHdvcmxkLCB2ZXJ0aWNlc0xlbmd0aCAtIDQsIDIpO1xuXHRcdFx0XHR3b3JsZFt2ZXJ0aWNlc0xlbmd0aCAtIDJdID0gd29ybGRbMF07XG5cdFx0XHRcdHdvcmxkW3ZlcnRpY2VzTGVuZ3RoIC0gMV0gPSB3b3JsZFsxXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjdXJ2ZUNvdW50LS07XG5cdFx0XHRcdHZlcnRpY2VzTGVuZ3RoIC09IDQ7XG5cdFx0XHRcdHdvcmxkID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMud29ybGQsIHZlcnRpY2VzTGVuZ3RoKTtcblx0XHRcdFx0cGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIDIsIHZlcnRpY2VzTGVuZ3RoLCB3b3JsZCwgMCwgMik7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VydmVzID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMuY3VydmVzLCBjdXJ2ZUNvdW50KTtcblx0XHRcdHZhciBwYXRoTGVuZ3RoID0gMDtcblx0XHRcdHZhciB4MSA9IHdvcmxkWzBdLCB5MSA9IHdvcmxkWzFdLCBjeDEgPSAwLCBjeTEgPSAwLCBjeDIgPSAwLCBjeTIgPSAwLCB4MiA9IDAsIHkyID0gMDtcblx0XHRcdHZhciB0bXB4ID0gMCwgdG1weSA9IDAsIGRkZGZ4ID0gMCwgZGRkZnkgPSAwLCBkZGZ4ID0gMCwgZGRmeSA9IDAsIGRmeCA9IDAsIGRmeSA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgdyA9IDI7IGkgPCBjdXJ2ZUNvdW50OyBpKyssIHcgKz0gNikge1xuXHRcdFx0XHRjeDEgPSB3b3JsZFt3XTtcblx0XHRcdFx0Y3kxID0gd29ybGRbdyArIDFdO1xuXHRcdFx0XHRjeDIgPSB3b3JsZFt3ICsgMl07XG5cdFx0XHRcdGN5MiA9IHdvcmxkW3cgKyAzXTtcblx0XHRcdFx0eDIgPSB3b3JsZFt3ICsgNF07XG5cdFx0XHRcdHkyID0gd29ybGRbdyArIDVdO1xuXHRcdFx0XHR0bXB4ID0gKHgxIC0gY3gxICogMiArIGN4MikgKiAwLjE4NzU7XG5cdFx0XHRcdHRtcHkgPSAoeTEgLSBjeTEgKiAyICsgY3kyKSAqIDAuMTg3NTtcblx0XHRcdFx0ZGRkZnggPSAoKGN4MSAtIGN4MikgKiAzIC0geDEgKyB4MikgKiAwLjA5Mzc1O1xuXHRcdFx0XHRkZGRmeSA9ICgoY3kxIC0gY3kyKSAqIDMgLSB5MSArIHkyKSAqIDAuMDkzNzU7XG5cdFx0XHRcdGRkZnggPSB0bXB4ICogMiArIGRkZGZ4O1xuXHRcdFx0XHRkZGZ5ID0gdG1weSAqIDIgKyBkZGRmeTtcblx0XHRcdFx0ZGZ4ID0gKGN4MSAtIHgxKSAqIDAuNzUgKyB0bXB4ICsgZGRkZnggKiAwLjE2NjY2NjY3O1xuXHRcdFx0XHRkZnkgPSAoY3kxIC0geTEpICogMC43NSArIHRtcHkgKyBkZGRmeSAqIDAuMTY2NjY2Njc7XG5cdFx0XHRcdHBhdGhMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XG5cdFx0XHRcdGRmeCArPSBkZGZ4O1xuXHRcdFx0XHRkZnkgKz0gZGRmeTtcblx0XHRcdFx0ZGRmeCArPSBkZGRmeDtcblx0XHRcdFx0ZGRmeSArPSBkZGRmeTtcblx0XHRcdFx0cGF0aExlbmd0aCArPSBNYXRoLnNxcnQoZGZ4ICogZGZ4ICsgZGZ5ICogZGZ5KTtcblx0XHRcdFx0ZGZ4ICs9IGRkZng7XG5cdFx0XHRcdGRmeSArPSBkZGZ5O1xuXHRcdFx0XHRwYXRoTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xuXHRcdFx0XHRkZnggKz0gZGRmeCArIGRkZGZ4O1xuXHRcdFx0XHRkZnkgKz0gZGRmeSArIGRkZGZ5O1xuXHRcdFx0XHRwYXRoTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xuXHRcdFx0XHRjdXJ2ZXNbaV0gPSBwYXRoTGVuZ3RoO1xuXHRcdFx0XHR4MSA9IHgyO1xuXHRcdFx0XHR5MSA9IHkyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBlcmNlbnRQb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKj0gcGF0aExlbmd0aDtcblx0XHRcdGlmIChwZXJjZW50U3BhY2luZykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyspXG5cdFx0XHRcdFx0c3BhY2VzW2ldICo9IHBhdGhMZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuXHRcdFx0dmFyIGN1cnZlTGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBvID0gMCwgY3VydmUgPSAwLCBzZWdtZW50ID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyssIG8gKz0gMykge1xuXHRcdFx0XHR2YXIgc3BhY2UgPSBzcGFjZXNbaV07XG5cdFx0XHRcdHBvc2l0aW9uICs9IHNwYWNlO1xuXHRcdFx0XHR2YXIgcCA9IHBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdFx0cCAlPSBwYXRoTGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChwIDwgMClcblx0XHRcdFx0XHRcdHAgKz0gcGF0aExlbmd0aDtcblx0XHRcdFx0XHRjdXJ2ZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEJlZm9yZVBvc2l0aW9uKHAsIHdvcmxkLCAwLCBvdXQsIG8pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHAgPiBwYXRoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRBZnRlclBvc2l0aW9uKHAgLSBwYXRoTGVuZ3RoLCB3b3JsZCwgdmVydGljZXNMZW5ndGggLSA0LCBvdXQsIG8pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoOzsgY3VydmUrKykge1xuXHRcdFx0XHRcdHZhciBsZW5ndGhfNSA9IGN1cnZlc1tjdXJ2ZV07XG5cdFx0XHRcdFx0aWYgKHAgPiBsZW5ndGhfNSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmIChjdXJ2ZSA9PSAwKVxuXHRcdFx0XHRcdFx0cCAvPSBsZW5ndGhfNTtcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gY3VydmVzW2N1cnZlIC0gMV07XG5cdFx0XHRcdFx0XHRwID0gKHAgLSBwcmV2KSAvIChsZW5ndGhfNSAtIHByZXYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3VydmUgIT0gcHJldkN1cnZlKSB7XG5cdFx0XHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0XHRcdFx0dmFyIGlpID0gY3VydmUgKiA2O1xuXHRcdFx0XHRcdHgxID0gd29ybGRbaWldO1xuXHRcdFx0XHRcdHkxID0gd29ybGRbaWkgKyAxXTtcblx0XHRcdFx0XHRjeDEgPSB3b3JsZFtpaSArIDJdO1xuXHRcdFx0XHRcdGN5MSA9IHdvcmxkW2lpICsgM107XG5cdFx0XHRcdFx0Y3gyID0gd29ybGRbaWkgKyA0XTtcblx0XHRcdFx0XHRjeTIgPSB3b3JsZFtpaSArIDVdO1xuXHRcdFx0XHRcdHgyID0gd29ybGRbaWkgKyA2XTtcblx0XHRcdFx0XHR5MiA9IHdvcmxkW2lpICsgN107XG5cdFx0XHRcdFx0dG1weCA9ICh4MSAtIGN4MSAqIDIgKyBjeDIpICogMC4wMztcblx0XHRcdFx0XHR0bXB5ID0gKHkxIC0gY3kxICogMiArIGN5MikgKiAwLjAzO1xuXHRcdFx0XHRcdGRkZGZ4ID0gKChjeDEgLSBjeDIpICogMyAtIHgxICsgeDIpICogMC4wMDY7XG5cdFx0XHRcdFx0ZGRkZnkgPSAoKGN5MSAtIGN5MikgKiAzIC0geTEgKyB5MikgKiAwLjAwNjtcblx0XHRcdFx0XHRkZGZ4ID0gdG1weCAqIDIgKyBkZGRmeDtcblx0XHRcdFx0XHRkZGZ5ID0gdG1weSAqIDIgKyBkZGRmeTtcblx0XHRcdFx0XHRkZnggPSAoY3gxIC0geDEpICogMC4zICsgdG1weCArIGRkZGZ4ICogMC4xNjY2NjY2Nztcblx0XHRcdFx0XHRkZnkgPSAoY3kxIC0geTEpICogMC4zICsgdG1weSArIGRkZGZ5ICogMC4xNjY2NjY2Nztcblx0XHRcdFx0XHRjdXJ2ZUxlbmd0aCA9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xuXHRcdFx0XHRcdHNlZ21lbnRzWzBdID0gY3VydmVMZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpaSA9IDE7IGlpIDwgODsgaWkrKykge1xuXHRcdFx0XHRcdFx0ZGZ4ICs9IGRkZng7XG5cdFx0XHRcdFx0XHRkZnkgKz0gZGRmeTtcblx0XHRcdFx0XHRcdGRkZnggKz0gZGRkZng7XG5cdFx0XHRcdFx0XHRkZGZ5ICs9IGRkZGZ5O1xuXHRcdFx0XHRcdFx0Y3VydmVMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XG5cdFx0XHRcdFx0XHRzZWdtZW50c1tpaV0gPSBjdXJ2ZUxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGZ4ICs9IGRkZng7XG5cdFx0XHRcdFx0ZGZ5ICs9IGRkZnk7XG5cdFx0XHRcdFx0Y3VydmVMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XG5cdFx0XHRcdFx0c2VnbWVudHNbOF0gPSBjdXJ2ZUxlbmd0aDtcblx0XHRcdFx0XHRkZnggKz0gZGRmeCArIGRkZGZ4O1xuXHRcdFx0XHRcdGRmeSArPSBkZGZ5ICsgZGRkZnk7XG5cdFx0XHRcdFx0Y3VydmVMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XG5cdFx0XHRcdFx0c2VnbWVudHNbOV0gPSBjdXJ2ZUxlbmd0aDtcblx0XHRcdFx0XHRzZWdtZW50ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwICo9IGN1cnZlTGVuZ3RoO1xuXHRcdFx0XHRmb3IgKDs7IHNlZ21lbnQrKykge1xuXHRcdFx0XHRcdHZhciBsZW5ndGhfNiA9IHNlZ21lbnRzW3NlZ21lbnRdO1xuXHRcdFx0XHRcdGlmIChwID4gbGVuZ3RoXzYpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAoc2VnbWVudCA9PSAwKVxuXHRcdFx0XHRcdFx0cCAvPSBsZW5ndGhfNjtcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gc2VnbWVudHNbc2VnbWVudCAtIDFdO1xuXHRcdFx0XHRcdFx0cCA9IHNlZ21lbnQgKyAocCAtIHByZXYpIC8gKGxlbmd0aF82IC0gcHJldik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkQ3VydmVQb3NpdGlvbihwICogMC4xLCB4MSwgeTEsIGN4MSwgY3kxLCBjeDIsIGN5MiwgeDIsIHkyLCBvdXQsIG8sIHRhbmdlbnRzIHx8IChpID4gMCAmJiBzcGFjZSA9PSAwKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH07XG5cdFx0UGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFkZEJlZm9yZVBvc2l0aW9uID0gZnVuY3Rpb24gKHAsIHRlbXAsIGksIG91dCwgbykge1xuXHRcdFx0dmFyIHgxID0gdGVtcFtpXSwgeTEgPSB0ZW1wW2kgKyAxXSwgZHggPSB0ZW1wW2kgKyAyXSAtIHgxLCBkeSA9IHRlbXBbaSArIDNdIC0geTEsIHIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cdFx0XHRvdXRbb10gPSB4MSArIHAgKiBNYXRoLmNvcyhyKTtcblx0XHRcdG91dFtvICsgMV0gPSB5MSArIHAgKiBNYXRoLnNpbihyKTtcblx0XHRcdG91dFtvICsgMl0gPSByO1xuXHRcdH07XG5cdFx0UGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFkZEFmdGVyUG9zaXRpb24gPSBmdW5jdGlvbiAocCwgdGVtcCwgaSwgb3V0LCBvKSB7XG5cdFx0XHR2YXIgeDEgPSB0ZW1wW2kgKyAyXSwgeTEgPSB0ZW1wW2kgKyAzXSwgZHggPSB4MSAtIHRlbXBbaV0sIGR5ID0geTEgLSB0ZW1wW2kgKyAxXSwgciA9IE1hdGguYXRhbjIoZHksIGR4KTtcblx0XHRcdG91dFtvXSA9IHgxICsgcCAqIE1hdGguY29zKHIpO1xuXHRcdFx0b3V0W28gKyAxXSA9IHkxICsgcCAqIE1hdGguc2luKHIpO1xuXHRcdFx0b3V0W28gKyAyXSA9IHI7XG5cdFx0fTtcblx0XHRQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuYWRkQ3VydmVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwLCB4MSwgeTEsIGN4MSwgY3kxLCBjeDIsIGN5MiwgeDIsIHkyLCBvdXQsIG8sIHRhbmdlbnRzKSB7XG5cdFx0XHRpZiAocCA9PSAwIHx8IGlzTmFOKHApKVxuXHRcdFx0XHRwID0gMC4wMDAxO1xuXHRcdFx0dmFyIHR0ID0gcCAqIHAsIHR0dCA9IHR0ICogcCwgdSA9IDEgLSBwLCB1dSA9IHUgKiB1LCB1dXUgPSB1dSAqIHU7XG5cdFx0XHR2YXIgdXQgPSB1ICogcCwgdXQzID0gdXQgKiAzLCB1dXQzID0gdSAqIHV0MywgdXR0MyA9IHV0MyAqIHA7XG5cdFx0XHR2YXIgeCA9IHgxICogdXV1ICsgY3gxICogdXV0MyArIGN4MiAqIHV0dDMgKyB4MiAqIHR0dCwgeSA9IHkxICogdXV1ICsgY3kxICogdXV0MyArIGN5MiAqIHV0dDMgKyB5MiAqIHR0dDtcblx0XHRcdG91dFtvXSA9IHg7XG5cdFx0XHRvdXRbbyArIDFdID0geTtcblx0XHRcdGlmICh0YW5nZW50cylcblx0XHRcdFx0b3V0W28gKyAyXSA9IE1hdGguYXRhbjIoeSAtICh5MSAqIHV1ICsgY3kxICogdXQgKiAyICsgY3kyICogdHQpLCB4IC0gKHgxICogdXUgKyBjeDEgKiB1dCAqIDIgKyBjeDIgKiB0dCkpO1xuXHRcdH07XG5cdFx0UGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmdldE9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5vcmRlcjtcblx0XHR9O1xuXHRcdFBhdGhDb25zdHJhaW50Lk5PTkUgPSAtMTtcblx0XHRQYXRoQ29uc3RyYWludC5CRUZPUkUgPSAtMjtcblx0XHRQYXRoQ29uc3RyYWludC5BRlRFUiA9IC0zO1xuXHRcdHJldHVybiBQYXRoQ29uc3RyYWludDtcblx0fSgpKTtcblx0c3BpbmUuUGF0aENvbnN0cmFpbnQgPSBQYXRoQ29uc3RyYWludDtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBQYXRoQ29uc3RyYWludERhdGEgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50RGF0YShuYW1lKSB7XG5cdFx0XHR0aGlzLm9yZGVyID0gMDtcblx0XHRcdHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0fVxuXHRcdHJldHVybiBQYXRoQ29uc3RyYWludERhdGE7XG5cdH0oKSk7XG5cdHNwaW5lLlBhdGhDb25zdHJhaW50RGF0YSA9IFBhdGhDb25zdHJhaW50RGF0YTtcblx0KGZ1bmN0aW9uIChQb3NpdGlvbk1vZGUpIHtcblx0XHRQb3NpdGlvbk1vZGVbUG9zaXRpb25Nb2RlW1wiRml4ZWRcIl0gPSAwXSA9IFwiRml4ZWRcIjtcblx0XHRQb3NpdGlvbk1vZGVbUG9zaXRpb25Nb2RlW1wiUGVyY2VudFwiXSA9IDFdID0gXCJQZXJjZW50XCI7XG5cdH0pKHNwaW5lLlBvc2l0aW9uTW9kZSB8fCAoc3BpbmUuUG9zaXRpb25Nb2RlID0ge30pKTtcblx0dmFyIFBvc2l0aW9uTW9kZSA9IHNwaW5lLlBvc2l0aW9uTW9kZTtcblx0KGZ1bmN0aW9uIChTcGFjaW5nTW9kZSkge1xuXHRcdFNwYWNpbmdNb2RlW1NwYWNpbmdNb2RlW1wiTGVuZ3RoXCJdID0gMF0gPSBcIkxlbmd0aFwiO1xuXHRcdFNwYWNpbmdNb2RlW1NwYWNpbmdNb2RlW1wiRml4ZWRcIl0gPSAxXSA9IFwiRml4ZWRcIjtcblx0XHRTcGFjaW5nTW9kZVtTcGFjaW5nTW9kZVtcIlBlcmNlbnRcIl0gPSAyXSA9IFwiUGVyY2VudFwiO1xuXHR9KShzcGluZS5TcGFjaW5nTW9kZSB8fCAoc3BpbmUuU3BhY2luZ01vZGUgPSB7fSkpO1xuXHR2YXIgU3BhY2luZ01vZGUgPSBzcGluZS5TcGFjaW5nTW9kZTtcblx0KGZ1bmN0aW9uIChSb3RhdGVNb2RlKSB7XG5cdFx0Um90YXRlTW9kZVtSb3RhdGVNb2RlW1wiVGFuZ2VudFwiXSA9IDBdID0gXCJUYW5nZW50XCI7XG5cdFx0Um90YXRlTW9kZVtSb3RhdGVNb2RlW1wiQ2hhaW5cIl0gPSAxXSA9IFwiQ2hhaW5cIjtcblx0XHRSb3RhdGVNb2RlW1JvdGF0ZU1vZGVbXCJDaGFpblNjYWxlXCJdID0gMl0gPSBcIkNoYWluU2NhbGVcIjtcblx0fSkoc3BpbmUuUm90YXRlTW9kZSB8fCAoc3BpbmUuUm90YXRlTW9kZSA9IHt9KSk7XG5cdHZhciBSb3RhdGVNb2RlID0gc3BpbmUuUm90YXRlTW9kZTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBBc3NldHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEFzc2V0cyhjbGllbnRJZCkge1xuXHRcdFx0dGhpcy50b0xvYWQgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuYXNzZXRzID0ge307XG5cdFx0XHR0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG5cdFx0fVxuXHRcdEFzc2V0cy5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICh2YXIgdiBpbiB0aGlzLmFzc2V0cylcblx0XHRcdFx0aSsrO1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fTtcblx0XHRyZXR1cm4gQXNzZXRzO1xuXHR9KCkpO1xuXHR2YXIgU2hhcmVkQXNzZXRNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBTaGFyZWRBc3NldE1hbmFnZXIocGF0aFByZWZpeCkge1xuXHRcdFx0aWYgKHBhdGhQcmVmaXggPT09IHZvaWQgMCkgeyBwYXRoUHJlZml4ID0gXCJcIjsgfVxuXHRcdFx0dGhpcy5jbGllbnRBc3NldHMgPSB7fTtcblx0XHRcdHRoaXMucXVldWVkQXNzZXRzID0ge307XG5cdFx0XHR0aGlzLnJhd0Fzc2V0cyA9IHt9O1xuXHRcdFx0dGhpcy5lcnJvcnMgPSB7fTtcblx0XHRcdHRoaXMucGF0aFByZWZpeCA9IHBhdGhQcmVmaXg7XG5cdFx0fVxuXHRcdFNoYXJlZEFzc2V0TWFuYWdlci5wcm90b3R5cGUucXVldWVBc3NldCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgdGV4dHVyZUxvYWRlciwgcGF0aCkge1xuXHRcdFx0dmFyIGNsaWVudEFzc2V0cyA9IHRoaXMuY2xpZW50QXNzZXRzW2NsaWVudElkXTtcblx0XHRcdGlmIChjbGllbnRBc3NldHMgPT09IG51bGwgfHwgY2xpZW50QXNzZXRzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2xpZW50QXNzZXRzID0gbmV3IEFzc2V0cyhjbGllbnRJZCk7XG5cdFx0XHRcdHRoaXMuY2xpZW50QXNzZXRzW2NsaWVudElkXSA9IGNsaWVudEFzc2V0cztcblx0XHRcdH1cblx0XHRcdGlmICh0ZXh0dXJlTG9hZGVyICE9PSBudWxsKVxuXHRcdFx0XHRjbGllbnRBc3NldHMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG5cdFx0XHRjbGllbnRBc3NldHMudG9Mb2FkLnB1c2gocGF0aCk7XG5cdFx0XHRpZiAodGhpcy5xdWV1ZWRBc3NldHNbcGF0aF0gPT09IHBhdGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMucXVldWVkQXNzZXRzW3BhdGhdID0gcGF0aDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTaGFyZWRBc3NldE1hbmFnZXIucHJvdG90eXBlLmxvYWRUZXh0ID0gZnVuY3Rpb24gKGNsaWVudElkLCBwYXRoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0cGF0aCA9IHRoaXMucGF0aFByZWZpeCArIHBhdGg7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVBc3NldChjbGllbnRJZCwgbnVsbCwgcGF0aCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG5cdFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDMwMCkge1xuXHRcdFx0XHRcdFx0X3RoaXMucmF3QXNzZXRzW3BhdGhdID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X3RoaXMuZXJyb3JzW3BhdGhdID0gXCJDb3VsZG4ndCBsb2FkIHRleHQgXCIgKyBwYXRoICsgXCI6IHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIsIFwiICsgcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xuXHRcdFx0cmVxdWVzdC5zZW5kKCk7XG5cdFx0fTtcblx0XHRTaGFyZWRBc3NldE1hbmFnZXIucHJvdG90eXBlLmxvYWRKc29uID0gZnVuY3Rpb24gKGNsaWVudElkLCBwYXRoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0cGF0aCA9IHRoaXMucGF0aFByZWZpeCArIHBhdGg7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVBc3NldChjbGllbnRJZCwgbnVsbCwgcGF0aCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG5cdFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDMwMCkge1xuXHRcdFx0XHRcdFx0X3RoaXMucmF3QXNzZXRzW3BhdGhdID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X3RoaXMuZXJyb3JzW3BhdGhdID0gXCJDb3VsZG4ndCBsb2FkIHRleHQgXCIgKyBwYXRoICsgXCI6IHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIsIFwiICsgcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xuXHRcdFx0cmVxdWVzdC5zZW5kKCk7XG5cdFx0fTtcblx0XHRTaGFyZWRBc3NldE1hbmFnZXIucHJvdG90eXBlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKGNsaWVudElkLCB0ZXh0dXJlTG9hZGVyLCBwYXRoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0cGF0aCA9IHRoaXMucGF0aFByZWZpeCArIHBhdGg7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVBc3NldChjbGllbnRJZCwgdGV4dHVyZUxvYWRlciwgcGF0aCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdGltZy5zcmMgPSBwYXRoO1xuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcblx0XHRcdGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdFx0X3RoaXMucmF3QXNzZXRzW3BhdGhdID0gaW1nO1xuXHRcdFx0fTtcblx0XHRcdGltZy5vbmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdF90aGlzLmVycm9yc1twYXRoXSA9IFwiQ291bGRuJ3QgbG9hZCBpbWFnZSBcIiArIHBhdGg7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0U2hhcmVkQXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoY2xpZW50SWQsIHBhdGgpIHtcblx0XHRcdHBhdGggPSB0aGlzLnBhdGhQcmVmaXggKyBwYXRoO1xuXHRcdFx0dmFyIGNsaWVudEFzc2V0cyA9IHRoaXMuY2xpZW50QXNzZXRzW2NsaWVudElkXTtcblx0XHRcdGlmIChjbGllbnRBc3NldHMgPT09IG51bGwgfHwgY2xpZW50QXNzZXRzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGNsaWVudEFzc2V0cy5hc3NldHNbcGF0aF07XG5cdFx0fTtcblx0XHRTaGFyZWRBc3NldE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUNsaWVudEFzc2V0cyA9IGZ1bmN0aW9uIChjbGllbnRBc3NldHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2xpZW50QXNzZXRzLnRvTG9hZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IGNsaWVudEFzc2V0cy50b0xvYWRbaV07XG5cdFx0XHRcdHZhciBhc3NldCA9IGNsaWVudEFzc2V0cy5hc3NldHNbcGF0aF07XG5cdFx0XHRcdGlmIChhc3NldCA9PT0gbnVsbCB8fCBhc3NldCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFyIHJhd0Fzc2V0ID0gdGhpcy5yYXdBc3NldHNbcGF0aF07XG5cdFx0XHRcdFx0aWYgKHJhd0Fzc2V0ID09PSBudWxsIHx8IHJhd0Fzc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAocmF3QXNzZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjbGllbnRBc3NldHMuYXNzZXRzW3BhdGhdID0gY2xpZW50QXNzZXRzLnRleHR1cmVMb2FkZXIocmF3QXNzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNsaWVudEFzc2V0cy5hc3NldHNbcGF0aF0gPSByYXdBc3NldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFNoYXJlZEFzc2V0TWFuYWdlci5wcm90b3R5cGUuaXNMb2FkaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoY2xpZW50SWQpIHtcblx0XHRcdHZhciBjbGllbnRBc3NldHMgPSB0aGlzLmNsaWVudEFzc2V0c1tjbGllbnRJZF07XG5cdFx0XHRpZiAoY2xpZW50QXNzZXRzID09PSBudWxsIHx8IGNsaWVudEFzc2V0cyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHRoaXMudXBkYXRlQ2xpZW50QXNzZXRzKGNsaWVudEFzc2V0cyk7XG5cdFx0XHRyZXR1cm4gY2xpZW50QXNzZXRzLnRvTG9hZC5sZW5ndGggPT0gY2xpZW50QXNzZXRzLmxvYWRlZCgpO1xuXHRcdH07XG5cdFx0U2hhcmVkQXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdH07XG5cdFx0U2hhcmVkQXNzZXRNYW5hZ2VyLnByb3RvdHlwZS5oYXNFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmxlbmd0aCA+IDA7XG5cdFx0fTtcblx0XHRTaGFyZWRBc3NldE1hbmFnZXIucHJvdG90eXBlLmdldEVycm9ycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmVycm9ycztcblx0XHR9O1xuXHRcdHJldHVybiBTaGFyZWRBc3NldE1hbmFnZXI7XG5cdH0oKSk7XG5cdHNwaW5lLlNoYXJlZEFzc2V0TWFuYWdlciA9IFNoYXJlZEFzc2V0TWFuYWdlcjtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBTa2VsZXRvbiA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gU2tlbGV0b24oZGF0YSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ2FjaGUgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMudXBkYXRlQ2FjaGVSZXNldCA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy50aW1lID0gMDtcblx0XHRcdHRoaXMuZmxpcFggPSBmYWxzZTtcblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0dGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmJvbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBib25lRGF0YSA9IGRhdGEuYm9uZXNbaV07XG5cdFx0XHRcdHZhciBib25lID0gdm9pZCAwO1xuXHRcdFx0XHRpZiAoYm9uZURhdGEucGFyZW50ID09IG51bGwpXG5cdFx0XHRcdFx0Ym9uZSA9IG5ldyBzcGluZS5Cb25lKGJvbmVEYXRhLCB0aGlzLCBudWxsKTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHBhcmVudF8xID0gdGhpcy5ib25lc1tib25lRGF0YS5wYXJlbnQuaW5kZXhdO1xuXHRcdFx0XHRcdGJvbmUgPSBuZXcgc3BpbmUuQm9uZShib25lRGF0YSwgdGhpcywgcGFyZW50XzEpO1xuXHRcdFx0XHRcdHBhcmVudF8xLmNoaWxkcmVuLnB1c2goYm9uZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ib25lcy5wdXNoKGJvbmUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zbG90cyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5kcmF3T3JkZXIgPSBuZXcgQXJyYXkoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zbG90cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgc2xvdERhdGEgPSBkYXRhLnNsb3RzW2ldO1xuXHRcdFx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbc2xvdERhdGEuYm9uZURhdGEuaW5kZXhdO1xuXHRcdFx0XHR2YXIgc2xvdCA9IG5ldyBzcGluZS5TbG90KHNsb3REYXRhLCBib25lKTtcblx0XHRcdFx0dGhpcy5zbG90cy5wdXNoKHNsb3QpO1xuXHRcdFx0XHR0aGlzLmRyYXdPcmRlci5wdXNoKHNsb3QpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pa0NvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuaWtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgaWtDb25zdHJhaW50RGF0YSA9IGRhdGEuaWtDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0dGhpcy5pa0NvbnN0cmFpbnRzLnB1c2gobmV3IHNwaW5lLklrQ29uc3RyYWludChpa0NvbnN0cmFpbnREYXRhLCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEudHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHRyYW5zZm9ybUNvbnN0cmFpbnREYXRhID0gZGF0YS50cmFuc2Zvcm1Db25zdHJhaW50c1tpXTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cy5wdXNoKG5ldyBzcGluZS5UcmFuc2Zvcm1Db25zdHJhaW50KHRyYW5zZm9ybUNvbnN0cmFpbnREYXRhLCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBhdGhDb25zdHJhaW50cyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnBhdGhDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aENvbnN0cmFpbnREYXRhID0gZGF0YS5wYXRoQ29uc3RyYWludHNbaV07XG5cdFx0XHRcdHRoaXMucGF0aENvbnN0cmFpbnRzLnB1c2gobmV3IHNwaW5lLlBhdGhDb25zdHJhaW50KHBhdGhDb25zdHJhaW50RGF0YSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBzcGluZS5Db2xvcigxLCAxLCAxLCAxKTtcblx0XHRcdHRoaXMudXBkYXRlQ2FjaGUoKTtcblx0XHR9XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHVwZGF0ZUNhY2hlID0gdGhpcy5fdXBkYXRlQ2FjaGU7XG5cdFx0XHR1cGRhdGVDYWNoZS5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51cGRhdGVDYWNoZVJlc2V0Lmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdGJvbmVzW2ldLnNvcnRlZCA9IGZhbHNlO1xuXHRcdFx0dmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XG5cdFx0XHR2YXIgdHJhbnNmb3JtQ29uc3RyYWludHMgPSB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzO1xuXHRcdFx0dmFyIHBhdGhDb25zdHJhaW50cyA9IHRoaXMucGF0aENvbnN0cmFpbnRzO1xuXHRcdFx0dmFyIGlrQ291bnQgPSBpa0NvbnN0cmFpbnRzLmxlbmd0aCwgdHJhbnNmb3JtQ291bnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50cy5sZW5ndGgsIHBhdGhDb3VudCA9IHBhdGhDb25zdHJhaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgY29uc3RyYWludENvdW50ID0gaWtDb3VudCArIHRyYW5zZm9ybUNvdW50ICsgcGF0aENvdW50O1xuXHRcdFx0b3V0ZXI6IGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludENvdW50OyBpKyspIHtcblx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGlrQ291bnQ7IGlpKyspIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludCA9IGlrQ29uc3RyYWludHNbaWldO1xuXHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmRhdGEub3JkZXIgPT0gaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0SWtDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRcdFx0Y29udGludWUgb3V0ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCB0cmFuc2Zvcm1Db3VudDsgaWkrKykge1xuXHRcdFx0XHRcdHZhciBjb25zdHJhaW50ID0gdHJhbnNmb3JtQ29uc3RyYWludHNbaWldO1xuXHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmRhdGEub3JkZXIgPT0gaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0VHJhbnNmb3JtQ29uc3RyYWludChjb25zdHJhaW50KTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlIG91dGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBpaSA9IDA7IGlpIDwgcGF0aENvdW50OyBpaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnN0cmFpbnQgPSBwYXRoQ29uc3RyYWludHNbaWldO1xuXHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmRhdGEub3JkZXIgPT0gaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0UGF0aENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZSBvdXRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHR0aGlzLnNvcnRCb25lKGJvbmVzW2ldKTtcblx0XHR9O1xuXHRcdFNrZWxldG9uLnByb3RvdHlwZS5zb3J0SWtDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcblx0XHRcdHZhciB0YXJnZXQgPSBjb25zdHJhaW50LnRhcmdldDtcblx0XHRcdHRoaXMuc29ydEJvbmUodGFyZ2V0KTtcblx0XHRcdHZhciBjb25zdHJhaW5lZCA9IGNvbnN0cmFpbnQuYm9uZXM7XG5cdFx0XHR2YXIgcGFyZW50ID0gY29uc3RyYWluZWRbMF07XG5cdFx0XHR0aGlzLnNvcnRCb25lKHBhcmVudCk7XG5cdFx0XHRpZiAoY29uc3RyYWluZWQubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjb25zdHJhaW5lZFtjb25zdHJhaW5lZC5sZW5ndGggLSAxXTtcblx0XHRcdFx0aWYgKCEodGhpcy5fdXBkYXRlQ2FjaGUuaW5kZXhPZihjaGlsZCkgPiAtMSkpXG5cdFx0XHRcdFx0dGhpcy51cGRhdGVDYWNoZVJlc2V0LnB1c2goY2hpbGQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlQ2FjaGUucHVzaChjb25zdHJhaW50KTtcblx0XHRcdHRoaXMuc29ydFJlc2V0KHBhcmVudC5jaGlsZHJlbik7XG5cdFx0XHRjb25zdHJhaW5lZFtjb25zdHJhaW5lZC5sZW5ndGggLSAxXS5zb3J0ZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLnNvcnRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG5cdFx0XHR2YXIgc2xvdCA9IGNvbnN0cmFpbnQudGFyZ2V0O1xuXHRcdFx0dmFyIHNsb3RJbmRleCA9IHNsb3QuZGF0YS5pbmRleDtcblx0XHRcdHZhciBzbG90Qm9uZSA9IHNsb3QuYm9uZTtcblx0XHRcdGlmICh0aGlzLnNraW4gIT0gbnVsbClcblx0XHRcdFx0dGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50KHRoaXMuc2tpbiwgc2xvdEluZGV4LCBzbG90Qm9uZSk7XG5cdFx0XHRpZiAodGhpcy5kYXRhLmRlZmF1bHRTa2luICE9IG51bGwgJiYgdGhpcy5kYXRhLmRlZmF1bHRTa2luICE9IHRoaXMuc2tpbilcblx0XHRcdFx0dGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50KHRoaXMuZGF0YS5kZWZhdWx0U2tpbiwgc2xvdEluZGV4LCBzbG90Qm9uZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuZGF0YS5za2lucy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCh0aGlzLmRhdGEuc2tpbnNbaV0sIHNsb3RJbmRleCwgc2xvdEJvbmUpO1xuXHRcdFx0dmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcblx0XHRcdGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUGF0aEF0dGFjaG1lbnQpXG5cdFx0XHRcdHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudFdpdGgoYXR0YWNobWVudCwgc2xvdEJvbmUpO1xuXHRcdFx0dmFyIGNvbnN0cmFpbmVkID0gY29uc3RyYWludC5ib25lcztcblx0XHRcdHZhciBib25lQ291bnQgPSBjb25zdHJhaW5lZC5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKVxuXHRcdFx0XHR0aGlzLnNvcnRCb25lKGNvbnN0cmFpbmVkW2ldKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKVxuXHRcdFx0XHR0aGlzLnNvcnRSZXNldChjb25zdHJhaW5lZFtpXS5jaGlsZHJlbik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKVxuXHRcdFx0XHRjb25zdHJhaW5lZFtpXS5zb3J0ZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLnNvcnRUcmFuc2Zvcm1Db25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcblx0XHRcdHRoaXMuc29ydEJvbmUoY29uc3RyYWludC50YXJnZXQpO1xuXHRcdFx0dmFyIGNvbnN0cmFpbmVkID0gY29uc3RyYWludC5ib25lcztcblx0XHRcdHZhciBib25lQ291bnQgPSBjb25zdHJhaW5lZC5sZW5ndGg7XG5cdFx0XHRpZiAoY29uc3RyYWludC5kYXRhLmxvY2FsKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjb25zdHJhaW5lZFtpXTtcblx0XHRcdFx0XHR0aGlzLnNvcnRCb25lKGNoaWxkLnBhcmVudCk7XG5cdFx0XHRcdFx0aWYgKCEodGhpcy5fdXBkYXRlQ2FjaGUuaW5kZXhPZihjaGlsZCkgPiAtMSkpXG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZUNhY2hlUmVzZXQucHVzaChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zb3J0Qm9uZShjb25zdHJhaW5lZFtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRmb3IgKHZhciBpaSA9IDA7IGlpIDwgYm9uZUNvdW50OyBpaSsrKVxuXHRcdFx0XHR0aGlzLnNvcnRSZXNldChjb25zdHJhaW5lZFtpaV0uY2hpbGRyZW4pO1xuXHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IGJvbmVDb3VudDsgaWkrKylcblx0XHRcdFx0Y29uc3RyYWluZWRbaWldLnNvcnRlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBzbG90SW5kZXgsIHNsb3RCb25lKSB7XG5cdFx0XHR2YXIgYXR0YWNobWVudHMgPSBza2luLmF0dGFjaG1lbnRzW3Nsb3RJbmRleF07XG5cdFx0XHRpZiAoIWF0dGFjaG1lbnRzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXR0YWNobWVudHMpIHtcblx0XHRcdFx0dGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50V2l0aChhdHRhY2htZW50c1trZXldLCBzbG90Qm9uZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudFdpdGggPSBmdW5jdGlvbiAoYXR0YWNobWVudCwgc2xvdEJvbmUpIHtcblx0XHRcdGlmICghKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5QYXRoQXR0YWNobWVudCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBwYXRoQm9uZXMgPSBhdHRhY2htZW50LmJvbmVzO1xuXHRcdFx0aWYgKHBhdGhCb25lcyA9PSBudWxsKVxuXHRcdFx0XHR0aGlzLnNvcnRCb25lKHNsb3RCb25lKTtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRcdHdoaWxlIChpIDwgcGF0aEJvbmVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBib25lQ291bnQgPSBwYXRoQm9uZXNbaSsrXTtcblx0XHRcdFx0XHRmb3IgKHZhciBuID0gaSArIGJvbmVDb3VudDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIGJvbmVJbmRleCA9IHBhdGhCb25lc1tpXTtcblx0XHRcdFx0XHRcdHRoaXMuc29ydEJvbmUoYm9uZXNbYm9uZUluZGV4XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc29ydEJvbmUgPSBmdW5jdGlvbiAoYm9uZSkge1xuXHRcdFx0aWYgKGJvbmUuc29ydGVkKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcGFyZW50ID0gYm9uZS5wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50ICE9IG51bGwpXG5cdFx0XHRcdHRoaXMuc29ydEJvbmUocGFyZW50KTtcblx0XHRcdGJvbmUuc29ydGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goYm9uZSk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc29ydFJlc2V0ID0gZnVuY3Rpb24gKGJvbmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgYm9uZSA9IGJvbmVzW2ldO1xuXHRcdFx0XHRpZiAoYm9uZS5zb3J0ZWQpXG5cdFx0XHRcdFx0dGhpcy5zb3J0UmVzZXQoYm9uZS5jaGlsZHJlbik7XG5cdFx0XHRcdGJvbmUuc29ydGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUudXBkYXRlV29ybGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdXBkYXRlQ2FjaGVSZXNldCA9IHRoaXMudXBkYXRlQ2FjaGVSZXNldDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdXBkYXRlQ2FjaGVSZXNldC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGJvbmUgPSB1cGRhdGVDYWNoZVJlc2V0W2ldO1xuXHRcdFx0XHRib25lLmF4ID0gYm9uZS54O1xuXHRcdFx0XHRib25lLmF5ID0gYm9uZS55O1xuXHRcdFx0XHRib25lLmFyb3RhdGlvbiA9IGJvbmUucm90YXRpb247XG5cdFx0XHRcdGJvbmUuYXNjYWxlWCA9IGJvbmUuc2NhbGVYO1xuXHRcdFx0XHRib25lLmFzY2FsZVkgPSBib25lLnNjYWxlWTtcblx0XHRcdFx0Ym9uZS5hc2hlYXJYID0gYm9uZS5zaGVhclg7XG5cdFx0XHRcdGJvbmUuYXNoZWFyWSA9IGJvbmUuc2hlYXJZO1xuXHRcdFx0XHRib25lLmFwcGxpZWRWYWxpZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdXBkYXRlQ2FjaGUgPSB0aGlzLl91cGRhdGVDYWNoZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdXBkYXRlQ2FjaGUubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHR1cGRhdGVDYWNoZVtpXS51cGRhdGUoKTtcblx0XHR9O1xuXHRcdFNrZWxldG9uLnByb3RvdHlwZS5zZXRUb1NldHVwUG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2V0Qm9uZXNUb1NldHVwUG9zZSgpO1xuXHRcdFx0dGhpcy5zZXRTbG90c1RvU2V0dXBQb3NlKCk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc2V0Qm9uZXNUb1NldHVwUG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0Ym9uZXNbaV0uc2V0VG9TZXR1cFBvc2UoKTtcblx0XHRcdHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBpa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY29uc3RyYWludCA9IGlrQ29uc3RyYWludHNbaV07XG5cdFx0XHRcdGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uO1xuXHRcdFx0XHRjb25zdHJhaW50Lm1peCA9IGNvbnN0cmFpbnQuZGF0YS5taXg7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHJhbnNmb3JtQ29uc3RyYWludHMgPSB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0cmFuc2Zvcm1Db25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGNvbnN0cmFpbnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50c1tpXTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb25zdHJhaW50LmRhdGE7XG5cdFx0XHRcdGNvbnN0cmFpbnQucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XG5cdFx0XHRcdGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XG5cdFx0XHRcdGNvbnN0cmFpbnQuc2NhbGVNaXggPSBkYXRhLnNjYWxlTWl4O1xuXHRcdFx0XHRjb25zdHJhaW50LnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peDtcblx0XHRcdH1cblx0XHRcdHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY29uc3RyYWludCA9IHBhdGhDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb25zdHJhaW50LmRhdGE7XG5cdFx0XHRcdGNvbnN0cmFpbnQucG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdHJhaW50LnNwYWNpbmcgPSBkYXRhLnNwYWNpbmc7XG5cdFx0XHRcdGNvbnN0cmFpbnQucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XG5cdFx0XHRcdGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc2V0U2xvdHNUb1NldHVwUG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG5cdFx0XHRzcGluZS5VdGlscy5hcnJheUNvcHkoc2xvdHMsIDAsIHRoaXMuZHJhd09yZGVyLCAwLCBzbG90cy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdHNsb3RzW2ldLnNldFRvU2V0dXBQb3NlKCk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuZ2V0Um9vdEJvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5ib25lcy5sZW5ndGggPT0gMClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRyZXR1cm4gdGhpcy5ib25lc1swXTtcblx0XHR9O1xuXHRcdFNrZWxldG9uLnByb3RvdHlwZS5maW5kQm9uZSA9IGZ1bmN0aW9uIChib25lTmFtZSkge1xuXHRcdFx0aWYgKGJvbmVOYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJvbmVOYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgYm9uZSA9IGJvbmVzW2ldO1xuXHRcdFx0XHRpZiAoYm9uZS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uLnByb3RvdHlwZS5maW5kQm9uZUluZGV4ID0gZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG5cdFx0XHRpZiAoYm9uZU5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYm9uZU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHRpZiAoYm9uZXNbaV0uZGF0YS5uYW1lID09IGJvbmVOYW1lKVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmZpbmRTbG90ID0gZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG5cdFx0XHRpZiAoc2xvdE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2xvdE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIHNsb3RzID0gdGhpcy5zbG90cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBzbG90ID0gc2xvdHNbaV07XG5cdFx0XHRcdGlmIChzbG90LmRhdGEubmFtZSA9PSBzbG90TmFtZSlcblx0XHRcdFx0XHRyZXR1cm4gc2xvdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmZpbmRTbG90SW5kZXggPSBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcblx0XHRcdGlmIChzbG90TmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzbG90TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdGlmIChzbG90c1tpXS5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuc2V0U2tpbkJ5TmFtZSA9IGZ1bmN0aW9uIChza2luTmFtZSkge1xuXHRcdFx0dmFyIHNraW4gPSB0aGlzLmRhdGEuZmluZFNraW4oc2tpbk5hbWUpO1xuXHRcdFx0aWYgKHNraW4gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2tpbiBub3QgZm91bmQ6IFwiICsgc2tpbk5hbWUpO1xuXHRcdFx0dGhpcy5zZXRTa2luKHNraW4pO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLnNldFNraW4gPSBmdW5jdGlvbiAobmV3U2tpbikge1xuXHRcdFx0aWYgKG5ld1NraW4gIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodGhpcy5za2luICE9IG51bGwpXG5cdFx0XHRcdFx0bmV3U2tpbi5hdHRhY2hBbGwodGhpcywgdGhpcy5za2luKTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHNsb3RzID0gdGhpcy5zbG90cztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3QgPSBzbG90c1tpXTtcblx0XHRcdFx0XHRcdHZhciBuYW1lXzEgPSBzbG90LmRhdGEuYXR0YWNobWVudE5hbWU7XG5cdFx0XHRcdFx0XHRpZiAobmFtZV8xICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGF0dGFjaG1lbnQgPSBuZXdTa2luLmdldEF0dGFjaG1lbnQoaSwgbmFtZV8xKTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNraW4gPSBuZXdTa2luO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmdldEF0dGFjaG1lbnRCeU5hbWUgPSBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRhY2htZW50KHRoaXMuZGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKSwgYXR0YWNobWVudE5hbWUpO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmdldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSkge1xuXHRcdFx0aWYgKGF0dGFjaG1lbnROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImF0dGFjaG1lbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdGlmICh0aGlzLnNraW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IHRoaXMuc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xuXHRcdFx0XHRpZiAoYXR0YWNobWVudCAhPSBudWxsKVxuXHRcdFx0XHRcdHJldHVybiBhdHRhY2htZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZGF0YS5kZWZhdWx0U2tpbiAhPSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmRlZmF1bHRTa2luLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uLnByb3RvdHlwZS5zZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSkge1xuXHRcdFx0aWYgKHNsb3ROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNsb3ROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgc2xvdCA9IHNsb3RzW2ldO1xuXHRcdFx0XHRpZiAoc2xvdC5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpIHtcblx0XHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnROYW1lICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoaSwgYXR0YWNobWVudE5hbWUpO1xuXHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgYXR0YWNobWVudE5hbWUgKyBcIiwgZm9yIHNsb3Q6IFwiICsgc2xvdE5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTbG90IG5vdCBmb3VuZDogXCIgKyBzbG90TmFtZSk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuZmluZElrQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBpa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgaWtDb25zdHJhaW50ID0gaWtDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0aWYgKGlrQ29uc3RyYWludC5kYXRhLm5hbWUgPT0gY29uc3RyYWludE5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGlrQ29uc3RyYWludDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmZpbmRUcmFuc2Zvcm1Db25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnROYW1lKSB7XG5cdFx0XHRpZiAoY29uc3RyYWludE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIHRyYW5zZm9ybUNvbnN0cmFpbnRzID0gdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb25zdHJhaW50ID0gdHJhbnNmb3JtQ29uc3RyYWludHNbaV07XG5cdFx0XHRcdGlmIChjb25zdHJhaW50LmRhdGEubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcblx0XHRcdFx0XHRyZXR1cm4gY29uc3RyYWludDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b24ucHJvdG90eXBlLmZpbmRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY29uc3RyYWludCA9IHBhdGhDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0aWYgKGNvbnN0cmFpbnQuZGF0YS5uYW1lID09IGNvbnN0cmFpbnROYW1lKVxuXHRcdFx0XHRcdHJldHVybiBjb25zdHJhaW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSwgdGVtcCkge1xuXHRcdFx0aWYgKG9mZnNldCA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJvZmZzZXQgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKHNpemUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2l6ZSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR2YXIgZHJhd09yZGVyID0gdGhpcy5kcmF3T3JkZXI7XG5cdFx0XHR2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgc2xvdCA9IGRyYXdPcmRlcltpXTtcblx0XHRcdFx0dmFyIHZlcnRpY2VzTGVuZ3RoID0gMDtcblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gbnVsbDtcblx0XHRcdFx0dmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcblx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5SZWdpb25BdHRhY2htZW50KSB7XG5cdFx0XHRcdFx0dmVydGljZXNMZW5ndGggPSA4O1xuXHRcdFx0XHRcdHZlcnRpY2VzID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKHRlbXAsIHZlcnRpY2VzTGVuZ3RoLCAwKTtcblx0XHRcdFx0XHRhdHRhY2htZW50LmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QuYm9uZSwgdmVydGljZXMsIDAsIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5NZXNoQXR0YWNobWVudCkge1xuXHRcdFx0XHRcdHZhciBtZXNoID0gYXR0YWNobWVudDtcblx0XHRcdFx0XHR2ZXJ0aWNlc0xlbmd0aCA9IG1lc2gud29ybGRWZXJ0aWNlc0xlbmd0aDtcblx0XHRcdFx0XHR2ZXJ0aWNlcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0ZW1wLCB2ZXJ0aWNlc0xlbmd0aCwgMCk7XG5cdFx0XHRcdFx0bWVzaC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCB2ZXJ0aWNlc0xlbmd0aCwgdmVydGljZXMsIDAsIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2ZXJ0aWNlcyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwLCBubiA9IHZlcnRpY2VzLmxlbmd0aDsgaWkgPCBubjsgaWkgKz0gMikge1xuXHRcdFx0XHRcdFx0dmFyIHggPSB2ZXJ0aWNlc1tpaV0sIHkgPSB2ZXJ0aWNlc1tpaSArIDFdO1xuXHRcdFx0XHRcdFx0bWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuXHRcdFx0XHRcdFx0bWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuXHRcdFx0XHRcdFx0bWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuXHRcdFx0XHRcdFx0bWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0LnNldChtaW5YLCBtaW5ZKTtcblx0XHRcdHNpemUuc2V0KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG5cdFx0XHR0aGlzLnRpbWUgKz0gZGVsdGE7XG5cdFx0fTtcblx0XHRyZXR1cm4gU2tlbGV0b247XG5cdH0oKSk7XG5cdHNwaW5lLlNrZWxldG9uID0gU2tlbGV0b247XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgU2tlbGV0b25Cb3VuZHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFNrZWxldG9uQm91bmRzKCkge1xuXHRcdFx0dGhpcy5taW5YID0gMDtcblx0XHRcdHRoaXMubWluWSA9IDA7XG5cdFx0XHR0aGlzLm1heFggPSAwO1xuXHRcdFx0dGhpcy5tYXhZID0gMDtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3hlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5wb2x5Z29ucyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5wb2x5Z29uUG9vbCA9IG5ldyBzcGluZS5Qb29sKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoMTYpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2tlbGV0b24sIHVwZGF0ZUFhYmIpIHtcblx0XHRcdGlmIChza2VsZXRvbiA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbiBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR2YXIgYm91bmRpbmdCb3hlcyA9IHRoaXMuYm91bmRpbmdCb3hlcztcblx0XHRcdHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnM7XG5cdFx0XHR2YXIgcG9seWdvblBvb2wgPSB0aGlzLnBvbHlnb25Qb29sO1xuXHRcdFx0dmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XG5cdFx0XHR2YXIgc2xvdENvdW50ID0gc2xvdHMubGVuZ3RoO1xuXHRcdFx0Ym91bmRpbmdCb3hlcy5sZW5ndGggPSAwO1xuXHRcdFx0cG9seWdvblBvb2wuZnJlZUFsbChwb2x5Z29ucyk7XG5cdFx0XHRwb2x5Z29ucy5sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Q291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgc2xvdCA9IHNsb3RzW2ldO1xuXHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xuXHRcdFx0XHRpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLkJvdW5kaW5nQm94QXR0YWNobWVudCkge1xuXHRcdFx0XHRcdHZhciBib3VuZGluZ0JveCA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0Ym91bmRpbmdCb3hlcy5wdXNoKGJvdW5kaW5nQm94KTtcblx0XHRcdFx0XHR2YXIgcG9seWdvbiA9IHBvbHlnb25Qb29sLm9idGFpbigpO1xuXHRcdFx0XHRcdGlmIChwb2x5Z29uLmxlbmd0aCAhPSBib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRwb2x5Z29uID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheShib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9seWdvbnMucHVzaChwb2x5Z29uKTtcblx0XHRcdFx0XHRib3VuZGluZ0JveC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCBib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoLCBwb2x5Z29uLCAwLCAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVwZGF0ZUFhYmIpIHtcblx0XHRcdFx0dGhpcy5hYWJiQ29tcHV0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHRcdFx0dGhpcy5taW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdFx0XHR0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cdFx0XHRcdHRoaXMubWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5hYWJiQ29tcHV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXHRcdFx0dmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2x5Z29uID0gcG9seWdvbnNbaV07XG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IHBvbHlnb247XG5cdFx0XHRcdGZvciAodmFyIGlpID0gMCwgbm4gPSBwb2x5Z29uLmxlbmd0aDsgaWkgPCBubjsgaWkgKz0gMikge1xuXHRcdFx0XHRcdHZhciB4ID0gdmVydGljZXNbaWldO1xuXHRcdFx0XHRcdHZhciB5ID0gdmVydGljZXNbaWkgKyAxXTtcblx0XHRcdFx0XHRtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG5cdFx0XHRcdFx0bWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuXHRcdFx0XHRcdG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcblx0XHRcdFx0XHRtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMubWluWCA9IG1pblg7XG5cdFx0XHR0aGlzLm1pblkgPSBtaW5ZO1xuXHRcdFx0dGhpcy5tYXhYID0gbWF4WDtcblx0XHRcdHRoaXMubWF4WSA9IG1heFk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuYWFiYkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdFx0cmV0dXJuIHggPj0gdGhpcy5taW5YICYmIHggPD0gdGhpcy5tYXhYICYmIHkgPj0gdGhpcy5taW5ZICYmIHkgPD0gdGhpcy5tYXhZO1xuXHRcdH07XG5cdFx0U2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmFhYmJJbnRlcnNlY3RzU2VnbWVudCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0dmFyIG1pblggPSB0aGlzLm1pblg7XG5cdFx0XHR2YXIgbWluWSA9IHRoaXMubWluWTtcblx0XHRcdHZhciBtYXhYID0gdGhpcy5tYXhYO1xuXHRcdFx0dmFyIG1heFkgPSB0aGlzLm1heFk7XG5cdFx0XHRpZiAoKHgxIDw9IG1pblggJiYgeDIgPD0gbWluWCkgfHwgKHkxIDw9IG1pblkgJiYgeTIgPD0gbWluWSkgfHwgKHgxID49IG1heFggJiYgeDIgPj0gbWF4WCkgfHwgKHkxID49IG1heFkgJiYgeTIgPj0gbWF4WSkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHZhciBtID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xuXHRcdFx0dmFyIHkgPSBtICogKG1pblggLSB4MSkgKyB5MTtcblx0XHRcdGlmICh5ID4gbWluWSAmJiB5IDwgbWF4WSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR5ID0gbSAqIChtYXhYIC0geDEpICsgeTE7XG5cdFx0XHRpZiAoeSA+IG1pblkgJiYgeSA8IG1heFkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0dmFyIHggPSAobWluWSAtIHkxKSAvIG0gKyB4MTtcblx0XHRcdGlmICh4ID4gbWluWCAmJiB4IDwgbWF4WClcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR4ID0gKG1heFkgLSB5MSkgLyBtICsgeDE7XG5cdFx0XHRpZiAoeCA+IG1pblggJiYgeCA8IG1heFgpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0U2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmFhYmJJbnRlcnNlY3RzU2tlbGV0b24gPSBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5taW5YIDwgYm91bmRzLm1heFggJiYgdGhpcy5tYXhYID4gYm91bmRzLm1pblggJiYgdGhpcy5taW5ZIDwgYm91bmRzLm1heFkgJiYgdGhpcy5tYXhZID4gYm91bmRzLm1pblk7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0XHR2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdGlmICh0aGlzLmNvbnRhaW5zUG9pbnRQb2x5Z29uKHBvbHlnb25zW2ldLCB4LCB5KSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5ib3VuZGluZ0JveGVzW2ldO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuY29udGFpbnNQb2ludFBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbiwgeCwgeSkge1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gcG9seWdvbjtcblx0XHRcdHZhciBubiA9IHBvbHlnb24ubGVuZ3RoO1xuXHRcdFx0dmFyIHByZXZJbmRleCA9IG5uIC0gMjtcblx0XHRcdHZhciBpbnNpZGUgPSBmYWxzZTtcblx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBubjsgaWkgKz0gMikge1xuXHRcdFx0XHR2YXIgdmVydGV4WSA9IHZlcnRpY2VzW2lpICsgMV07XG5cdFx0XHRcdHZhciBwcmV2WSA9IHZlcnRpY2VzW3ByZXZJbmRleCArIDFdO1xuXHRcdFx0XHRpZiAoKHZlcnRleFkgPCB5ICYmIHByZXZZID49IHkpIHx8IChwcmV2WSA8IHkgJiYgdmVydGV4WSA+PSB5KSkge1xuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhYID0gdmVydGljZXNbaWldO1xuXHRcdFx0XHRcdGlmICh2ZXJ0ZXhYICsgKHkgLSB2ZXJ0ZXhZKSAvIChwcmV2WSAtIHZlcnRleFkpICogKHZlcnRpY2VzW3ByZXZJbmRleF0gLSB2ZXJ0ZXhYKSA8IHgpXG5cdFx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZXZJbmRleCA9IGlpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluc2lkZTtcblx0XHR9O1xuXHRcdFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5pbnRlcnNlY3RzU2VnbWVudCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0dmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0XHRpZiAodGhpcy5pbnRlcnNlY3RzU2VnbWVudFBvbHlnb24ocG9seWdvbnNbaV0sIHgxLCB5MSwgeDIsIHkyKSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5ib3VuZGluZ0JveGVzW2ldO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuaW50ZXJzZWN0c1NlZ21lbnRQb2x5Z29uID0gZnVuY3Rpb24gKHBvbHlnb24sIHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHR2YXIgdmVydGljZXMgPSBwb2x5Z29uO1xuXHRcdFx0dmFyIG5uID0gcG9seWdvbi5sZW5ndGg7XG5cdFx0XHR2YXIgd2lkdGgxMiA9IHgxIC0geDIsIGhlaWdodDEyID0geTEgLSB5Mjtcblx0XHRcdHZhciBkZXQxID0geDEgKiB5MiAtIHkxICogeDI7XG5cdFx0XHR2YXIgeDMgPSB2ZXJ0aWNlc1tubiAtIDJdLCB5MyA9IHZlcnRpY2VzW25uIC0gMV07XG5cdFx0XHRmb3IgKHZhciBpaSA9IDA7IGlpIDwgbm47IGlpICs9IDIpIHtcblx0XHRcdFx0dmFyIHg0ID0gdmVydGljZXNbaWldLCB5NCA9IHZlcnRpY2VzW2lpICsgMV07XG5cdFx0XHRcdHZhciBkZXQyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cdFx0XHRcdHZhciB3aWR0aDM0ID0geDMgLSB4NCwgaGVpZ2h0MzQgPSB5MyAtIHk0O1xuXHRcdFx0XHR2YXIgZGV0MyA9IHdpZHRoMTIgKiBoZWlnaHQzNCAtIGhlaWdodDEyICogd2lkdGgzNDtcblx0XHRcdFx0dmFyIHggPSAoZGV0MSAqIHdpZHRoMzQgLSB3aWR0aDEyICogZGV0MikgLyBkZXQzO1xuXHRcdFx0XHRpZiAoKCh4ID49IHgzICYmIHggPD0geDQpIHx8ICh4ID49IHg0ICYmIHggPD0geDMpKSAmJiAoKHggPj0geDEgJiYgeCA8PSB4MikgfHwgKHggPj0geDIgJiYgeCA8PSB4MSkpKSB7XG5cdFx0XHRcdFx0dmFyIHkgPSAoZGV0MSAqIGhlaWdodDM0IC0gaGVpZ2h0MTIgKiBkZXQyKSAvIGRldDM7XG5cdFx0XHRcdFx0aWYgKCgoeSA+PSB5MyAmJiB5IDw9IHk0KSB8fCAoeSA+PSB5NCAmJiB5IDw9IHkzKSkgJiYgKCh5ID49IHkxICYmIHkgPD0geTIpIHx8ICh5ID49IHkyICYmIHkgPD0geTEpKSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHgzID0geDQ7XG5cdFx0XHRcdHkzID0geTQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuZ2V0UG9seWdvbiA9IGZ1bmN0aW9uIChib3VuZGluZ0JveCkge1xuXHRcdFx0aWYgKGJvdW5kaW5nQm94ID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJvdW5kaW5nQm94IGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBpbmRleCA9IHRoaXMuYm91bmRpbmdCb3hlcy5pbmRleE9mKGJvdW5kaW5nQm94KTtcblx0XHRcdHJldHVybiBpbmRleCA9PSAtMSA/IG51bGwgOiB0aGlzLnBvbHlnb25zW2luZGV4XTtcblx0XHR9O1xuXHRcdFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblg7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWTtcblx0XHR9O1xuXHRcdHJldHVybiBTa2VsZXRvbkJvdW5kcztcblx0fSgpKTtcblx0c3BpbmUuU2tlbGV0b25Cb3VuZHMgPSBTa2VsZXRvbkJvdW5kcztcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBTa2VsZXRvbkNsaXBwaW5nID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBTa2VsZXRvbkNsaXBwaW5nKCkge1xuXHRcdFx0dGhpcy50cmlhbmd1bGF0b3IgPSBuZXcgc3BpbmUuVHJpYW5ndWxhdG9yKCk7XG5cdFx0XHR0aGlzLmNsaXBwaW5nUG9seWdvbiA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5jbGlwT3V0cHV0ID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmNsaXBwZWRWZXJ0aWNlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5jbGlwcGVkVHJpYW5nbGVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnNjcmF0Y2ggPSBuZXcgQXJyYXkoKTtcblx0XHR9XG5cdFx0U2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcFN0YXJ0ID0gZnVuY3Rpb24gKHNsb3QsIGNsaXApIHtcblx0XHRcdGlmICh0aGlzLmNsaXBBdHRhY2htZW50ICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0dGhpcy5jbGlwQXR0YWNobWVudCA9IGNsaXA7XG5cdFx0XHR2YXIgbiA9IGNsaXAud29ybGRWZXJ0aWNlc0xlbmd0aDtcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLmNsaXBwaW5nUG9seWdvbiwgbik7XG5cdFx0XHRjbGlwLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIG4sIHZlcnRpY2VzLCAwLCAyKTtcblx0XHRcdHZhciBjbGlwcGluZ1BvbHlnb24gPSB0aGlzLmNsaXBwaW5nUG9seWdvbjtcblx0XHRcdFNrZWxldG9uQ2xpcHBpbmcubWFrZUNsb2Nrd2lzZShjbGlwcGluZ1BvbHlnb24pO1xuXHRcdFx0dmFyIGNsaXBwaW5nUG9seWdvbnMgPSB0aGlzLmNsaXBwaW5nUG9seWdvbnMgPSB0aGlzLnRyaWFuZ3VsYXRvci5kZWNvbXBvc2UoY2xpcHBpbmdQb2x5Z29uLCB0aGlzLnRyaWFuZ3VsYXRvci50cmlhbmd1bGF0ZShjbGlwcGluZ1BvbHlnb24pKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuXzEgPSBjbGlwcGluZ1BvbHlnb25zLmxlbmd0aDsgaSA8IG5fMTsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2x5Z29uID0gY2xpcHBpbmdQb2x5Z29uc1tpXTtcblx0XHRcdFx0U2tlbGV0b25DbGlwcGluZy5tYWtlQ2xvY2t3aXNlKHBvbHlnb24pO1xuXHRcdFx0XHRwb2x5Z29uLnB1c2gocG9seWdvblswXSk7XG5cdFx0XHRcdHBvbHlnb24ucHVzaChwb2x5Z29uWzFdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjbGlwcGluZ1BvbHlnb25zLmxlbmd0aDtcblx0XHR9O1xuXHRcdFNrZWxldG9uQ2xpcHBpbmcucHJvdG90eXBlLmNsaXBFbmRXaXRoU2xvdCA9IGZ1bmN0aW9uIChzbG90KSB7XG5cdFx0XHRpZiAodGhpcy5jbGlwQXR0YWNobWVudCAhPSBudWxsICYmIHRoaXMuY2xpcEF0dGFjaG1lbnQuZW5kU2xvdCA9PSBzbG90LmRhdGEpXG5cdFx0XHRcdHRoaXMuY2xpcEVuZCgpO1xuXHRcdH07XG5cdFx0U2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcEVuZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLmNsaXBBdHRhY2htZW50ID09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoaXMuY2xpcEF0dGFjaG1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5jbGlwcGluZ1BvbHlnb25zID0gbnVsbDtcblx0XHRcdHRoaXMuY2xpcHBlZFZlcnRpY2VzLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLmNsaXBwZWRUcmlhbmdsZXMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMuY2xpcHBpbmdQb2x5Z29uLmxlbmd0aCA9IDA7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5pc0NsaXBwaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xpcEF0dGFjaG1lbnQgIT0gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uQ2xpcHBpbmcucHJvdG90eXBlLmNsaXBUcmlhbmdsZXMgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRpY2VzTGVuZ3RoLCB0cmlhbmdsZXMsIHRyaWFuZ2xlc0xlbmd0aCwgdXZzLCBsaWdodCwgZGFyaywgdHdvQ29sb3IpIHtcblx0XHRcdHZhciBjbGlwT3V0cHV0ID0gdGhpcy5jbGlwT3V0cHV0LCBjbGlwcGVkVmVydGljZXMgPSB0aGlzLmNsaXBwZWRWZXJ0aWNlcztcblx0XHRcdHZhciBjbGlwcGVkVHJpYW5nbGVzID0gdGhpcy5jbGlwcGVkVHJpYW5nbGVzO1xuXHRcdFx0dmFyIHBvbHlnb25zID0gdGhpcy5jbGlwcGluZ1BvbHlnb25zO1xuXHRcdFx0dmFyIHBvbHlnb25zQ291bnQgPSB0aGlzLmNsaXBwaW5nUG9seWdvbnMubGVuZ3RoO1xuXHRcdFx0dmFyIHZlcnRleFNpemUgPSB0d29Db2xvciA/IDEyIDogODtcblx0XHRcdHZhciBpbmRleCA9IDA7XG5cdFx0XHRjbGlwcGVkVmVydGljZXMubGVuZ3RoID0gMDtcblx0XHRcdGNsaXBwZWRUcmlhbmdsZXMubGVuZ3RoID0gMDtcblx0XHRcdG91dGVyOiBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlc0xlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhPZmZzZXQgPSB0cmlhbmdsZXNbaV0gPDwgMTtcblx0XHRcdFx0dmFyIHgxID0gdmVydGljZXNbdmVydGV4T2Zmc2V0XSwgeTEgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcblx0XHRcdFx0dmFyIHUxID0gdXZzW3ZlcnRleE9mZnNldF0sIHYxID0gdXZzW3ZlcnRleE9mZnNldCArIDFdO1xuXHRcdFx0XHR2ZXJ0ZXhPZmZzZXQgPSB0cmlhbmdsZXNbaSArIDFdIDw8IDE7XG5cdFx0XHRcdHZhciB4MiA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldF0sIHkyID0gdmVydGljZXNbdmVydGV4T2Zmc2V0ICsgMV07XG5cdFx0XHRcdHZhciB1MiA9IHV2c1t2ZXJ0ZXhPZmZzZXRdLCB2MiA9IHV2c1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcblx0XHRcdFx0dmVydGV4T2Zmc2V0ID0gdHJpYW5nbGVzW2kgKyAyXSA8PCAxO1xuXHRcdFx0XHR2YXIgeDMgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXRdLCB5MyA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldCArIDFdO1xuXHRcdFx0XHR2YXIgdTMgPSB1dnNbdmVydGV4T2Zmc2V0XSwgdjMgPSB1dnNbdmVydGV4T2Zmc2V0ICsgMV07XG5cdFx0XHRcdGZvciAodmFyIHAgPSAwOyBwIDwgcG9seWdvbnNDb3VudDsgcCsrKSB7XG5cdFx0XHRcdFx0dmFyIHMgPSBjbGlwcGVkVmVydGljZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmICh0aGlzLmNsaXAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgcG9seWdvbnNbcF0sIGNsaXBPdXRwdXQpKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2xpcE91dHB1dExlbmd0aCA9IGNsaXBPdXRwdXQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYgKGNsaXBPdXRwdXRMZW5ndGggPT0gMClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR2YXIgZDAgPSB5MiAtIHkzLCBkMSA9IHgzIC0geDIsIGQyID0geDEgLSB4MywgZDQgPSB5MyAtIHkxO1xuXHRcdFx0XHRcdFx0dmFyIGQgPSAxIC8gKGQwICogZDIgKyBkMSAqICh5MSAtIHkzKSk7XG5cdFx0XHRcdFx0XHR2YXIgY2xpcE91dHB1dENvdW50ID0gY2xpcE91dHB1dExlbmd0aCA+PiAxO1xuXHRcdFx0XHRcdFx0dmFyIGNsaXBPdXRwdXRJdGVtcyA9IHRoaXMuY2xpcE91dHB1dDtcblx0XHRcdFx0XHRcdHZhciBjbGlwcGVkVmVydGljZXNJdGVtcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZShjbGlwcGVkVmVydGljZXMsIHMgKyBjbGlwT3V0cHV0Q291bnQgKiB2ZXJ0ZXhTaXplKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBjbGlwT3V0cHV0TGVuZ3RoOyBpaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB4ID0gY2xpcE91dHB1dEl0ZW1zW2lpXSwgeSA9IGNsaXBPdXRwdXRJdGVtc1tpaSArIDFdO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzXSA9IHg7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxXSA9IHk7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyXSA9IGxpZ2h0LnI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzXSA9IGxpZ2h0Lmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA0XSA9IGxpZ2h0LmI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA1XSA9IGxpZ2h0LmE7XG5cdFx0XHRcdFx0XHRcdHZhciBjMCA9IHggLSB4MywgYzEgPSB5IC0geTM7XG5cdFx0XHRcdFx0XHRcdHZhciBhID0gKGQwICogYzAgKyBkMSAqIGMxKSAqIGQ7XG5cdFx0XHRcdFx0XHRcdHZhciBiID0gKGQ0ICogYzAgKyBkMiAqIGMxKSAqIGQ7XG5cdFx0XHRcdFx0XHRcdHZhciBjID0gMSAtIGEgLSBiO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNl0gPSB1MSAqIGEgKyB1MiAqIGIgKyB1MyAqIGM7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA3XSA9IHYxICogYSArIHYyICogYiArIHYzICogYztcblx0XHRcdFx0XHRcdFx0aWYgKHR3b0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDhdID0gZGFyay5yO1xuXHRcdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA4XSA9IGRhcmsuZztcblx0XHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTBdID0gZGFyay5iO1xuXHRcdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBkYXJrLmE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cyArPSB2ZXJ0ZXhTaXplO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cyA9IGNsaXBwZWRUcmlhbmdsZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dmFyIGNsaXBwZWRUcmlhbmdsZXNJdGVtcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZShjbGlwcGVkVHJpYW5nbGVzLCBzICsgMyAqIChjbGlwT3V0cHV0Q291bnQgLSAyKSk7XG5cdFx0XHRcdFx0XHRjbGlwT3V0cHV0Q291bnQtLTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMTsgaWkgPCBjbGlwT3V0cHV0Q291bnQ7IGlpKyspIHtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3NdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRUcmlhbmdsZXNJdGVtc1tzICsgMV0gPSAoaW5kZXggKyBpaSk7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRUcmlhbmdsZXNJdGVtc1tzICsgMl0gPSAoaW5kZXggKyBpaSArIDEpO1xuXHRcdFx0XHRcdFx0XHRzICs9IDM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbmRleCArPSBjbGlwT3V0cHV0Q291bnQgKyAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBjbGlwcGVkVmVydGljZXNJdGVtcyA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZShjbGlwcGVkVmVydGljZXMsIHMgKyAzICogdmVydGV4U2l6ZSk7XG5cdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzXSA9IHgxO1xuXHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDFdID0geTE7XG5cdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMl0gPSBsaWdodC5yO1xuXHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDNdID0gbGlnaHQuZztcblx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA0XSA9IGxpZ2h0LmI7XG5cdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNV0gPSBsaWdodC5hO1xuXHRcdFx0XHRcdFx0aWYgKCF0d29Db2xvcikge1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNl0gPSB1MTtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDddID0gdjE7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA4XSA9IHgyO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOV0gPSB5Mjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDEwXSA9IGxpZ2h0LnI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBsaWdodC5nO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTJdID0gbGlnaHQuYjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDEzXSA9IGxpZ2h0LmE7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxNF0gPSB1Mjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE1XSA9IHYyO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTZdID0geDM7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxN10gPSB5Mztcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE4XSA9IGxpZ2h0LnI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxOV0gPSBsaWdodC5nO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjBdID0gbGlnaHQuYjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIxXSA9IGxpZ2h0LmE7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMl0gPSB1Mztcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIzXSA9IHYzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA2XSA9IHUxO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgN10gPSB2MTtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDhdID0gZGFyay5yO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOV0gPSBkYXJrLmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMF0gPSBkYXJrLmI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBkYXJrLmE7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMl0gPSB4Mjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDEzXSA9IHkyO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTRdID0gbGlnaHQucjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE1XSA9IGxpZ2h0Lmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxNl0gPSBsaWdodC5iO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTddID0gbGlnaHQuYTtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE4XSA9IHUyO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTldID0gdjI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMF0gPSBkYXJrLnI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMV0gPSBkYXJrLmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMl0gPSBkYXJrLmI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyM10gPSBkYXJrLmE7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyNF0gPSB4Mztcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI1XSA9IHkzO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjZdID0gbGlnaHQucjtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI3XSA9IGxpZ2h0Lmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyOF0gPSBsaWdodC5iO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjldID0gbGlnaHQuYTtcblx0XHRcdFx0XHRcdFx0Y2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDMwXSA9IHUzO1xuXHRcdFx0XHRcdFx0XHRjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMzFdID0gdjM7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzMl0gPSBkYXJrLnI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzM10gPSBkYXJrLmc7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzNF0gPSBkYXJrLmI7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzNV0gPSBkYXJrLmE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzID0gY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR2YXIgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zID0gc3BpbmUuVXRpbHMuc2V0QXJyYXlTaXplKGNsaXBwZWRUcmlhbmdsZXMsIHMgKyAzKTtcblx0XHRcdFx0XHRcdGNsaXBwZWRUcmlhbmdsZXNJdGVtc1tzXSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0Y2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3MgKyAxXSA9IChpbmRleCArIDEpO1xuXHRcdFx0XHRcdFx0Y2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3MgKyAyXSA9IChpbmRleCArIDIpO1xuXHRcdFx0XHRcdFx0aW5kZXggKz0gMztcblx0XHRcdFx0XHRcdGNvbnRpbnVlIG91dGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0U2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBjbGlwcGluZ0FyZWEsIG91dHB1dCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsT3V0cHV0ID0gb3V0cHV0O1xuXHRcdFx0dmFyIGNsaXBwZWQgPSBmYWxzZTtcblx0XHRcdHZhciBpbnB1dCA9IG51bGw7XG5cdFx0XHRpZiAoY2xpcHBpbmdBcmVhLmxlbmd0aCAlIDQgPj0gMikge1xuXHRcdFx0XHRpbnB1dCA9IG91dHB1dDtcblx0XHRcdFx0b3V0cHV0ID0gdGhpcy5zY3JhdGNoO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpbnB1dCA9IHRoaXMuc2NyYXRjaDtcblx0XHRcdGlucHV0Lmxlbmd0aCA9IDA7XG5cdFx0XHRpbnB1dC5wdXNoKHgxKTtcblx0XHRcdGlucHV0LnB1c2goeTEpO1xuXHRcdFx0aW5wdXQucHVzaCh4Mik7XG5cdFx0XHRpbnB1dC5wdXNoKHkyKTtcblx0XHRcdGlucHV0LnB1c2goeDMpO1xuXHRcdFx0aW5wdXQucHVzaCh5Myk7XG5cdFx0XHRpbnB1dC5wdXNoKHgxKTtcblx0XHRcdGlucHV0LnB1c2goeTEpO1xuXHRcdFx0b3V0cHV0Lmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgY2xpcHBpbmdWZXJ0aWNlcyA9IGNsaXBwaW5nQXJlYTtcblx0XHRcdHZhciBjbGlwcGluZ1ZlcnRpY2VzTGFzdCA9IGNsaXBwaW5nQXJlYS5sZW5ndGggLSA0O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7OyBpICs9IDIpIHtcblx0XHRcdFx0dmFyIGVkZ2VYID0gY2xpcHBpbmdWZXJ0aWNlc1tpXSwgZWRnZVkgPSBjbGlwcGluZ1ZlcnRpY2VzW2kgKyAxXTtcblx0XHRcdFx0dmFyIGVkZ2VYMiA9IGNsaXBwaW5nVmVydGljZXNbaSArIDJdLCBlZGdlWTIgPSBjbGlwcGluZ1ZlcnRpY2VzW2kgKyAzXTtcblx0XHRcdFx0dmFyIGRlbHRhWCA9IGVkZ2VYIC0gZWRnZVgyLCBkZWx0YVkgPSBlZGdlWSAtIGVkZ2VZMjtcblx0XHRcdFx0dmFyIGlucHV0VmVydGljZXMgPSBpbnB1dDtcblx0XHRcdFx0dmFyIGlucHV0VmVydGljZXNMZW5ndGggPSBpbnB1dC5sZW5ndGggLSAyLCBvdXRwdXRTdGFydCA9IG91dHB1dC5sZW5ndGg7XG5cdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBpbnB1dFZlcnRpY2VzTGVuZ3RoOyBpaSArPSAyKSB7XG5cdFx0XHRcdFx0dmFyIGlucHV0WCA9IGlucHV0VmVydGljZXNbaWldLCBpbnB1dFkgPSBpbnB1dFZlcnRpY2VzW2lpICsgMV07XG5cdFx0XHRcdFx0dmFyIGlucHV0WDIgPSBpbnB1dFZlcnRpY2VzW2lpICsgMl0sIGlucHV0WTIgPSBpbnB1dFZlcnRpY2VzW2lpICsgM107XG5cdFx0XHRcdFx0dmFyIHNpZGUyID0gZGVsdGFYICogKGlucHV0WTIgLSBlZGdlWTIpIC0gZGVsdGFZICogKGlucHV0WDIgLSBlZGdlWDIpID4gMDtcblx0XHRcdFx0XHRpZiAoZGVsdGFYICogKGlucHV0WSAtIGVkZ2VZMikgLSBkZWx0YVkgKiAoaW5wdXRYIC0gZWRnZVgyKSA+IDApIHtcblx0XHRcdFx0XHRcdGlmIChzaWRlMikge1xuXHRcdFx0XHRcdFx0XHRvdXRwdXQucHVzaChpbnB1dFgyKTtcblx0XHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goaW5wdXRZMik7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIGMwID0gaW5wdXRZMiAtIGlucHV0WSwgYzIgPSBpbnB1dFgyIC0gaW5wdXRYO1xuXHRcdFx0XHRcdFx0dmFyIHVhID0gKGMyICogKGVkZ2VZIC0gaW5wdXRZKSAtIGMwICogKGVkZ2VYIC0gaW5wdXRYKSkgLyAoYzAgKiAoZWRnZVgyIC0gZWRnZVgpIC0gYzIgKiAoZWRnZVkyIC0gZWRnZVkpKTtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKGVkZ2VYICsgKGVkZ2VYMiAtIGVkZ2VYKSAqIHVhKTtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKGVkZ2VZICsgKGVkZ2VZMiAtIGVkZ2VZKSAqIHVhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc2lkZTIpIHtcblx0XHRcdFx0XHRcdHZhciBjMCA9IGlucHV0WTIgLSBpbnB1dFksIGMyID0gaW5wdXRYMiAtIGlucHV0WDtcblx0XHRcdFx0XHRcdHZhciB1YSA9IChjMiAqIChlZGdlWSAtIGlucHV0WSkgLSBjMCAqIChlZGdlWCAtIGlucHV0WCkpIC8gKGMwICogKGVkZ2VYMiAtIGVkZ2VYKSAtIGMyICogKGVkZ2VZMiAtIGVkZ2VZKSk7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChlZGdlWCArIChlZGdlWDIgLSBlZGdlWCkgKiB1YSk7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChlZGdlWSArIChlZGdlWTIgLSBlZGdlWSkgKiB1YSk7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChpbnB1dFgyKTtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKGlucHV0WTIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGlwcGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0cHV0U3RhcnQgPT0gb3V0cHV0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdG9yaWdpbmFsT3V0cHV0Lmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0cHV0LnB1c2gob3V0cHV0WzBdKTtcblx0XHRcdFx0b3V0cHV0LnB1c2gob3V0cHV0WzFdKTtcblx0XHRcdFx0aWYgKGkgPT0gY2xpcHBpbmdWZXJ0aWNlc0xhc3QpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdHZhciB0ZW1wID0gb3V0cHV0O1xuXHRcdFx0XHRvdXRwdXQgPSBpbnB1dDtcblx0XHRcdFx0b3V0cHV0Lmxlbmd0aCA9IDA7XG5cdFx0XHRcdGlucHV0ID0gdGVtcDtcblx0XHRcdH1cblx0XHRcdGlmIChvcmlnaW5hbE91dHB1dCAhPSBvdXRwdXQpIHtcblx0XHRcdFx0b3JpZ2luYWxPdXRwdXQubGVuZ3RoID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBvdXRwdXQubGVuZ3RoIC0gMjsgaSA8IG47IGkrKylcblx0XHRcdFx0XHRvcmlnaW5hbE91dHB1dFtpXSA9IG91dHB1dFtpXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0b3JpZ2luYWxPdXRwdXQubGVuZ3RoID0gb3JpZ2luYWxPdXRwdXQubGVuZ3RoIC0gMjtcblx0XHRcdHJldHVybiBjbGlwcGVkO1xuXHRcdH07XG5cdFx0U2tlbGV0b25DbGlwcGluZy5tYWtlQ2xvY2t3aXNlID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHBvbHlnb247XG5cdFx0XHR2YXIgdmVydGljZXNsZW5ndGggPSBwb2x5Z29uLmxlbmd0aDtcblx0XHRcdHZhciBhcmVhID0gdmVydGljZXNbdmVydGljZXNsZW5ndGggLSAyXSAqIHZlcnRpY2VzWzFdIC0gdmVydGljZXNbMF0gKiB2ZXJ0aWNlc1t2ZXJ0aWNlc2xlbmd0aCAtIDFdLCBwMXggPSAwLCBwMXkgPSAwLCBwMnggPSAwLCBwMnkgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlc2xlbmd0aCAtIDM7IGkgPCBuOyBpICs9IDIpIHtcblx0XHRcdFx0cDF4ID0gdmVydGljZXNbaV07XG5cdFx0XHRcdHAxeSA9IHZlcnRpY2VzW2kgKyAxXTtcblx0XHRcdFx0cDJ4ID0gdmVydGljZXNbaSArIDJdO1xuXHRcdFx0XHRwMnkgPSB2ZXJ0aWNlc1tpICsgM107XG5cdFx0XHRcdGFyZWEgKz0gcDF4ICogcDJ5IC0gcDJ4ICogcDF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZWEgPCAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGFzdFggPSB2ZXJ0aWNlc2xlbmd0aCAtIDIsIG4gPSB2ZXJ0aWNlc2xlbmd0aCA+PiAxOyBpIDwgbjsgaSArPSAyKSB7XG5cdFx0XHRcdHZhciB4ID0gdmVydGljZXNbaV0sIHkgPSB2ZXJ0aWNlc1tpICsgMV07XG5cdFx0XHRcdHZhciBvdGhlciA9IGxhc3RYIC0gaTtcblx0XHRcdFx0dmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tvdGhlcl07XG5cdFx0XHRcdHZlcnRpY2VzW2kgKyAxXSA9IHZlcnRpY2VzW290aGVyICsgMV07XG5cdFx0XHRcdHZlcnRpY2VzW290aGVyXSA9IHg7XG5cdFx0XHRcdHZlcnRpY2VzW290aGVyICsgMV0gPSB5O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFNrZWxldG9uQ2xpcHBpbmc7XG5cdH0oKSk7XG5cdHNwaW5lLlNrZWxldG9uQ2xpcHBpbmcgPSBTa2VsZXRvbkNsaXBwaW5nO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFNrZWxldG9uRGF0YSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gU2tlbGV0b25EYXRhKCkge1xuXHRcdFx0dGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5zbG90cyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5za2lucyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5ldmVudHMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5pa0NvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnBhdGhDb25zdHJhaW50cyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5mcHMgPSAwO1xuXHRcdH1cblx0XHRTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRCb25lID0gZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG5cdFx0XHRpZiAoYm9uZU5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYm9uZU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdGlmIChib25lLm5hbWUgPT0gYm9uZU5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEJvbmVJbmRleCA9IGZ1bmN0aW9uIChib25lTmFtZSkge1xuXHRcdFx0aWYgKGJvbmVOYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJvbmVOYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0aWYgKGJvbmVzW2ldLm5hbWUgPT0gYm9uZU5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRTbG90ID0gZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG5cdFx0XHRpZiAoc2xvdE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2xvdE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIHNsb3RzID0gdGhpcy5zbG90cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBzbG90ID0gc2xvdHNbaV07XG5cdFx0XHRcdGlmIChzbG90Lm5hbWUgPT0gc2xvdE5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIHNsb3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZFNsb3RJbmRleCA9IGZ1bmN0aW9uIChzbG90TmFtZSkge1xuXHRcdFx0aWYgKHNsb3ROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNsb3ROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0aWYgKHNsb3RzW2ldLm5hbWUgPT0gc2xvdE5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRTa2luID0gZnVuY3Rpb24gKHNraW5OYW1lKSB7XG5cdFx0XHRpZiAoc2tpbk5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2tpbk5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIHNraW5zID0gdGhpcy5za2lucztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gc2tpbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBza2luID0gc2tpbnNbaV07XG5cdFx0XHRcdGlmIChza2luLm5hbWUgPT0gc2tpbk5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIHNraW47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50RGF0YU5hbWUpIHtcblx0XHRcdGlmIChldmVudERhdGFOYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImV2ZW50RGF0YU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBldmVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBldmVudF80ID0gZXZlbnRzW2ldO1xuXHRcdFx0XHRpZiAoZXZlbnRfNC5uYW1lID09IGV2ZW50RGF0YU5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGV2ZW50XzQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uTmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhbmltYXRpb25OYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1tpXTtcblx0XHRcdFx0aWYgKGFuaW1hdGlvbi5uYW1lID09IGFuaW1hdGlvbk5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kSWtDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnROYW1lKSB7XG5cdFx0XHRpZiAoY29uc3RyYWludE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGlrQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb25zdHJhaW50ID0gaWtDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0aWYgKGNvbnN0cmFpbnQubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcblx0XHRcdFx0XHRyZXR1cm4gY29uc3RyYWludDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kVHJhbnNmb3JtQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciB0cmFuc2Zvcm1Db25zdHJhaW50cyA9IHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY29uc3RyYWludCA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzW2ldO1xuXHRcdFx0XHRpZiAoY29uc3RyYWludC5uYW1lID09IGNvbnN0cmFpbnROYW1lKVxuXHRcdFx0XHRcdHJldHVybiBjb25zdHJhaW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgY29uc3RyYWludCA9IHBhdGhDb25zdHJhaW50c1tpXTtcblx0XHRcdFx0aWYgKGNvbnN0cmFpbnQubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcblx0XHRcdFx0XHRyZXR1cm4gY29uc3RyYWludDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0U2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kUGF0aENvbnN0cmFpbnRJbmRleCA9IGZ1bmN0aW9uIChwYXRoQ29uc3RyYWludE5hbWUpIHtcblx0XHRcdGlmIChwYXRoQ29uc3RyYWludE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGF0aENvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0aWYgKHBhdGhDb25zdHJhaW50c1tpXS5uYW1lID09IHBhdGhDb25zdHJhaW50TmFtZSlcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRcdHJldHVybiBTa2VsZXRvbkRhdGE7XG5cdH0oKSk7XG5cdHNwaW5lLlNrZWxldG9uRGF0YSA9IFNrZWxldG9uRGF0YTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBTa2VsZXRvbkpzb24gPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFNrZWxldG9uSnNvbihhdHRhY2htZW50TG9hZGVyKSB7XG5cdFx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHRcdHRoaXMubGlua2VkTWVzaGVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmF0dGFjaG1lbnRMb2FkZXIgPSBhdHRhY2htZW50TG9hZGVyO1xuXHRcdH1cblx0XHRTa2VsZXRvbkpzb24ucHJvdG90eXBlLnJlYWRTa2VsZXRvbkRhdGEgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdHZhciBza2VsZXRvbkRhdGEgPSBuZXcgc3BpbmUuU2tlbGV0b25EYXRhKCk7XG5cdFx0XHR2YXIgcm9vdCA9IHR5cGVvZiAoanNvbikgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcblx0XHRcdHZhciBza2VsZXRvbk1hcCA9IHJvb3Quc2tlbGV0b247XG5cdFx0XHRpZiAoc2tlbGV0b25NYXAgIT0gbnVsbCkge1xuXHRcdFx0XHRza2VsZXRvbkRhdGEuaGFzaCA9IHNrZWxldG9uTWFwLmhhc2g7XG5cdFx0XHRcdHNrZWxldG9uRGF0YS52ZXJzaW9uID0gc2tlbGV0b25NYXAuc3BpbmU7XG5cdFx0XHRcdHNrZWxldG9uRGF0YS53aWR0aCA9IHNrZWxldG9uTWFwLndpZHRoO1xuXHRcdFx0XHRza2VsZXRvbkRhdGEuaGVpZ2h0ID0gc2tlbGV0b25NYXAuaGVpZ2h0O1xuXHRcdFx0XHRza2VsZXRvbkRhdGEuZnBzID0gc2tlbGV0b25NYXAuZnBzO1xuXHRcdFx0XHRza2VsZXRvbkRhdGEuaW1hZ2VzUGF0aCA9IHNrZWxldG9uTWFwLmltYWdlcztcblx0XHRcdH1cblx0XHRcdGlmIChyb290LmJvbmVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5ib25lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBib25lTWFwID0gcm9vdC5ib25lc1tpXTtcblx0XHRcdFx0XHR2YXIgcGFyZW50XzIgPSBudWxsO1xuXHRcdFx0XHRcdHZhciBwYXJlbnROYW1lID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInBhcmVudFwiLCBudWxsKTtcblx0XHRcdFx0XHRpZiAocGFyZW50TmFtZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRfMiA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShwYXJlbnROYW1lKTtcblx0XHRcdFx0XHRcdGlmIChwYXJlbnRfMiA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgYm9uZSBub3QgZm91bmQ6IFwiICsgcGFyZW50TmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBkYXRhID0gbmV3IHNwaW5lLkJvbmVEYXRhKHNrZWxldG9uRGF0YS5ib25lcy5sZW5ndGgsIGJvbmVNYXAubmFtZSwgcGFyZW50XzIpO1xuXHRcdFx0XHRcdGRhdGEubGVuZ3RoID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcImxlbmd0aFwiLCAwKSAqIHNjYWxlO1xuXHRcdFx0XHRcdGRhdGEueCA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJ4XCIsIDApICogc2NhbGU7XG5cdFx0XHRcdFx0ZGF0YS55ID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcblx0XHRcdFx0XHRkYXRhLnJvdGF0aW9uID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInJvdGF0aW9uXCIsIDApO1xuXHRcdFx0XHRcdGRhdGEuc2NhbGVYID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNjYWxlWFwiLCAxKTtcblx0XHRcdFx0XHRkYXRhLnNjYWxlWSA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJzY2FsZVlcIiwgMSk7XG5cdFx0XHRcdFx0ZGF0YS5zaGVhclggPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwic2hlYXJYXCIsIDApO1xuXHRcdFx0XHRcdGRhdGEuc2hlYXJZID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNoZWFyWVwiLCAwKTtcblx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybU1vZGUgPSBTa2VsZXRvbkpzb24udHJhbnNmb3JtTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInRyYW5zZm9ybVwiLCBcIm5vcm1hbFwiKSk7XG5cdFx0XHRcdFx0c2tlbGV0b25EYXRhLmJvbmVzLnB1c2goZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyb290LnNsb3RzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5zbG90cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBzbG90TWFwID0gcm9vdC5zbG90c1tpXTtcblx0XHRcdFx0XHR2YXIgc2xvdE5hbWUgPSBzbG90TWFwLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGJvbmVOYW1lID0gc2xvdE1hcC5ib25lO1xuXHRcdFx0XHRcdHZhciBib25lRGF0YSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTmFtZSk7XG5cdFx0XHRcdFx0aWYgKGJvbmVEYXRhID09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTbG90IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IG5ldyBzcGluZS5TbG90RGF0YShza2VsZXRvbkRhdGEuc2xvdHMubGVuZ3RoLCBzbG90TmFtZSwgYm9uZURhdGEpO1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJjb2xvclwiLCBudWxsKTtcblx0XHRcdFx0XHRpZiAoY29sb3IgIT0gbnVsbClcblx0XHRcdFx0XHRcdGRhdGEuY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XG5cdFx0XHRcdFx0dmFyIGRhcmsgPSB0aGlzLmdldFZhbHVlKHNsb3RNYXAsIFwiZGFya1wiLCBudWxsKTtcblx0XHRcdFx0XHRpZiAoZGFyayAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRhcmtDb2xvciA9IG5ldyBzcGluZS5Db2xvcigxLCAxLCAxLCAxKTtcblx0XHRcdFx0XHRcdGRhdGEuZGFya0NvbG9yLnNldEZyb21TdHJpbmcoZGFyayk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEuYXR0YWNobWVudE5hbWUgPSB0aGlzLmdldFZhbHVlKHNsb3RNYXAsIFwiYXR0YWNobWVudFwiLCBudWxsKTtcblx0XHRcdFx0XHRkYXRhLmJsZW5kTW9kZSA9IFNrZWxldG9uSnNvbi5ibGVuZE1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJibGVuZFwiLCBcIm5vcm1hbFwiKSk7XG5cdFx0XHRcdFx0c2tlbGV0b25EYXRhLnNsb3RzLnB1c2goZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyb290LmlrKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5pay5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjb25zdHJhaW50TWFwID0gcm9vdC5pa1tpXTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IG5ldyBzcGluZS5Ja0NvbnN0cmFpbnREYXRhKGNvbnN0cmFpbnRNYXAubmFtZSk7XG5cdFx0XHRcdFx0ZGF0YS5vcmRlciA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJvcmRlclwiLCAwKTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvbnN0cmFpbnRNYXAuYm9uZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciBib25lTmFtZSA9IGNvbnN0cmFpbnRNYXAuYm9uZXNbal07XG5cdFx0XHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTmFtZSk7XG5cdFx0XHRcdFx0XHRpZiAoYm9uZSA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJSyBib25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZSk7XG5cdFx0XHRcdFx0XHRkYXRhLmJvbmVzLnB1c2goYm9uZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0YXJnZXROYW1lID0gY29uc3RyYWludE1hcC50YXJnZXQ7XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXQgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUodGFyZ2V0TmFtZSk7XG5cdFx0XHRcdFx0aWYgKGRhdGEudGFyZ2V0ID09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJSyB0YXJnZXQgYm9uZSBub3QgZm91bmQ6IFwiICsgdGFyZ2V0TmFtZSk7XG5cdFx0XHRcdFx0ZGF0YS5iZW5kRGlyZWN0aW9uID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcImJlbmRQb3NpdGl2ZVwiLCB0cnVlKSA/IDEgOiAtMTtcblx0XHRcdFx0XHRkYXRhLm1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJtaXhcIiwgMSk7XG5cdFx0XHRcdFx0c2tlbGV0b25EYXRhLmlrQ29uc3RyYWludHMucHVzaChkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJvb3QudHJhbnNmb3JtKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC50cmFuc2Zvcm0ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludE1hcCA9IHJvb3QudHJhbnNmb3JtW2ldO1xuXHRcdFx0XHRcdHZhciBkYXRhID0gbmV3IHNwaW5lLlRyYW5zZm9ybUNvbnN0cmFpbnREYXRhKGNvbnN0cmFpbnRNYXAubmFtZSk7XG5cdFx0XHRcdFx0ZGF0YS5vcmRlciA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJvcmRlclwiLCAwKTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvbnN0cmFpbnRNYXAuYm9uZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciBib25lTmFtZSA9IGNvbnN0cmFpbnRNYXAuYm9uZXNbal07XG5cdFx0XHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTmFtZSk7XG5cdFx0XHRcdFx0XHRpZiAoYm9uZSA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2Zvcm0gY29uc3RyYWludCBib25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZSk7XG5cdFx0XHRcdFx0XHRkYXRhLmJvbmVzLnB1c2goYm9uZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0YXJnZXROYW1lID0gY29uc3RyYWludE1hcC50YXJnZXQ7XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXQgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUodGFyZ2V0TmFtZSk7XG5cdFx0XHRcdFx0aWYgKGRhdGEudGFyZ2V0ID09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2Zvcm0gY29uc3RyYWludCB0YXJnZXQgYm9uZSBub3QgZm91bmQ6IFwiICsgdGFyZ2V0TmFtZSk7XG5cdFx0XHRcdFx0ZGF0YS5sb2NhbCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJsb2NhbFwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0ZGF0YS5yZWxhdGl2ZSA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyZWxhdGl2ZVwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0ZGF0YS5vZmZzZXRSb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGlvblwiLCAwKTtcblx0XHRcdFx0XHRkYXRhLm9mZnNldFggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwieFwiLCAwKSAqIHNjYWxlO1xuXHRcdFx0XHRcdGRhdGEub2Zmc2V0WSA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJ5XCIsIDApICogc2NhbGU7XG5cdFx0XHRcdFx0ZGF0YS5vZmZzZXRTY2FsZVggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2NhbGVYXCIsIDApO1xuXHRcdFx0XHRcdGRhdGEub2Zmc2V0U2NhbGVZID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNjYWxlWVwiLCAwKTtcblx0XHRcdFx0XHRkYXRhLm9mZnNldFNoZWFyWSA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzaGVhcllcIiwgMCk7XG5cdFx0XHRcdFx0ZGF0YS5yb3RhdGVNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicm90YXRlTWl4XCIsIDEpO1xuXHRcdFx0XHRcdGRhdGEudHJhbnNsYXRlTWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInRyYW5zbGF0ZU1peFwiLCAxKTtcblx0XHRcdFx0XHRkYXRhLnNjYWxlTWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNjYWxlTWl4XCIsIDEpO1xuXHRcdFx0XHRcdGRhdGEuc2hlYXJNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2hlYXJNaXhcIiwgMSk7XG5cdFx0XHRcdFx0c2tlbGV0b25EYXRhLnRyYW5zZm9ybUNvbnN0cmFpbnRzLnB1c2goZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyb290LnBhdGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByb290LnBhdGgubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludE1hcCA9IHJvb3QucGF0aFtpXTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IG5ldyBzcGluZS5QYXRoQ29uc3RyYWludERhdGEoY29uc3RyYWludE1hcC5uYW1lKTtcblx0XHRcdFx0XHRkYXRhLm9yZGVyID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcIm9yZGVyXCIsIDApO1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgY29uc3RyYWludE1hcC5ib25lcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0dmFyIGJvbmVOYW1lID0gY29uc3RyYWludE1hcC5ib25lc1tqXTtcblx0XHRcdFx0XHRcdHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVOYW1lKTtcblx0XHRcdFx0XHRcdGlmIChib25lID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybSBjb25zdHJhaW50IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcblx0XHRcdFx0XHRcdGRhdGEuYm9uZXMucHVzaChib25lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRhcmdldE5hbWUgPSBjb25zdHJhaW50TWFwLnRhcmdldDtcblx0XHRcdFx0XHRkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdCh0YXJnZXROYW1lKTtcblx0XHRcdFx0XHRpZiAoZGF0YS50YXJnZXQgPT0gbnVsbClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhdGggdGFyZ2V0IHNsb3Qgbm90IGZvdW5kOiBcIiArIHRhcmdldE5hbWUpO1xuXHRcdFx0XHRcdGRhdGEucG9zaXRpb25Nb2RlID0gU2tlbGV0b25Kc29uLnBvc2l0aW9uTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInBvc2l0aW9uTW9kZVwiLCBcInBlcmNlbnRcIikpO1xuXHRcdFx0XHRcdGRhdGEuc3BhY2luZ01vZGUgPSBTa2VsZXRvbkpzb24uc3BhY2luZ01vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzcGFjaW5nTW9kZVwiLCBcImxlbmd0aFwiKSk7XG5cdFx0XHRcdFx0ZGF0YS5yb3RhdGVNb2RlID0gU2tlbGV0b25Kc29uLnJvdGF0ZU1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGVNb2RlXCIsIFwidGFuZ2VudFwiKSk7XG5cdFx0XHRcdFx0ZGF0YS5vZmZzZXRSb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGlvblwiLCAwKTtcblx0XHRcdFx0XHRkYXRhLnBvc2l0aW9uID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInBvc2l0aW9uXCIsIDApO1xuXHRcdFx0XHRcdGlmIChkYXRhLnBvc2l0aW9uTW9kZSA9PSBzcGluZS5Qb3NpdGlvbk1vZGUuRml4ZWQpXG5cdFx0XHRcdFx0XHRkYXRhLnBvc2l0aW9uICo9IHNjYWxlO1xuXHRcdFx0XHRcdGRhdGEuc3BhY2luZyA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzcGFjaW5nXCIsIDApO1xuXHRcdFx0XHRcdGlmIChkYXRhLnNwYWNpbmdNb2RlID09IHNwaW5lLlNwYWNpbmdNb2RlLkxlbmd0aCB8fCBkYXRhLnNwYWNpbmdNb2RlID09IHNwaW5lLlNwYWNpbmdNb2RlLkZpeGVkKVxuXHRcdFx0XHRcdFx0ZGF0YS5zcGFjaW5nICo9IHNjYWxlO1xuXHRcdFx0XHRcdGRhdGEucm90YXRlTWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInJvdGF0ZU1peFwiLCAxKTtcblx0XHRcdFx0XHRkYXRhLnRyYW5zbGF0ZU1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJ0cmFuc2xhdGVNaXhcIiwgMSk7XG5cdFx0XHRcdFx0c2tlbGV0b25EYXRhLnBhdGhDb25zdHJhaW50cy5wdXNoKGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocm9vdC5za2lucykge1xuXHRcdFx0XHRmb3IgKHZhciBza2luTmFtZSBpbiByb290LnNraW5zKSB7XG5cdFx0XHRcdFx0dmFyIHNraW5NYXAgPSByb290LnNraW5zW3NraW5OYW1lXTtcblx0XHRcdFx0XHR2YXIgc2tpbiA9IG5ldyBzcGluZS5Ta2luKHNraW5OYW1lKTtcblx0XHRcdFx0XHRmb3IgKHZhciBzbG90TmFtZSBpbiBza2luTWFwKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2xvdEluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xuXHRcdFx0XHRcdFx0aWYgKHNsb3RJbmRleCA9PSAtMSlcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE5hbWUpO1xuXHRcdFx0XHRcdFx0dmFyIHNsb3RNYXAgPSBza2luTWFwW3Nsb3ROYW1lXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGVudHJ5TmFtZSBpbiBzbG90TWFwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChzbG90TWFwW2VudHJ5TmFtZV0sIHNraW4sIHNsb3RJbmRleCwgZW50cnlOYW1lLCBza2VsZXRvbkRhdGEpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudCAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdHNraW4uYWRkQXR0YWNobWVudChzbG90SW5kZXgsIGVudHJ5TmFtZSwgYXR0YWNobWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNrZWxldG9uRGF0YS5za2lucy5wdXNoKHNraW4pO1xuXHRcdFx0XHRcdGlmIChza2luLm5hbWUgPT0gXCJkZWZhdWx0XCIpXG5cdFx0XHRcdFx0XHRza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gPSBza2luO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMubGlua2VkTWVzaGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgbGlua2VkTWVzaCA9IHRoaXMubGlua2VkTWVzaGVzW2ldO1xuXHRcdFx0XHR2YXIgc2tpbiA9IGxpbmtlZE1lc2guc2tpbiA9PSBudWxsID8gc2tlbGV0b25EYXRhLmRlZmF1bHRTa2luIDogc2tlbGV0b25EYXRhLmZpbmRTa2luKGxpbmtlZE1lc2guc2tpbik7XG5cdFx0XHRcdGlmIChza2luID09IG51bGwpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2tpbiBub3QgZm91bmQ6IFwiICsgbGlua2VkTWVzaC5za2luKTtcblx0XHRcdFx0dmFyIHBhcmVudF8zID0gc2tpbi5nZXRBdHRhY2htZW50KGxpbmtlZE1lc2guc2xvdEluZGV4LCBsaW5rZWRNZXNoLnBhcmVudCk7XG5cdFx0XHRcdGlmIChwYXJlbnRfMyA9PSBudWxsKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBtZXNoIG5vdCBmb3VuZDogXCIgKyBsaW5rZWRNZXNoLnBhcmVudCk7XG5cdFx0XHRcdGxpbmtlZE1lc2gubWVzaC5zZXRQYXJlbnRNZXNoKHBhcmVudF8zKTtcblx0XHRcdFx0bGlua2VkTWVzaC5tZXNoLnVwZGF0ZVVWcygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5saW5rZWRNZXNoZXMubGVuZ3RoID0gMDtcblx0XHRcdGlmIChyb290LmV2ZW50cykge1xuXHRcdFx0XHRmb3IgKHZhciBldmVudE5hbWUgaW4gcm9vdC5ldmVudHMpIHtcblx0XHRcdFx0XHR2YXIgZXZlbnRNYXAgPSByb290LmV2ZW50c1tldmVudE5hbWVdO1xuXHRcdFx0XHRcdHZhciBkYXRhID0gbmV3IHNwaW5lLkV2ZW50RGF0YShldmVudE5hbWUpO1xuXHRcdFx0XHRcdGRhdGEuaW50VmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImludFwiLCAwKTtcblx0XHRcdFx0XHRkYXRhLmZsb2F0VmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImZsb2F0XCIsIDApO1xuXHRcdFx0XHRcdGRhdGEuc3RyaW5nVmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcInN0cmluZ1wiLCBcIlwiKTtcblx0XHRcdFx0XHRza2VsZXRvbkRhdGEuZXZlbnRzLnB1c2goZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyb290LmFuaW1hdGlvbnMpIHtcblx0XHRcdFx0Zm9yICh2YXIgYW5pbWF0aW9uTmFtZSBpbiByb290LmFuaW1hdGlvbnMpIHtcblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uTWFwID0gcm9vdC5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuXHRcdFx0XHRcdHRoaXMucmVhZEFuaW1hdGlvbihhbmltYXRpb25NYXAsIGFuaW1hdGlvbk5hbWUsIHNrZWxldG9uRGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBza2VsZXRvbkRhdGE7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkpzb24ucHJvdG90eXBlLnJlYWRBdHRhY2htZW50ID0gZnVuY3Rpb24gKG1hcCwgc2tpbiwgc2xvdEluZGV4LCBuYW1lLCBza2VsZXRvbkRhdGEpIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cdFx0XHRuYW1lID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwibmFtZVwiLCBuYW1lKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwidHlwZVwiLCBcInJlZ2lvblwiKTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlIFwicmVnaW9uXCI6IHtcblx0XHRcdFx0XHR2YXIgcGF0aCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInBhdGhcIiwgbmFtZSk7XG5cdFx0XHRcdFx0dmFyIHJlZ2lvbiA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdSZWdpb25BdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xuXHRcdFx0XHRcdGlmIChyZWdpb24gPT0gbnVsbClcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdHJlZ2lvbi5wYXRoID0gcGF0aDtcblx0XHRcdFx0XHRyZWdpb24ueCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInhcIiwgMCkgKiBzY2FsZTtcblx0XHRcdFx0XHRyZWdpb24ueSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcblx0XHRcdFx0XHRyZWdpb24uc2NhbGVYID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwic2NhbGVYXCIsIDEpO1xuXHRcdFx0XHRcdHJlZ2lvbi5zY2FsZVkgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJzY2FsZVlcIiwgMSk7XG5cdFx0XHRcdFx0cmVnaW9uLnJvdGF0aW9uID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwicm90YXRpb25cIiwgMCk7XG5cdFx0XHRcdFx0cmVnaW9uLndpZHRoID0gbWFwLndpZHRoICogc2NhbGU7XG5cdFx0XHRcdFx0cmVnaW9uLmhlaWdodCA9IG1hcC5oZWlnaHQgKiBzY2FsZTtcblx0XHRcdFx0XHR2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJjb2xvclwiLCBudWxsKTtcblx0XHRcdFx0XHRpZiAoY29sb3IgIT0gbnVsbClcblx0XHRcdFx0XHRcdHJlZ2lvbi5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcblx0XHRcdFx0XHRyZWdpb24udXBkYXRlT2Zmc2V0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFwiYm91bmRpbmdib3hcIjoge1xuXHRcdFx0XHRcdHZhciBib3ggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Qm91bmRpbmdCb3hBdHRhY2htZW50KHNraW4sIG5hbWUpO1xuXHRcdFx0XHRcdGlmIChib3ggPT0gbnVsbClcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdHRoaXMucmVhZFZlcnRpY2VzKG1hcCwgYm94LCBtYXAudmVydGV4Q291bnQgPDwgMSk7XG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXG5cdFx0XHRcdFx0XHRib3guY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XG5cdFx0XHRcdFx0cmV0dXJuIGJveDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFwibWVzaFwiOlxuXHRcdFx0XHRjYXNlIFwibGlua2VkbWVzaFwiOiB7XG5cdFx0XHRcdFx0dmFyIHBhdGggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJwYXRoXCIsIG5hbWUpO1xuXHRcdFx0XHRcdHZhciBtZXNoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld01lc2hBdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xuXHRcdFx0XHRcdGlmIChtZXNoID09IG51bGwpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRtZXNoLnBhdGggPSBwYXRoO1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xuXHRcdFx0XHRcdGlmIChjb2xvciAhPSBudWxsKVxuXHRcdFx0XHRcdFx0bWVzaC5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcblx0XHRcdFx0XHR2YXIgcGFyZW50XzQgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJwYXJlbnRcIiwgbnVsbCk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudF80ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdG1lc2guaW5oZXJpdERlZm9ybSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImRlZm9ybVwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdHRoaXMubGlua2VkTWVzaGVzLnB1c2gobmV3IExpbmtlZE1lc2gobWVzaCwgdGhpcy5nZXRWYWx1ZShtYXAsIFwic2tpblwiLCBudWxsKSwgc2xvdEluZGV4LCBwYXJlbnRfNCkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1lc2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB1dnMgPSBtYXAudXZzO1xuXHRcdFx0XHRcdHRoaXMucmVhZFZlcnRpY2VzKG1hcCwgbWVzaCwgdXZzLmxlbmd0aCk7XG5cdFx0XHRcdFx0bWVzaC50cmlhbmdsZXMgPSBtYXAudHJpYW5nbGVzO1xuXHRcdFx0XHRcdG1lc2gucmVnaW9uVVZzID0gdXZzO1xuXHRcdFx0XHRcdG1lc2gudXBkYXRlVVZzKCk7XG5cdFx0XHRcdFx0bWVzaC5odWxsTGVuZ3RoID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiaHVsbFwiLCAwKSAqIDI7XG5cdFx0XHRcdFx0cmV0dXJuIG1lc2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBcInBhdGhcIjoge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1BhdGhBdHRhY2htZW50KHNraW4sIG5hbWUpO1xuXHRcdFx0XHRcdGlmIChwYXRoID09IG51bGwpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRwYXRoLmNsb3NlZCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNsb3NlZFwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0cGF0aC5jb25zdGFudFNwZWVkID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29uc3RhbnRTcGVlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR2YXIgdmVydGV4Q291bnQgPSBtYXAudmVydGV4Q291bnQ7XG5cdFx0XHRcdFx0dGhpcy5yZWFkVmVydGljZXMobWFwLCBwYXRoLCB2ZXJ0ZXhDb3VudCA8PCAxKTtcblx0XHRcdFx0XHR2YXIgbGVuZ3RocyA9IHNwaW5lLlV0aWxzLm5ld0FycmF5KHZlcnRleENvdW50IC8gMywgMCk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3Rocy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRcdGxlbmd0aHNbaV0gPSBtYXAubGVuZ3Roc1tpXSAqIHNjYWxlO1xuXHRcdFx0XHRcdHBhdGgubGVuZ3RocyA9IGxlbmd0aHM7XG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXG5cdFx0XHRcdFx0XHRwYXRoLmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xuXHRcdFx0XHRcdHJldHVybiBwYXRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgXCJwb2ludFwiOiB7XG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1BvaW50QXR0YWNobWVudChza2luLCBuYW1lKTtcblx0XHRcdFx0XHRpZiAocG9pbnQgPT0gbnVsbClcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdHBvaW50LnggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJ4XCIsIDApICogc2NhbGU7XG5cdFx0XHRcdFx0cG9pbnQueSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcblx0XHRcdFx0XHRwb2ludC5yb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInJvdGF0aW9uXCIsIDApO1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xuXHRcdFx0XHRcdGlmIChjb2xvciAhPSBudWxsKVxuXHRcdFx0XHRcdFx0cG9pbnQuY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XG5cdFx0XHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgXCJjbGlwcGluZ1wiOiB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Q2xpcHBpbmdBdHRhY2htZW50KHNraW4sIG5hbWUpO1xuXHRcdFx0XHRcdGlmIChjbGlwID09IG51bGwpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR2YXIgZW5kID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiZW5kXCIsIG51bGwpO1xuXHRcdFx0XHRcdGlmIChlbmQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3QgPSBza2VsZXRvbkRhdGEuZmluZFNsb3QoZW5kKTtcblx0XHRcdFx0XHRcdGlmIChzbG90ID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNsaXBwaW5nIGVuZCBzbG90IG5vdCBmb3VuZDogXCIgKyBlbmQpO1xuXHRcdFx0XHRcdFx0Y2xpcC5lbmRTbG90ID0gc2xvdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHZlcnRleENvdW50ID0gbWFwLnZlcnRleENvdW50O1xuXHRcdFx0XHRcdHRoaXMucmVhZFZlcnRpY2VzKG1hcCwgY2xpcCwgdmVydGV4Q291bnQgPDwgMSk7XG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjbGlwLmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xuXHRcdFx0XHRcdHJldHVybiBjbGlwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFNrZWxldG9uSnNvbi5wcm90b3R5cGUucmVhZFZlcnRpY2VzID0gZnVuY3Rpb24gKG1hcCwgYXR0YWNobWVudCwgdmVydGljZXNMZW5ndGgpIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cdFx0XHRhdHRhY2htZW50LndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlc0xlbmd0aDtcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG1hcC52ZXJ0aWNlcztcblx0XHRcdGlmICh2ZXJ0aWNlc0xlbmd0aCA9PSB2ZXJ0aWNlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIHNjYWxlZFZlcnRpY2VzID0gc3BpbmUuVXRpbHMudG9GbG9hdEFycmF5KHZlcnRpY2VzKTtcblx0XHRcdFx0aWYgKHNjYWxlICE9IDEpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0XHRcdHNjYWxlZFZlcnRpY2VzW2ldICo9IHNjYWxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dGFjaG1lbnQudmVydGljZXMgPSBzY2FsZWRWZXJ0aWNlcztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHdlaWdodHMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHZhciBib25lcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBuOykge1xuXHRcdFx0XHR2YXIgYm9uZUNvdW50ID0gdmVydGljZXNbaSsrXTtcblx0XHRcdFx0Ym9uZXMucHVzaChib25lQ291bnQpO1xuXHRcdFx0XHRmb3IgKHZhciBubiA9IGkgKyBib25lQ291bnQgKiA0OyBpIDwgbm47IGkgKz0gNCkge1xuXHRcdFx0XHRcdGJvbmVzLnB1c2godmVydGljZXNbaV0pO1xuXHRcdFx0XHRcdHdlaWdodHMucHVzaCh2ZXJ0aWNlc1tpICsgMV0gKiBzY2FsZSk7XG5cdFx0XHRcdFx0d2VpZ2h0cy5wdXNoKHZlcnRpY2VzW2kgKyAyXSAqIHNjYWxlKTtcblx0XHRcdFx0XHR3ZWlnaHRzLnB1c2godmVydGljZXNbaSArIDNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YXR0YWNobWVudC5ib25lcyA9IGJvbmVzO1xuXHRcdFx0YXR0YWNobWVudC52ZXJ0aWNlcyA9IHNwaW5lLlV0aWxzLnRvRmxvYXRBcnJheSh3ZWlnaHRzKTtcblx0XHR9O1xuXHRcdFNrZWxldG9uSnNvbi5wcm90b3R5cGUucmVhZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNrZWxldG9uRGF0YSkge1xuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdHZhciB0aW1lbGluZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHZhciBkdXJhdGlvbiA9IDA7XG5cdFx0XHRpZiAobWFwLnNsb3RzKSB7XG5cdFx0XHRcdGZvciAodmFyIHNsb3ROYW1lIGluIG1hcC5zbG90cykge1xuXHRcdFx0XHRcdHZhciBzbG90TWFwID0gbWFwLnNsb3RzW3Nsb3ROYW1lXTtcblx0XHRcdFx0XHR2YXIgc2xvdEluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xuXHRcdFx0XHRcdGlmIChzbG90SW5kZXggPT0gLTEpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTbG90IG5vdCBmb3VuZDogXCIgKyBzbG90TmFtZSk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgdGltZWxpbmVOYW1lIGluIHNsb3RNYXApIHtcblx0XHRcdFx0XHRcdHZhciB0aW1lbGluZU1hcCA9IHNsb3RNYXBbdGltZWxpbmVOYW1lXTtcblx0XHRcdFx0XHRcdGlmICh0aW1lbGluZU5hbWUgPT0gXCJhdHRhY2htZW50XCIpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLkF0dGFjaG1lbnRUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cdFx0XHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgdmFsdWVNYXAudGltZSwgdmFsdWVNYXAubmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwiY29sb3JcIikge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuQ29sb3JUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cdFx0XHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBjb2xvciA9IG5ldyBzcGluZS5Db2xvcigpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbG9yLnNldEZyb21TdHJpbmcodmFsdWVNYXAuY29sb3IpO1xuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwLnRpbWUsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIHNwaW5lLkNvbG9yVGltZWxpbmUuRU5UUklFU10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwidHdvQ29sb3JcIikge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuVHdvQ29sb3JUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cdFx0XHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBsaWdodCA9IG5ldyBzcGluZS5Db2xvcigpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXJrID0gbmV3IHNwaW5lLkNvbG9yKCk7XG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQuc2V0RnJvbVN0cmluZyh2YWx1ZU1hcC5saWdodCk7XG5cdFx0XHRcdFx0XHRcdFx0ZGFyay5zZXRGcm9tU3RyaW5nKHZhbHVlTWFwLmRhcmspO1xuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwLnRpbWUsIGxpZ2h0LnIsIGxpZ2h0LmcsIGxpZ2h0LmIsIGxpZ2h0LmEsIGRhcmsuciwgZGFyay5nLCBkYXJrLmIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIHNwaW5lLlR3b0NvbG9yVGltZWxpbmUuRU5UUklFU10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRpbWVsaW5lIHR5cGUgZm9yIGEgc2xvdDogXCIgKyB0aW1lbGluZU5hbWUgKyBcIiAoXCIgKyBzbG90TmFtZSArIFwiKVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChtYXAuYm9uZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgYm9uZU5hbWUgaW4gbWFwLmJvbmVzKSB7XG5cdFx0XHRcdFx0dmFyIGJvbmVNYXAgPSBtYXAuYm9uZXNbYm9uZU5hbWVdO1xuXHRcdFx0XHRcdHZhciBib25lSW5kZXggPSBza2VsZXRvbkRhdGEuZmluZEJvbmVJbmRleChib25lTmFtZSk7XG5cdFx0XHRcdFx0aWYgKGJvbmVJbmRleCA9PSAtMSlcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcblx0XHRcdFx0XHRmb3IgKHZhciB0aW1lbGluZU5hbWUgaW4gYm9uZU1hcCkge1xuXHRcdFx0XHRcdFx0dmFyIHRpbWVsaW5lTWFwID0gYm9uZU1hcFt0aW1lbGluZU5hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJyb3RhdGVcIikge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuUm90YXRlVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0dGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcC50aW1lLCB2YWx1ZU1hcC5hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogc3BpbmUuUm90YXRlVGltZWxpbmUuRU5UUklFU10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodGltZWxpbmVOYW1lID09PSBcInRyYW5zbGF0ZVwiIHx8IHRpbWVsaW5lTmFtZSA9PT0gXCJzY2FsZVwiIHx8IHRpbWVsaW5lTmFtZSA9PT0gXCJzaGVhclwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aW1lbGluZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHZhciB0aW1lbGluZVNjYWxlID0gMTtcblx0XHRcdFx0XHRcdFx0aWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJzY2FsZVwiKVxuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lID0gbmV3IHNwaW5lLlNjYWxlVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGltZWxpbmVOYW1lID09PSBcInNoZWFyXCIpXG5cdFx0XHRcdFx0XHRcdFx0dGltZWxpbmUgPSBuZXcgc3BpbmUuU2hlYXJUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZSA9IG5ldyBzcGluZS5UcmFuc2xhdGVUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XG5cdFx0XHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4ID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ4XCIsIDApLCB5ID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ5XCIsIDApO1xuXHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwLnRpbWUsIHggKiB0aW1lbGluZVNjYWxlLCB5ICogdGltZWxpbmVTY2FsZSk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFU10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRpbWVsaW5lIHR5cGUgZm9yIGEgYm9uZTogXCIgKyB0aW1lbGluZU5hbWUgKyBcIiAoXCIgKyBib25lTmFtZSArIFwiKVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChtYXAuaWspIHtcblx0XHRcdFx0Zm9yICh2YXIgY29uc3RyYWludE5hbWUgaW4gbWFwLmlrKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnN0cmFpbnRNYXAgPSBtYXAuaWtbY29uc3RyYWludE5hbWVdO1xuXHRcdFx0XHRcdHZhciBjb25zdHJhaW50ID0gc2tlbGV0b25EYXRhLmZpbmRJa0NvbnN0cmFpbnQoY29uc3RyYWludE5hbWUpO1xuXHRcdFx0XHRcdHZhciB0aW1lbGluZSA9IG5ldyBzcGluZS5Ja0NvbnN0cmFpbnRUaW1lbGluZShjb25zdHJhaW50TWFwLmxlbmd0aCk7XG5cdFx0XHRcdFx0dGltZWxpbmUuaWtDb25zdHJhaW50SW5kZXggPSBza2VsZXRvbkRhdGEuaWtDb25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRNYXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IGNvbnN0cmFpbnRNYXBbaV07XG5cdFx0XHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcC50aW1lLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcIm1peFwiLCAxKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJiZW5kUG9zaXRpdmVcIiwgdHJ1ZSkgPyAxIDogLTEpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcblx0XHRcdFx0XHRcdGZyYW1lSW5kZXgrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBzcGluZS5Ja0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChtYXAudHJhbnNmb3JtKSB7XG5cdFx0XHRcdGZvciAodmFyIGNvbnN0cmFpbnROYW1lIGluIG1hcC50cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludE1hcCA9IG1hcC50cmFuc2Zvcm1bY29uc3RyYWludE5hbWVdO1xuXHRcdFx0XHRcdHZhciBjb25zdHJhaW50ID0gc2tlbGV0b25EYXRhLmZpbmRUcmFuc2Zvcm1Db25zdHJhaW50KGNvbnN0cmFpbnROYW1lKTtcblx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lKGNvbnN0cmFpbnRNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHR0aW1lbGluZS50cmFuc2Zvcm1Db25zdHJhaW50SW5kZXggPSBza2VsZXRvbkRhdGEudHJhbnNmb3JtQ29uc3RyYWludHMuaW5kZXhPZihjb25zdHJhaW50KTtcblx0XHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50TWFwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSBjb25zdHJhaW50TWFwW2ldO1xuXHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXAudGltZSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJyb3RhdGVNaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidHJhbnNsYXRlTWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInNjYWxlTWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInNoZWFyTWl4XCIsIDEpKTtcblx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogc3BpbmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG1hcC5wYXRocykge1xuXHRcdFx0XHRmb3IgKHZhciBjb25zdHJhaW50TmFtZSBpbiBtYXAucGF0aHMpIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludE1hcCA9IG1hcC5wYXRoc1tjb25zdHJhaW50TmFtZV07XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRQYXRoQ29uc3RyYWludEluZGV4KGNvbnN0cmFpbnROYW1lKTtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT0gLTEpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGNvbnN0cmFpbnQgbm90IGZvdW5kOiBcIiArIGNvbnN0cmFpbnROYW1lKTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IHNrZWxldG9uRGF0YS5wYXRoQ29uc3RyYWludHNbaW5kZXhdO1xuXHRcdFx0XHRcdGZvciAodmFyIHRpbWVsaW5lTmFtZSBpbiBjb25zdHJhaW50TWFwKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGltZWxpbmVNYXAgPSBjb25zdHJhaW50TWFwW3RpbWVsaW5lTmFtZV07XG5cdFx0XHRcdFx0XHRpZiAodGltZWxpbmVOYW1lID09PSBcInBvc2l0aW9uXCIgfHwgdGltZWxpbmVOYW1lID09PSBcInNwYWNpbmdcIikge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmVTY2FsZSA9IDE7XG5cdFx0XHRcdFx0XHRcdGlmICh0aW1lbGluZU5hbWUgPT09IFwic3BhY2luZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGltZWxpbmUgPSBuZXcgc3BpbmUuUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5zcGFjaW5nTW9kZSA9PSBzcGluZS5TcGFjaW5nTW9kZS5MZW5ndGggfHwgZGF0YS5zcGFjaW5nTW9kZSA9PSBzcGluZS5TcGFjaW5nTW9kZS5GaXhlZClcblx0XHRcdFx0XHRcdFx0XHRcdHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZSA9IG5ldyBzcGluZS5QYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5wb3NpdGlvbk1vZGUgPT0gc3BpbmUuUG9zaXRpb25Nb2RlLkZpeGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZWxpbmVTY2FsZSA9IHNjYWxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lLnBhdGhDb25zdHJhaW50SW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXAudGltZSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgdGltZWxpbmVOYW1lLCAwKSAqIHRpbWVsaW5lU2NhbGUpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIHNwaW5lLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh0aW1lbGluZU5hbWUgPT09IFwibWl4XCIpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLlBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0dGltZWxpbmUucGF0aENvbnN0cmFpbnRJbmRleCA9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcC50aW1lLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInJvdGF0ZU1peFwiLCAxKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0cmFuc2xhdGVNaXhcIiwgMSkpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIHNwaW5lLlBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFU10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG1hcC5kZWZvcm0pIHtcblx0XHRcdFx0Zm9yICh2YXIgZGVmb3JtTmFtZSBpbiBtYXAuZGVmb3JtKSB7XG5cdFx0XHRcdFx0dmFyIGRlZm9ybU1hcCA9IG1hcC5kZWZvcm1bZGVmb3JtTmFtZV07XG5cdFx0XHRcdFx0dmFyIHNraW4gPSBza2VsZXRvbkRhdGEuZmluZFNraW4oZGVmb3JtTmFtZSk7XG5cdFx0XHRcdFx0aWYgKHNraW4gPT0gbnVsbClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNraW4gbm90IGZvdW5kOiBcIiArIGRlZm9ybU5hbWUpO1xuXHRcdFx0XHRcdGZvciAodmFyIHNsb3ROYW1lIGluIGRlZm9ybU1hcCkge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3RNYXAgPSBkZWZvcm1NYXBbc2xvdE5hbWVdO1xuXHRcdFx0XHRcdFx0dmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcblx0XHRcdFx0XHRcdGlmIChzbG90SW5kZXggPT0gLTEpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3RNYXAubmFtZSk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciB0aW1lbGluZU5hbWUgaW4gc2xvdE1hcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGltZWxpbmVNYXAgPSBzbG90TWFwW3RpbWVsaW5lTmFtZV07XG5cdFx0XHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgdGltZWxpbmVOYW1lKTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEZWZvcm0gYXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgdGltZWxpbmVNYXAubmFtZSk7XG5cdFx0XHRcdFx0XHRcdHZhciB3ZWlnaHRlZCA9IGF0dGFjaG1lbnQuYm9uZXMgIT0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gYXR0YWNobWVudC52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdFx0dmFyIGRlZm9ybUxlbmd0aCA9IHdlaWdodGVkID8gdmVydGljZXMubGVuZ3RoIC8gMyAqIDIgOiB2ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHZhciB0aW1lbGluZSA9IG5ldyBzcGluZS5EZWZvcm1UaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuXHRcdFx0XHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtqXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVmb3JtID0gdm9pZCAwO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2ZXJ0aWNlc1ZhbHVlID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ2ZXJ0aWNlc1wiLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmVydGljZXNWYWx1ZSA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmb3JtID0gd2VpZ2h0ZWQgPyBzcGluZS5VdGlscy5uZXdGbG9hdEFycmF5KGRlZm9ybUxlbmd0aCkgOiB2ZXJ0aWNlcztcblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlZm9ybSA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZGVmb3JtTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwib2Zmc2V0XCIsIDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0c3BpbmUuVXRpbHMuYXJyYXlDb3B5KHZlcnRpY2VzVmFsdWUsIDAsIGRlZm9ybSwgc3RhcnQsIHZlcnRpY2VzVmFsdWUubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChzY2FsZSAhPSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSBzdGFydCwgbiA9IGkgKyB2ZXJ0aWNlc1ZhbHVlLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZvcm1baV0gKj0gc2NhbGU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIXdlaWdodGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVmb3JtTGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmb3JtW2ldICs9IHZlcnRpY2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcC50aW1lLCBkZWZvcm0pO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBkcmF3T3JkZXJOb2RlID0gbWFwLmRyYXdPcmRlcjtcblx0XHRcdGlmIChkcmF3T3JkZXJOb2RlID09IG51bGwpXG5cdFx0XHRcdGRyYXdPcmRlck5vZGUgPSBtYXAuZHJhd29yZGVyO1xuXHRcdFx0aWYgKGRyYXdPcmRlck5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuRHJhd09yZGVyVGltZWxpbmUoZHJhd09yZGVyTm9kZS5sZW5ndGgpO1xuXHRcdFx0XHR2YXIgc2xvdENvdW50ID0gc2tlbGV0b25EYXRhLnNsb3RzLmxlbmd0aDtcblx0XHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRyYXdPcmRlck5vZGUubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgZHJhd09yZGVyTWFwID0gZHJhd09yZGVyTm9kZVtqXTtcblx0XHRcdFx0XHR2YXIgZHJhd09yZGVyID0gbnVsbDtcblx0XHRcdFx0XHR2YXIgb2Zmc2V0cyA9IHRoaXMuZ2V0VmFsdWUoZHJhd09yZGVyTWFwLCBcIm9mZnNldHNcIiwgbnVsbCk7XG5cdFx0XHRcdFx0aWYgKG9mZnNldHMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHJhd09yZGVyID0gc3BpbmUuVXRpbHMubmV3QXJyYXkoc2xvdENvdW50LCAtMSk7XG5cdFx0XHRcdFx0XHR2YXIgdW5jaGFuZ2VkID0gc3BpbmUuVXRpbHMubmV3QXJyYXkoc2xvdENvdW50IC0gb2Zmc2V0cy5sZW5ndGgsIDApO1xuXHRcdFx0XHRcdFx0dmFyIG9yaWdpbmFsSW5kZXggPSAwLCB1bmNoYW5nZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldE1hcCA9IG9mZnNldHNbaV07XG5cdFx0XHRcdFx0XHRcdHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChvZmZzZXRNYXAuc2xvdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChzbG90SW5kZXggPT0gLTEpXG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgb2Zmc2V0TWFwLnNsb3QpO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAob3JpZ2luYWxJbmRleCAhPSBzbG90SW5kZXgpXG5cdFx0XHRcdFx0XHRcdFx0dW5jaGFuZ2VkW3VuY2hhbmdlZEluZGV4KytdID0gb3JpZ2luYWxJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHRkcmF3T3JkZXJbb3JpZ2luYWxJbmRleCArIG9mZnNldE1hcC5vZmZzZXRdID0gb3JpZ2luYWxJbmRleCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKG9yaWdpbmFsSW5kZXggPCBzbG90Q291bnQpXG5cdFx0XHRcdFx0XHRcdHVuY2hhbmdlZFt1bmNoYW5nZWRJbmRleCsrXSA9IG9yaWdpbmFsSW5kZXgrKztcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSBzbG90Q291bnQgLSAxOyBpID49IDA7IGktLSlcblx0XHRcdFx0XHRcdFx0aWYgKGRyYXdPcmRlcltpXSA9PSAtMSlcblx0XHRcdFx0XHRcdFx0XHRkcmF3T3JkZXJbaV0gPSB1bmNoYW5nZWRbLS11bmNoYW5nZWRJbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgZHJhd09yZGVyTWFwLnRpbWUsIGRyYXdPcmRlcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1hcC5ldmVudHMpIHtcblx0XHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLkV2ZW50VGltZWxpbmUobWFwLmV2ZW50cy5sZW5ndGgpO1xuXHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBldmVudE1hcCA9IG1hcC5ldmVudHNbaV07XG5cdFx0XHRcdFx0dmFyIGV2ZW50RGF0YSA9IHNrZWxldG9uRGF0YS5maW5kRXZlbnQoZXZlbnRNYXAubmFtZSk7XG5cdFx0XHRcdFx0aWYgKGV2ZW50RGF0YSA9PSBudWxsKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbm90IGZvdW5kOiBcIiArIGV2ZW50TWFwLm5hbWUpO1xuXHRcdFx0XHRcdHZhciBldmVudF81ID0gbmV3IHNwaW5lLkV2ZW50KGV2ZW50TWFwLnRpbWUsIGV2ZW50RGF0YSk7XG5cdFx0XHRcdFx0ZXZlbnRfNS5pbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiaW50XCIsIGV2ZW50RGF0YS5pbnRWYWx1ZSk7XG5cdFx0XHRcdFx0ZXZlbnRfNS5mbG9hdFZhbHVlID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJmbG9hdFwiLCBldmVudERhdGEuZmxvYXRWYWx1ZSk7XG5cdFx0XHRcdFx0ZXZlbnRfNS5zdHJpbmdWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwic3RyaW5nXCIsIGV2ZW50RGF0YS5zdHJpbmdWYWx1ZSk7XG5cdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCsrLCBldmVudF81KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG5cdFx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNOYU4oZHVyYXRpb24pKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkVycm9yIHdoaWxlIHBhcnNpbmcgYW5pbWF0aW9uLCBkdXJhdGlvbiBpcyBOYU5cIik7XG5cdFx0XHR9XG5cdFx0XHRza2VsZXRvbkRhdGEuYW5pbWF0aW9ucy5wdXNoKG5ldyBzcGluZS5BbmltYXRpb24obmFtZSwgdGltZWxpbmVzLCBkdXJhdGlvbikpO1xuXHRcdH07XG5cdFx0U2tlbGV0b25Kc29uLnByb3RvdHlwZS5yZWFkQ3VydmUgPSBmdW5jdGlvbiAobWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCkge1xuXHRcdFx0aWYgKCFtYXAuY3VydmUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGlmIChtYXAuY3VydmUgPT09IFwic3RlcHBlZFwiKVxuXHRcdFx0XHR0aW1lbGluZS5zZXRTdGVwcGVkKGZyYW1lSW5kZXgpO1xuXHRcdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1hcC5jdXJ2ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdFx0dmFyIGN1cnZlID0gbWFwLmN1cnZlO1xuXHRcdFx0XHR0aW1lbGluZS5zZXRDdXJ2ZShmcmFtZUluZGV4LCBjdXJ2ZVswXSwgY3VydmVbMV0sIGN1cnZlWzJdLCBjdXJ2ZVszXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTa2VsZXRvbkpzb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKG1hcCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gbWFwW3Byb3BdICE9PSB1bmRlZmluZWQgPyBtYXBbcHJvcF0gOiBkZWZhdWx0VmFsdWU7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkpzb24uYmxlbmRNb2RlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKHN0ciA9PSBcIm5vcm1hbFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuQmxlbmRNb2RlLk5vcm1hbDtcblx0XHRcdGlmIChzdHIgPT0gXCJhZGRpdGl2ZVwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuQmxlbmRNb2RlLkFkZGl0aXZlO1xuXHRcdFx0aWYgKHN0ciA9PSBcIm11bHRpcGx5XCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5CbGVuZE1vZGUuTXVsdGlwbHk7XG5cdFx0XHRpZiAoc3RyID09IFwic2NyZWVuXCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5CbGVuZE1vZGUuU2NyZWVuO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBibGVuZCBtb2RlOiBcIiArIHN0cik7XG5cdFx0fTtcblx0XHRTa2VsZXRvbkpzb24ucG9zaXRpb25Nb2RlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKHN0ciA9PSBcImZpeGVkXCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5Qb3NpdGlvbk1vZGUuRml4ZWQ7XG5cdFx0XHRpZiAoc3RyID09IFwicGVyY2VudFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuUG9zaXRpb25Nb2RlLlBlcmNlbnQ7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBvc2l0aW9uIG1vZGU6IFwiICsgc3RyKTtcblx0XHR9O1xuXHRcdFNrZWxldG9uSnNvbi5zcGFjaW5nTW9kZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChzdHIgPT0gXCJsZW5ndGhcIilcblx0XHRcdFx0cmV0dXJuIHNwaW5lLlNwYWNpbmdNb2RlLkxlbmd0aDtcblx0XHRcdGlmIChzdHIgPT0gXCJmaXhlZFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuU3BhY2luZ01vZGUuRml4ZWQ7XG5cdFx0XHRpZiAoc3RyID09IFwicGVyY2VudFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuU3BhY2luZ01vZGUuUGVyY2VudDtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcG9zaXRpb24gbW9kZTogXCIgKyBzdHIpO1xuXHRcdH07XG5cdFx0U2tlbGV0b25Kc29uLnJvdGF0ZU1vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0c3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAoc3RyID09IFwidGFuZ2VudFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuUm90YXRlTW9kZS5UYW5nZW50O1xuXHRcdFx0aWYgKHN0ciA9PSBcImNoYWluXCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5Sb3RhdGVNb2RlLkNoYWluO1xuXHRcdFx0aWYgKHN0ciA9PSBcImNoYWluc2NhbGVcIilcblx0XHRcdFx0cmV0dXJuIHNwaW5lLlJvdGF0ZU1vZGUuQ2hhaW5TY2FsZTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm90YXRlIG1vZGU6IFwiICsgc3RyKTtcblx0XHR9O1xuXHRcdFNrZWxldG9uSnNvbi50cmFuc2Zvcm1Nb2RlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKHN0ciA9PSBcIm5vcm1hbFwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuVHJhbnNmb3JtTW9kZS5Ob3JtYWw7XG5cdFx0XHRpZiAoc3RyID09IFwib25seXRyYW5zbGF0aW9uXCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5UcmFuc2Zvcm1Nb2RlLk9ubHlUcmFuc2xhdGlvbjtcblx0XHRcdGlmIChzdHIgPT0gXCJub3JvdGF0aW9ub3JyZWZsZWN0aW9uXCIpXG5cdFx0XHRcdHJldHVybiBzcGluZS5UcmFuc2Zvcm1Nb2RlLk5vUm90YXRpb25PclJlZmxlY3Rpb247XG5cdFx0XHRpZiAoc3RyID09IFwibm9zY2FsZVwiKVxuXHRcdFx0XHRyZXR1cm4gc3BpbmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlO1xuXHRcdFx0aWYgKHN0ciA9PSBcIm5vc2NhbGVvcnJlZmxlY3Rpb25cIilcblx0XHRcdFx0cmV0dXJuIHNwaW5lLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbjtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNmb3JtIG1vZGU6IFwiICsgc3RyKTtcblx0XHR9O1xuXHRcdHJldHVybiBTa2VsZXRvbkpzb247XG5cdH0oKSk7XG5cdHNwaW5lLlNrZWxldG9uSnNvbiA9IFNrZWxldG9uSnNvbjtcblx0dmFyIExpbmtlZE1lc2ggPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIExpbmtlZE1lc2gobWVzaCwgc2tpbiwgc2xvdEluZGV4LCBwYXJlbnQpIHtcblx0XHRcdHRoaXMubWVzaCA9IG1lc2g7XG5cdFx0XHR0aGlzLnNraW4gPSBza2luO1xuXHRcdFx0dGhpcy5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIExpbmtlZE1lc2g7XG5cdH0oKSk7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgU2tpbiA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gU2tpbihuYW1lKSB7XG5cdFx0XHR0aGlzLmF0dGFjaG1lbnRzID0gbmV3IEFycmF5KCk7XG5cdFx0XHRpZiAobmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0fVxuXHRcdFNraW4ucHJvdG90eXBlLmFkZEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lLCBhdHRhY2htZW50KSB7XG5cdFx0XHRpZiAoYXR0YWNobWVudCA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhdHRhY2htZW50IGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHZhciBhdHRhY2htZW50cyA9IHRoaXMuYXR0YWNobWVudHM7XG5cdFx0XHRpZiAoc2xvdEluZGV4ID49IGF0dGFjaG1lbnRzLmxlbmd0aClcblx0XHRcdFx0YXR0YWNobWVudHMubGVuZ3RoID0gc2xvdEluZGV4ICsgMTtcblx0XHRcdGlmICghYXR0YWNobWVudHNbc2xvdEluZGV4XSlcblx0XHRcdFx0YXR0YWNobWVudHNbc2xvdEluZGV4XSA9IHt9O1xuXHRcdFx0YXR0YWNobWVudHNbc2xvdEluZGV4XVtuYW1lXSA9IGF0dGFjaG1lbnQ7XG5cdFx0fTtcblx0XHRTa2luLnByb3RvdHlwZS5nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNsb3RJbmRleCwgbmFtZSkge1xuXHRcdFx0dmFyIGRpY3Rpb25hcnkgPSB0aGlzLmF0dGFjaG1lbnRzW3Nsb3RJbmRleF07XG5cdFx0XHRyZXR1cm4gZGljdGlvbmFyeSA/IGRpY3Rpb25hcnlbbmFtZV0gOiBudWxsO1xuXHRcdH07XG5cdFx0U2tpbi5wcm90b3R5cGUuYXR0YWNoQWxsID0gZnVuY3Rpb24gKHNrZWxldG9uLCBvbGRTa2luKSB7XG5cdFx0XHR2YXIgc2xvdEluZGV4ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1tpXTtcblx0XHRcdFx0dmFyIHNsb3RBdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cdFx0XHRcdGlmIChzbG90QXR0YWNobWVudCAmJiBzbG90SW5kZXggPCBvbGRTa2luLmF0dGFjaG1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBkaWN0aW9uYXJ5ID0gb2xkU2tpbi5hdHRhY2htZW50c1tzbG90SW5kZXhdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBkaWN0aW9uYXJ5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2tpbkF0dGFjaG1lbnQgPSBkaWN0aW9uYXJ5W2tleV07XG5cdFx0XHRcdFx0XHRpZiAoc2xvdEF0dGFjaG1lbnQgPT0gc2tpbkF0dGFjaG1lbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBrZXkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudCAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNsb3RJbmRleCsrO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFNraW47XG5cdH0oKSk7XG5cdHNwaW5lLlNraW4gPSBTa2luO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFNsb3QgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFNsb3QoZGF0YSwgYm9uZSkge1xuXHRcdFx0dGhpcy5hdHRhY2htZW50VmVydGljZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKGJvbmUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYm9uZSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0dGhpcy5ib25lID0gYm9uZTtcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoKTtcblx0XHRcdHRoaXMuZGFya0NvbG9yID0gZGF0YS5kYXJrQ29sb3IgPT0gbnVsbCA/IG51bGwgOiBuZXcgc3BpbmUuQ29sb3IoKTtcblx0XHRcdHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcblx0XHR9XG5cdFx0U2xvdC5wcm90b3R5cGUuZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dGFjaG1lbnQ7XG5cdFx0fTtcblx0XHRTbG90LnByb3RvdHlwZS5zZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcblx0XHRcdGlmICh0aGlzLmF0dGFjaG1lbnQgPT0gYXR0YWNobWVudClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhpcy5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcblx0XHRcdHRoaXMuYXR0YWNobWVudFRpbWUgPSB0aGlzLmJvbmUuc2tlbGV0b24udGltZTtcblx0XHRcdHRoaXMuYXR0YWNobWVudFZlcnRpY2VzLmxlbmd0aCA9IDA7XG5cdFx0fTtcblx0XHRTbG90LnByb3RvdHlwZS5zZXRBdHRhY2htZW50VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHR0aGlzLmF0dGFjaG1lbnRUaW1lID0gdGhpcy5ib25lLnNrZWxldG9uLnRpbWUgLSB0aW1lO1xuXHRcdH07XG5cdFx0U2xvdC5wcm90b3R5cGUuZ2V0QXR0YWNobWVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ib25lLnNrZWxldG9uLnRpbWUgLSB0aGlzLmF0dGFjaG1lbnRUaW1lO1xuXHRcdH07XG5cdFx0U2xvdC5wcm90b3R5cGUuc2V0VG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmRhdGEuY29sb3IpO1xuXHRcdFx0aWYgKHRoaXMuZGFya0NvbG9yICE9IG51bGwpXG5cdFx0XHRcdHRoaXMuZGFya0NvbG9yLnNldEZyb21Db2xvcih0aGlzLmRhdGEuZGFya0NvbG9yKTtcblx0XHRcdGlmICh0aGlzLmRhdGEuYXR0YWNobWVudE5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhpcy5hdHRhY2htZW50ID0gbnVsbDtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmF0dGFjaG1lbnQgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnNldEF0dGFjaG1lbnQodGhpcy5ib25lLnNrZWxldG9uLmdldEF0dGFjaG1lbnQodGhpcy5kYXRhLmluZGV4LCB0aGlzLmRhdGEuYXR0YWNobWVudE5hbWUpKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBTbG90O1xuXHR9KCkpO1xuXHRzcGluZS5TbG90ID0gU2xvdDtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBTbG90RGF0YSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gU2xvdERhdGEoaW5kZXgsIG5hbWUsIGJvbmVEYXRhKSB7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IHNwaW5lLkNvbG9yKDEsIDEsIDEsIDEpO1xuXHRcdFx0aWYgKGluZGV4IDwgMClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5kZXggbXVzdCBiZSA+PSAwLlwiKTtcblx0XHRcdGlmIChuYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0aWYgKGJvbmVEYXRhID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJvbmVEYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcblx0XHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLmJvbmVEYXRhID0gYm9uZURhdGE7XG5cdFx0fVxuXHRcdHJldHVybiBTbG90RGF0YTtcblx0fSgpKTtcblx0c3BpbmUuU2xvdERhdGEgPSBTbG90RGF0YTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBUZXh0dXJlID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUZXh0dXJlKGltYWdlKSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdH1cblx0XHRUZXh0dXJlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0XHR9O1xuXHRcdFRleHR1cmUuZmlsdGVyRnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRzd2l0Y2ggKHRleHQudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRjYXNlIFwibmVhcmVzdFwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5OZWFyZXN0O1xuXHRcdFx0XHRjYXNlIFwibGluZWFyXCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLkxpbmVhcjtcblx0XHRcdFx0Y2FzZSBcIm1pcG1hcFwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5NaXBNYXA7XG5cdFx0XHRcdGNhc2UgXCJtaXBtYXBuZWFyZXN0bmVhcmVzdFwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5NaXBNYXBOZWFyZXN0TmVhcmVzdDtcblx0XHRcdFx0Y2FzZSBcIm1pcG1hcGxpbmVhcm5lYXJlc3RcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTGluZWFyTmVhcmVzdDtcblx0XHRcdFx0Y2FzZSBcIm1pcG1hcG5lYXJlc3RsaW5lYXJcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTmVhcmVzdExpbmVhcjtcblx0XHRcdFx0Y2FzZSBcIm1pcG1hcGxpbmVhcmxpbmVhclwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5NaXBNYXBMaW5lYXJMaW5lYXI7XG5cdFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGV4dHVyZSBmaWx0ZXIgXCIgKyB0ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFRleHR1cmUud3JhcEZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0c3dpdGNoICh0ZXh0LnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0Y2FzZSBcIm1pcnJvcmVkdGVwZWF0XCI6IHJldHVybiBUZXh0dXJlV3JhcC5NaXJyb3JlZFJlcGVhdDtcblx0XHRcdFx0Y2FzZSBcImNsYW1wdG9lZGdlXCI6IHJldHVybiBUZXh0dXJlV3JhcC5DbGFtcFRvRWRnZTtcblx0XHRcdFx0Y2FzZSBcInJlcGVhdFwiOiByZXR1cm4gVGV4dHVyZVdyYXAuUmVwZWF0O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRleHR1cmUgd3JhcCBcIiArIHRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFRleHR1cmU7XG5cdH0oKSk7XG5cdHNwaW5lLlRleHR1cmUgPSBUZXh0dXJlO1xuXHQoZnVuY3Rpb24gKFRleHR1cmVGaWx0ZXIpIHtcblx0XHRUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJOZWFyZXN0XCJdID0gOTcyOF0gPSBcIk5lYXJlc3RcIjtcblx0XHRUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJMaW5lYXJcIl0gPSA5NzI5XSA9IFwiTGluZWFyXCI7XG5cdFx0VGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwXCJdID0gOTk4N10gPSBcIk1pcE1hcFwiO1xuXHRcdFRleHR1cmVGaWx0ZXJbVGV4dHVyZUZpbHRlcltcIk1pcE1hcE5lYXJlc3ROZWFyZXN0XCJdID0gOTk4NF0gPSBcIk1pcE1hcE5lYXJlc3ROZWFyZXN0XCI7XG5cdFx0VGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwTGluZWFyTmVhcmVzdFwiXSA9IDk5ODVdID0gXCJNaXBNYXBMaW5lYXJOZWFyZXN0XCI7XG5cdFx0VGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwTmVhcmVzdExpbmVhclwiXSA9IDk5ODZdID0gXCJNaXBNYXBOZWFyZXN0TGluZWFyXCI7XG5cdFx0VGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwTGluZWFyTGluZWFyXCJdID0gOTk4N10gPSBcIk1pcE1hcExpbmVhckxpbmVhclwiO1xuXHR9KShzcGluZS5UZXh0dXJlRmlsdGVyIHx8IChzcGluZS5UZXh0dXJlRmlsdGVyID0ge30pKTtcblx0dmFyIFRleHR1cmVGaWx0ZXIgPSBzcGluZS5UZXh0dXJlRmlsdGVyO1xuXHQoZnVuY3Rpb24gKFRleHR1cmVXcmFwKSB7XG5cdFx0VGV4dHVyZVdyYXBbVGV4dHVyZVdyYXBbXCJNaXJyb3JlZFJlcGVhdFwiXSA9IDMzNjQ4XSA9IFwiTWlycm9yZWRSZXBlYXRcIjtcblx0XHRUZXh0dXJlV3JhcFtUZXh0dXJlV3JhcFtcIkNsYW1wVG9FZGdlXCJdID0gMzMwNzFdID0gXCJDbGFtcFRvRWRnZVwiO1xuXHRcdFRleHR1cmVXcmFwW1RleHR1cmVXcmFwW1wiUmVwZWF0XCJdID0gMTA0OTddID0gXCJSZXBlYXRcIjtcblx0fSkoc3BpbmUuVGV4dHVyZVdyYXAgfHwgKHNwaW5lLlRleHR1cmVXcmFwID0ge30pKTtcblx0dmFyIFRleHR1cmVXcmFwID0gc3BpbmUuVGV4dHVyZVdyYXA7XG5cdHZhciBUZXh0dXJlUmVnaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUZXh0dXJlUmVnaW9uKCkge1xuXHRcdFx0dGhpcy51ID0gMDtcblx0XHRcdHRoaXMudiA9IDA7XG5cdFx0XHR0aGlzLnUyID0gMDtcblx0XHRcdHRoaXMudjIgPSAwO1xuXHRcdFx0dGhpcy53aWR0aCA9IDA7XG5cdFx0XHR0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLnJvdGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5vZmZzZXRYID0gMDtcblx0XHRcdHRoaXMub2Zmc2V0WSA9IDA7XG5cdFx0XHR0aGlzLm9yaWdpbmFsV2lkdGggPSAwO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEhlaWdodCA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiBUZXh0dXJlUmVnaW9uO1xuXHR9KCkpO1xuXHRzcGluZS5UZXh0dXJlUmVnaW9uID0gVGV4dHVyZVJlZ2lvbjtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBUZXh0dXJlQXRsYXMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFRleHR1cmVBdGxhcyhhdGxhc1RleHQsIHRleHR1cmVMb2FkZXIpIHtcblx0XHRcdHRoaXMucGFnZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMucmVnaW9ucyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5sb2FkKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlcik7XG5cdFx0fVxuXHRcdFRleHR1cmVBdGxhcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhdGxhc1RleHQsIHRleHR1cmVMb2FkZXIpIHtcblx0XHRcdGlmICh0ZXh0dXJlTG9hZGVyID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInRleHR1cmVMb2FkZXIgY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBUZXh0dXJlQXRsYXNSZWFkZXIoYXRsYXNUZXh0KTtcblx0XHRcdHZhciB0dXBsZSA9IG5ldyBBcnJheSg0KTtcblx0XHRcdHZhciBwYWdlID0gbnVsbDtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHZhciBsaW5lID0gcmVhZGVyLnJlYWRMaW5lKCk7XG5cdFx0XHRcdGlmIChsaW5lID09IG51bGwpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0aWYgKGxpbmUubGVuZ3RoID09IDApXG5cdFx0XHRcdFx0cGFnZSA9IG51bGw7XG5cdFx0XHRcdGVsc2UgaWYgKCFwYWdlKSB7XG5cdFx0XHRcdFx0cGFnZSA9IG5ldyBUZXh0dXJlQXRsYXNQYWdlKCk7XG5cdFx0XHRcdFx0cGFnZS5uYW1lID0gbGluZTtcblx0XHRcdFx0XHRpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gMikge1xuXHRcdFx0XHRcdFx0cGFnZS53aWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcblx0XHRcdFx0XHRcdHBhZ2UuaGVpZ2h0ID0gcGFyc2VJbnQodHVwbGVbMV0pO1xuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuXHRcdFx0XHRcdHBhZ2UubWluRmlsdGVyID0gc3BpbmUuVGV4dHVyZS5maWx0ZXJGcm9tU3RyaW5nKHR1cGxlWzBdKTtcblx0XHRcdFx0XHRwYWdlLm1hZ0ZpbHRlciA9IHNwaW5lLlRleHR1cmUuZmlsdGVyRnJvbVN0cmluZyh0dXBsZVsxXSk7XG5cdFx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IHJlYWRlci5yZWFkVmFsdWUoKTtcblx0XHRcdFx0XHRwYWdlLnVXcmFwID0gc3BpbmUuVGV4dHVyZVdyYXAuQ2xhbXBUb0VkZ2U7XG5cdFx0XHRcdFx0cGFnZS52V3JhcCA9IHNwaW5lLlRleHR1cmVXcmFwLkNsYW1wVG9FZGdlO1xuXHRcdFx0XHRcdGlmIChkaXJlY3Rpb24gPT0gXCJ4XCIpXG5cdFx0XHRcdFx0XHRwYWdlLnVXcmFwID0gc3BpbmUuVGV4dHVyZVdyYXAuUmVwZWF0O1xuXHRcdFx0XHRcdGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBcInlcIilcblx0XHRcdFx0XHRcdHBhZ2UudldyYXAgPSBzcGluZS5UZXh0dXJlV3JhcC5SZXBlYXQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieHlcIilcblx0XHRcdFx0XHRcdHBhZ2UudVdyYXAgPSBwYWdlLnZXcmFwID0gc3BpbmUuVGV4dHVyZVdyYXAuUmVwZWF0O1xuXHRcdFx0XHRcdHBhZ2UudGV4dHVyZSA9IHRleHR1cmVMb2FkZXIobGluZSk7XG5cdFx0XHRcdFx0cGFnZS50ZXh0dXJlLnNldEZpbHRlcnMocGFnZS5taW5GaWx0ZXIsIHBhZ2UubWFnRmlsdGVyKTtcblx0XHRcdFx0XHRwYWdlLnRleHR1cmUuc2V0V3JhcHMocGFnZS51V3JhcCwgcGFnZS52V3JhcCk7XG5cdFx0XHRcdFx0cGFnZS53aWR0aCA9IHBhZ2UudGV4dHVyZS5nZXRJbWFnZSgpLndpZHRoO1xuXHRcdFx0XHRcdHBhZ2UuaGVpZ2h0ID0gcGFnZS50ZXh0dXJlLmdldEltYWdlKCkuaGVpZ2h0O1xuXHRcdFx0XHRcdHRoaXMucGFnZXMucHVzaChwYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgcmVnaW9uID0gbmV3IFRleHR1cmVBdGxhc1JlZ2lvbigpO1xuXHRcdFx0XHRcdHJlZ2lvbi5uYW1lID0gbGluZTtcblx0XHRcdFx0XHRyZWdpb24ucGFnZSA9IHBhZ2U7XG5cdFx0XHRcdFx0cmVnaW9uLnJvdGF0ZSA9IHJlYWRlci5yZWFkVmFsdWUoKSA9PSBcInRydWVcIjtcblx0XHRcdFx0XHRyZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcblx0XHRcdFx0XHR2YXIgeCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcblx0XHRcdFx0XHR2YXIgeSA9IHBhcnNlSW50KHR1cGxlWzFdKTtcblx0XHRcdFx0XHRyZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBwYXJzZUludCh0dXBsZVswXSk7XG5cdFx0XHRcdFx0dmFyIGhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcblx0XHRcdFx0XHRyZWdpb24udSA9IHggLyBwYWdlLndpZHRoO1xuXHRcdFx0XHRcdHJlZ2lvbi52ID0geSAvIHBhZ2UuaGVpZ2h0O1xuXHRcdFx0XHRcdGlmIChyZWdpb24ucm90YXRlKSB7XG5cdFx0XHRcdFx0XHRyZWdpb24udTIgPSAoeCArIGhlaWdodCkgLyBwYWdlLndpZHRoO1xuXHRcdFx0XHRcdFx0cmVnaW9uLnYyID0gKHkgKyB3aWR0aCkgLyBwYWdlLmhlaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRyZWdpb24udTIgPSAoeCArIHdpZHRoKSAvIHBhZ2Uud2lkdGg7XG5cdFx0XHRcdFx0XHRyZWdpb24udjIgPSAoeSArIGhlaWdodCkgLyBwYWdlLmhlaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVnaW9uLnggPSB4O1xuXHRcdFx0XHRcdHJlZ2lvbi55ID0geTtcblx0XHRcdFx0XHRyZWdpb24ud2lkdGggPSBNYXRoLmFicyh3aWR0aCk7XG5cdFx0XHRcdFx0cmVnaW9uLmhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7XG5cdFx0XHRcdFx0aWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHtcblx0XHRcdFx0XHRcdGlmIChyZWFkZXIucmVhZFR1cGxlKHR1cGxlKSA9PSA0KSB7XG5cdFx0XHRcdFx0XHRcdHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZWdpb24ub3JpZ2luYWxXaWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcblx0XHRcdFx0XHRyZWdpb24ub3JpZ2luYWxIZWlnaHQgPSBwYXJzZUludCh0dXBsZVsxXSk7XG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG5cdFx0XHRcdFx0cmVnaW9uLm9mZnNldFggPSBwYXJzZUludCh0dXBsZVswXSk7XG5cdFx0XHRcdFx0cmVnaW9uLm9mZnNldFkgPSBwYXJzZUludCh0dXBsZVsxXSk7XG5cdFx0XHRcdFx0cmVnaW9uLmluZGV4ID0gcGFyc2VJbnQocmVhZGVyLnJlYWRWYWx1ZSgpKTtcblx0XHRcdFx0XHRyZWdpb24udGV4dHVyZSA9IHBhZ2UudGV4dHVyZTtcblx0XHRcdFx0XHR0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUZXh0dXJlQXRsYXMucHJvdG90eXBlLmZpbmRSZWdpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRoaXMucmVnaW9uc1tpXS5uYW1lID09IG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5yZWdpb25zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFRleHR1cmVBdGxhcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnBhZ2VzW2ldLnRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFRleHR1cmVBdGxhcztcblx0fSgpKTtcblx0c3BpbmUuVGV4dHVyZUF0bGFzID0gVGV4dHVyZUF0bGFzO1xuXHR2YXIgVGV4dHVyZUF0bGFzUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUZXh0dXJlQXRsYXNSZWFkZXIodGV4dCkge1xuXHRcdFx0dGhpcy5pbmRleCA9IDA7XG5cdFx0XHR0aGlzLmxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcblx0XHR9XG5cdFx0VGV4dHVyZUF0bGFzUmVhZGVyLnByb3RvdHlwZS5yZWFkTGluZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLmluZGV4ID49IHRoaXMubGluZXMubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiB0aGlzLmxpbmVzW3RoaXMuaW5kZXgrK107XG5cdFx0fTtcblx0XHRUZXh0dXJlQXRsYXNSZWFkZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuXHRcdFx0dmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcblx0XHRcdGlmIChjb2xvbiA9PSAtMSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmUpO1xuXHRcdFx0cmV0dXJuIGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSkudHJpbSgpO1xuXHRcdH07XG5cdFx0VGV4dHVyZUF0bGFzUmVhZGVyLnByb3RvdHlwZS5yZWFkVHVwbGUgPSBmdW5jdGlvbiAodHVwbGUpIHtcblx0XHRcdHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuXHRcdFx0dmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcblx0XHRcdGlmIChjb2xvbiA9PSAtMSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmUpO1xuXHRcdFx0dmFyIGkgPSAwLCBsYXN0TWF0Y2ggPSBjb2xvbiArIDE7XG5cdFx0XHRmb3IgKDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgY29tbWEgPSBsaW5lLmluZGV4T2YoXCIsXCIsIGxhc3RNYXRjaCk7XG5cdFx0XHRcdGlmIChjb21tYSA9PSAtMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0dHVwbGVbaV0gPSBsaW5lLnN1YnN0cihsYXN0TWF0Y2gsIGNvbW1hIC0gbGFzdE1hdGNoKS50cmltKCk7XG5cdFx0XHRcdGxhc3RNYXRjaCA9IGNvbW1hICsgMTtcblx0XHRcdH1cblx0XHRcdHR1cGxlW2ldID0gbGluZS5zdWJzdHJpbmcobGFzdE1hdGNoKS50cmltKCk7XG5cdFx0XHRyZXR1cm4gaSArIDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gVGV4dHVyZUF0bGFzUmVhZGVyO1xuXHR9KCkpO1xuXHR2YXIgVGV4dHVyZUF0bGFzUGFnZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVGV4dHVyZUF0bGFzUGFnZSgpIHtcblx0XHR9XG5cdFx0cmV0dXJuIFRleHR1cmVBdGxhc1BhZ2U7XG5cdH0oKSk7XG5cdHNwaW5lLlRleHR1cmVBdGxhc1BhZ2UgPSBUZXh0dXJlQXRsYXNQYWdlO1xuXHR2YXIgVGV4dHVyZUF0bGFzUmVnaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoVGV4dHVyZUF0bGFzUmVnaW9uLCBfc3VwZXIpO1xuXHRcdGZ1bmN0aW9uIFRleHR1cmVBdGxhc1JlZ2lvbigpIHtcblx0XHRcdF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gVGV4dHVyZUF0bGFzUmVnaW9uO1xuXHR9KHNwaW5lLlRleHR1cmVSZWdpb24pKTtcblx0c3BpbmUuVGV4dHVyZUF0bGFzUmVnaW9uID0gVGV4dHVyZUF0bGFzUmVnaW9uO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFRyYW5zZm9ybUNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFRyYW5zZm9ybUNvbnN0cmFpbnQoZGF0YSwgc2tlbGV0b24pIHtcblx0XHRcdHRoaXMucm90YXRlTWl4ID0gMDtcblx0XHRcdHRoaXMudHJhbnNsYXRlTWl4ID0gMDtcblx0XHRcdHRoaXMuc2NhbGVNaXggPSAwO1xuXHRcdFx0dGhpcy5zaGVhck1peCA9IDA7XG5cdFx0XHR0aGlzLnRlbXAgPSBuZXcgc3BpbmUuVmVjdG9yMigpO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHRpZiAoc2tlbGV0b24gPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xuXHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdHRoaXMucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XG5cdFx0XHR0aGlzLnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4O1xuXHRcdFx0dGhpcy5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXg7XG5cdFx0XHR0aGlzLnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peDtcblx0XHRcdHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ib25lcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0dGhpcy5ib25lcy5wdXNoKHNrZWxldG9uLmZpbmRCb25lKGRhdGEuYm9uZXNbaV0ubmFtZSkpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBza2VsZXRvbi5maW5kQm9uZShkYXRhLnRhcmdldC5uYW1lKTtcblx0XHR9XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuZGF0YS5sb2NhbCkge1xuXHRcdFx0XHRpZiAodGhpcy5kYXRhLnJlbGF0aXZlKVxuXHRcdFx0XHRcdHRoaXMuYXBwbHlSZWxhdGl2ZUxvY2FsKCk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLmFwcGx5QWJzb2x1dGVMb2NhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLmRhdGEucmVsYXRpdmUpXG5cdFx0XHRcdFx0dGhpcy5hcHBseVJlbGF0aXZlV29ybGQoKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRoaXMuYXBwbHlBYnNvbHV0ZVdvcmxkKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseUFic29sdXRlV29ybGQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblx0XHRcdHZhciB0YSA9IHRhcmdldC5hLCB0YiA9IHRhcmdldC5iLCB0YyA9IHRhcmdldC5jLCB0ZCA9IHRhcmdldC5kO1xuXHRcdFx0dmFyIGRlZ1JhZFJlZmxlY3QgPSB0YSAqIHRkIC0gdGIgKiB0YyA+IDAgPyBzcGluZS5NYXRoVXRpbHMuZGVnUmFkIDogLXNwaW5lLk1hdGhVdGlscy5kZWdSYWQ7XG5cdFx0XHR2YXIgb2Zmc2V0Um90YXRpb24gPSB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb24gKiBkZWdSYWRSZWZsZWN0O1xuXHRcdFx0dmFyIG9mZnNldFNoZWFyWSA9IHRoaXMuZGF0YS5vZmZzZXRTaGVhclkgKiBkZWdSYWRSZWZsZWN0O1xuXHRcdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdHZhciBtb2RpZmllZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAocm90YXRlTWl4ICE9IDApIHtcblx0XHRcdFx0XHR2YXIgYSA9IGJvbmUuYSwgYiA9IGJvbmUuYiwgYyA9IGJvbmUuYywgZCA9IGJvbmUuZDtcblx0XHRcdFx0XHR2YXIgciA9IE1hdGguYXRhbjIodGMsIHRhKSAtIE1hdGguYXRhbjIoYywgYSkgKyBvZmZzZXRSb3RhdGlvbjtcblx0XHRcdFx0XHRpZiAociA+IHNwaW5lLk1hdGhVdGlscy5QSSlcblx0XHRcdFx0XHRcdHIgLT0gc3BpbmUuTWF0aFV0aWxzLlBJMjtcblx0XHRcdFx0XHRlbHNlIGlmIChyIDwgLXNwaW5lLk1hdGhVdGlscy5QSSlcblx0XHRcdFx0XHRcdHIgKz0gc3BpbmUuTWF0aFV0aWxzLlBJMjtcblx0XHRcdFx0XHRyICo9IHJvdGF0ZU1peDtcblx0XHRcdFx0XHR2YXIgY29zID0gTWF0aC5jb3MociksIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdFx0XHRcdGJvbmUuYSA9IGNvcyAqIGEgLSBzaW4gKiBjO1xuXHRcdFx0XHRcdGJvbmUuYiA9IGNvcyAqIGIgLSBzaW4gKiBkO1xuXHRcdFx0XHRcdGJvbmUuYyA9IHNpbiAqIGEgKyBjb3MgKiBjO1xuXHRcdFx0XHRcdGJvbmUuZCA9IHNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcblx0XHRcdFx0XHR2YXIgdGVtcCA9IHRoaXMudGVtcDtcblx0XHRcdFx0XHR0YXJnZXQubG9jYWxUb1dvcmxkKHRlbXAuc2V0KHRoaXMuZGF0YS5vZmZzZXRYLCB0aGlzLmRhdGEub2Zmc2V0WSkpO1xuXHRcdFx0XHRcdGJvbmUud29ybGRYICs9ICh0ZW1wLnggLSBib25lLndvcmxkWCkgKiB0cmFuc2xhdGVNaXg7XG5cdFx0XHRcdFx0Ym9uZS53b3JsZFkgKz0gKHRlbXAueSAtIGJvbmUud29ybGRZKSAqIHRyYW5zbGF0ZU1peDtcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNjYWxlTWl4ID4gMCkge1xuXHRcdFx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KGJvbmUuYSAqIGJvbmUuYSArIGJvbmUuYyAqIGJvbmUuYyk7XG5cdFx0XHRcdFx0dmFyIHRzID0gTWF0aC5zcXJ0KHRhICogdGEgKyB0YyAqIHRjKTtcblx0XHRcdFx0XHRpZiAocyA+IDAuMDAwMDEpXG5cdFx0XHRcdFx0XHRzID0gKHMgKyAodHMgLSBzICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWCkgKiBzY2FsZU1peCkgLyBzO1xuXHRcdFx0XHRcdGJvbmUuYSAqPSBzO1xuXHRcdFx0XHRcdGJvbmUuYyAqPSBzO1xuXHRcdFx0XHRcdHMgPSBNYXRoLnNxcnQoYm9uZS5iICogYm9uZS5iICsgYm9uZS5kICogYm9uZS5kKTtcblx0XHRcdFx0XHR0cyA9IE1hdGguc3FydCh0YiAqIHRiICsgdGQgKiB0ZCk7XG5cdFx0XHRcdFx0aWYgKHMgPiAwLjAwMDAxKVxuXHRcdFx0XHRcdFx0cyA9IChzICsgKHRzIC0gcyArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVkpICogc2NhbGVNaXgpIC8gcztcblx0XHRcdFx0XHRib25lLmIgKj0gcztcblx0XHRcdFx0XHRib25lLmQgKj0gcztcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNoZWFyTWl4ID4gMCkge1xuXHRcdFx0XHRcdHZhciBiID0gYm9uZS5iLCBkID0gYm9uZS5kO1xuXHRcdFx0XHRcdHZhciBieSA9IE1hdGguYXRhbjIoZCwgYik7XG5cdFx0XHRcdFx0dmFyIHIgPSBNYXRoLmF0YW4yKHRkLCB0YikgLSBNYXRoLmF0YW4yKHRjLCB0YSkgLSAoYnkgLSBNYXRoLmF0YW4yKGJvbmUuYywgYm9uZS5hKSk7XG5cdFx0XHRcdFx0aWYgKHIgPiBzcGluZS5NYXRoVXRpbHMuUEkpXG5cdFx0XHRcdFx0XHRyIC09IHNwaW5lLk1hdGhVdGlscy5QSTI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAociA8IC1zcGluZS5NYXRoVXRpbHMuUEkpXG5cdFx0XHRcdFx0XHRyICs9IHNwaW5lLk1hdGhVdGlscy5QSTI7XG5cdFx0XHRcdFx0ciA9IGJ5ICsgKHIgKyBvZmZzZXRTaGVhclkpICogc2hlYXJNaXg7XG5cdFx0XHRcdFx0dmFyIHMgPSBNYXRoLnNxcnQoYiAqIGIgKyBkICogZCk7XG5cdFx0XHRcdFx0Ym9uZS5iID0gTWF0aC5jb3MocikgKiBzO1xuXHRcdFx0XHRcdGJvbmUuZCA9IE1hdGguc2luKHIpICogcztcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1vZGlmaWVkKVxuXHRcdFx0XHRcdGJvbmUuYXBwbGllZFZhbGlkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseVJlbGF0aXZlV29ybGQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblx0XHRcdHZhciB0YSA9IHRhcmdldC5hLCB0YiA9IHRhcmdldC5iLCB0YyA9IHRhcmdldC5jLCB0ZCA9IHRhcmdldC5kO1xuXHRcdFx0dmFyIGRlZ1JhZFJlZmxlY3QgPSB0YSAqIHRkIC0gdGIgKiB0YyA+IDAgPyBzcGluZS5NYXRoVXRpbHMuZGVnUmFkIDogLXNwaW5lLk1hdGhVdGlscy5kZWdSYWQ7XG5cdFx0XHR2YXIgb2Zmc2V0Um90YXRpb24gPSB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb24gKiBkZWdSYWRSZWZsZWN0LCBvZmZzZXRTaGVhclkgPSB0aGlzLmRhdGEub2Zmc2V0U2hlYXJZICogZGVnUmFkUmVmbGVjdDtcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgYm9uZSA9IGJvbmVzW2ldO1xuXHRcdFx0XHR2YXIgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHJvdGF0ZU1peCAhPSAwKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSBib25lLmEsIGIgPSBib25lLmIsIGMgPSBib25lLmMsIGQgPSBib25lLmQ7XG5cdFx0XHRcdFx0dmFyIHIgPSBNYXRoLmF0YW4yKHRjLCB0YSkgKyBvZmZzZXRSb3RhdGlvbjtcblx0XHRcdFx0XHRpZiAociA+IHNwaW5lLk1hdGhVdGlscy5QSSlcblx0XHRcdFx0XHRcdHIgLT0gc3BpbmUuTWF0aFV0aWxzLlBJMjtcblx0XHRcdFx0XHRlbHNlIGlmIChyIDwgLXNwaW5lLk1hdGhVdGlscy5QSSlcblx0XHRcdFx0XHRcdHIgKz0gc3BpbmUuTWF0aFV0aWxzLlBJMjtcblx0XHRcdFx0XHRyICo9IHJvdGF0ZU1peDtcblx0XHRcdFx0XHR2YXIgY29zID0gTWF0aC5jb3MociksIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdFx0XHRcdGJvbmUuYSA9IGNvcyAqIGEgLSBzaW4gKiBjO1xuXHRcdFx0XHRcdGJvbmUuYiA9IGNvcyAqIGIgLSBzaW4gKiBkO1xuXHRcdFx0XHRcdGJvbmUuYyA9IHNpbiAqIGEgKyBjb3MgKiBjO1xuXHRcdFx0XHRcdGJvbmUuZCA9IHNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcblx0XHRcdFx0XHR2YXIgdGVtcCA9IHRoaXMudGVtcDtcblx0XHRcdFx0XHR0YXJnZXQubG9jYWxUb1dvcmxkKHRlbXAuc2V0KHRoaXMuZGF0YS5vZmZzZXRYLCB0aGlzLmRhdGEub2Zmc2V0WSkpO1xuXHRcdFx0XHRcdGJvbmUud29ybGRYICs9IHRlbXAueCAqIHRyYW5zbGF0ZU1peDtcblx0XHRcdFx0XHRib25lLndvcmxkWSArPSB0ZW1wLnkgKiB0cmFuc2xhdGVNaXg7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzY2FsZU1peCA+IDApIHtcblx0XHRcdFx0XHR2YXIgcyA9IChNYXRoLnNxcnQodGEgKiB0YSArIHRjICogdGMpIC0gMSArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVgpICogc2NhbGVNaXggKyAxO1xuXHRcdFx0XHRcdGJvbmUuYSAqPSBzO1xuXHRcdFx0XHRcdGJvbmUuYyAqPSBzO1xuXHRcdFx0XHRcdHMgPSAoTWF0aC5zcXJ0KHRiICogdGIgKyB0ZCAqIHRkKSAtIDEgKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVZKSAqIHNjYWxlTWl4ICsgMTtcblx0XHRcdFx0XHRib25lLmIgKj0gcztcblx0XHRcdFx0XHRib25lLmQgKj0gcztcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNoZWFyTWl4ID4gMCkge1xuXHRcdFx0XHRcdHZhciByID0gTWF0aC5hdGFuMih0ZCwgdGIpIC0gTWF0aC5hdGFuMih0YywgdGEpO1xuXHRcdFx0XHRcdGlmIChyID4gc3BpbmUuTWF0aFV0aWxzLlBJKVxuXHRcdFx0XHRcdFx0ciAtPSBzcGluZS5NYXRoVXRpbHMuUEkyO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHIgPCAtc3BpbmUuTWF0aFV0aWxzLlBJKVxuXHRcdFx0XHRcdFx0ciArPSBzcGluZS5NYXRoVXRpbHMuUEkyO1xuXHRcdFx0XHRcdHZhciBiID0gYm9uZS5iLCBkID0gYm9uZS5kO1xuXHRcdFx0XHRcdHIgPSBNYXRoLmF0YW4yKGQsIGIpICsgKHIgLSBzcGluZS5NYXRoVXRpbHMuUEkgLyAyICsgb2Zmc2V0U2hlYXJZKSAqIHNoZWFyTWl4O1xuXHRcdFx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KGIgKiBiICsgZCAqIGQpO1xuXHRcdFx0XHRcdGJvbmUuYiA9IE1hdGguY29zKHIpICogcztcblx0XHRcdFx0XHRib25lLmQgPSBNYXRoLnNpbihyKSAqIHM7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtb2RpZmllZClcblx0XHRcdFx0XHRib25lLmFwcGxpZWRWYWxpZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHlBYnNvbHV0ZUxvY2FsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJvdGF0ZU1peCA9IHRoaXMucm90YXRlTWl4LCB0cmFuc2xhdGVNaXggPSB0aGlzLnRyYW5zbGF0ZU1peCwgc2NhbGVNaXggPSB0aGlzLnNjYWxlTWl4LCBzaGVhck1peCA9IHRoaXMuc2hlYXJNaXg7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cdFx0XHRpZiAoIXRhcmdldC5hcHBsaWVkVmFsaWQpXG5cdFx0XHRcdHRhcmdldC51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XG5cdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdFx0aWYgKCFib25lLmFwcGxpZWRWYWxpZClcblx0XHRcdFx0XHRib25lLnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gYm9uZS5hcm90YXRpb247XG5cdFx0XHRcdGlmIChyb3RhdGVNaXggIT0gMCkge1xuXHRcdFx0XHRcdHZhciByID0gdGFyZ2V0LmFyb3RhdGlvbiAtIHJvdGF0aW9uICsgdGhpcy5kYXRhLm9mZnNldFJvdGF0aW9uO1xuXHRcdFx0XHRcdHIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MDtcblx0XHRcdFx0XHRyb3RhdGlvbiArPSByICogcm90YXRlTWl4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB4ID0gYm9uZS5heCwgeSA9IGJvbmUuYXk7XG5cdFx0XHRcdGlmICh0cmFuc2xhdGVNaXggIT0gMCkge1xuXHRcdFx0XHRcdHggKz0gKHRhcmdldC5heCAtIHggKyB0aGlzLmRhdGEub2Zmc2V0WCkgKiB0cmFuc2xhdGVNaXg7XG5cdFx0XHRcdFx0eSArPSAodGFyZ2V0LmF5IC0geSArIHRoaXMuZGF0YS5vZmZzZXRZKSAqIHRyYW5zbGF0ZU1peDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc2NhbGVYID0gYm9uZS5hc2NhbGVYLCBzY2FsZVkgPSBib25lLmFzY2FsZVk7XG5cdFx0XHRcdGlmIChzY2FsZU1peCA+IDApIHtcblx0XHRcdFx0XHRpZiAoc2NhbGVYID4gMC4wMDAwMSlcblx0XHRcdFx0XHRcdHNjYWxlWCA9IChzY2FsZVggKyAodGFyZ2V0LmFzY2FsZVggLSBzY2FsZVggKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVYKSAqIHNjYWxlTWl4KSAvIHNjYWxlWDtcblx0XHRcdFx0XHRpZiAoc2NhbGVZID4gMC4wMDAwMSlcblx0XHRcdFx0XHRcdHNjYWxlWSA9IChzY2FsZVkgKyAodGFyZ2V0LmFzY2FsZVkgLSBzY2FsZVkgKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVZKSAqIHNjYWxlTWl4KSAvIHNjYWxlWTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc2hlYXJZID0gYm9uZS5hc2hlYXJZO1xuXHRcdFx0XHRpZiAoc2hlYXJNaXggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0YXJnZXQuYXNoZWFyWSAtIHNoZWFyWSArIHRoaXMuZGF0YS5vZmZzZXRTaGVhclk7XG5cdFx0XHRcdFx0ciAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIgLyAzNjApIHwgMCkpICogMzYwO1xuXHRcdFx0XHRcdGJvbmUuc2hlYXJZICs9IHIgKiBzaGVhck1peDtcblx0XHRcdFx0fVxuXHRcdFx0XHRib25lLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVksIGJvbmUuYXNoZWFyWCwgc2hlYXJZKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5UmVsYXRpdmVMb2NhbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXgsIHNjYWxlTWl4ID0gdGhpcy5zY2FsZU1peCwgc2hlYXJNaXggPSB0aGlzLnNoZWFyTWl4O1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXHRcdFx0aWYgKCF0YXJnZXQuYXBwbGllZFZhbGlkKVxuXHRcdFx0XHR0YXJnZXQudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xuXHRcdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdGlmICghYm9uZS5hcHBsaWVkVmFsaWQpXG5cdFx0XHRcdFx0Ym9uZS51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IGJvbmUuYXJvdGF0aW9uO1xuXHRcdFx0XHRpZiAocm90YXRlTWl4ICE9IDApXG5cdFx0XHRcdFx0cm90YXRpb24gKz0gKHRhcmdldC5hcm90YXRpb24gKyB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb24pICogcm90YXRlTWl4O1xuXHRcdFx0XHR2YXIgeCA9IGJvbmUuYXgsIHkgPSBib25lLmF5O1xuXHRcdFx0XHRpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcblx0XHRcdFx0XHR4ICs9ICh0YXJnZXQuYXggKyB0aGlzLmRhdGEub2Zmc2V0WCkgKiB0cmFuc2xhdGVNaXg7XG5cdFx0XHRcdFx0eSArPSAodGFyZ2V0LmF5ICsgdGhpcy5kYXRhLm9mZnNldFkpICogdHJhbnNsYXRlTWl4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzY2FsZVggPSBib25lLmFzY2FsZVgsIHNjYWxlWSA9IGJvbmUuYXNjYWxlWTtcblx0XHRcdFx0aWYgKHNjYWxlTWl4ID4gMCkge1xuXHRcdFx0XHRcdGlmIChzY2FsZVggPiAwLjAwMDAxKVxuXHRcdFx0XHRcdFx0c2NhbGVYICo9ICgodGFyZ2V0LmFzY2FsZVggLSAxICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWCkgKiBzY2FsZU1peCkgKyAxO1xuXHRcdFx0XHRcdGlmIChzY2FsZVkgPiAwLjAwMDAxKVxuXHRcdFx0XHRcdFx0c2NhbGVZICo9ICgodGFyZ2V0LmFzY2FsZVkgLSAxICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWSkgKiBzY2FsZU1peCkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzaGVhclkgPSBib25lLmFzaGVhclk7XG5cdFx0XHRcdGlmIChzaGVhck1peCA+IDApXG5cdFx0XHRcdFx0c2hlYXJZICs9ICh0YXJnZXQuYXNoZWFyWSArIHRoaXMuZGF0YS5vZmZzZXRTaGVhclkpICogc2hlYXJNaXg7XG5cdFx0XHRcdGJvbmUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHgsIHksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSwgYm9uZS5hc2hlYXJYLCBzaGVhclkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0T3JkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLm9yZGVyO1xuXHRcdH07XG5cdFx0cmV0dXJuIFRyYW5zZm9ybUNvbnN0cmFpbnQ7XG5cdH0oKSk7XG5cdHNwaW5lLlRyYW5zZm9ybUNvbnN0cmFpbnQgPSBUcmFuc2Zvcm1Db25zdHJhaW50O1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFRyYW5zZm9ybUNvbnN0cmFpbnREYXRhID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUcmFuc2Zvcm1Db25zdHJhaW50RGF0YShuYW1lKSB7XG5cdFx0XHR0aGlzLm9yZGVyID0gMDtcblx0XHRcdHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMucm90YXRlTWl4ID0gMDtcblx0XHRcdHRoaXMudHJhbnNsYXRlTWl4ID0gMDtcblx0XHRcdHRoaXMuc2NhbGVNaXggPSAwO1xuXHRcdFx0dGhpcy5zaGVhck1peCA9IDA7XG5cdFx0XHR0aGlzLm9mZnNldFJvdGF0aW9uID0gMDtcblx0XHRcdHRoaXMub2Zmc2V0WCA9IDA7XG5cdFx0XHR0aGlzLm9mZnNldFkgPSAwO1xuXHRcdFx0dGhpcy5vZmZzZXRTY2FsZVggPSAwO1xuXHRcdFx0dGhpcy5vZmZzZXRTY2FsZVkgPSAwO1xuXHRcdFx0dGhpcy5vZmZzZXRTaGVhclkgPSAwO1xuXHRcdFx0dGhpcy5yZWxhdGl2ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5sb2NhbCA9IGZhbHNlO1xuXHRcdFx0aWYgKG5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdH1cblx0XHRyZXR1cm4gVHJhbnNmb3JtQ29uc3RyYWludERhdGE7XG5cdH0oKSk7XG5cdHNwaW5lLlRyYW5zZm9ybUNvbnN0cmFpbnREYXRhID0gVHJhbnNmb3JtQ29uc3RyYWludERhdGE7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgVHJpYW5ndWxhdG9yID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUcmlhbmd1bGF0b3IoKSB7XG5cdFx0XHR0aGlzLmNvbnZleFBvbHlnb25zID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmNvbnZleFBvbHlnb25zSW5kaWNlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dGhpcy5pbmRpY2VzQXJyYXkgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuaXNDb25jYXZlQXJyYXkgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMudHJpYW5nbGVzID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLnBvbHlnb25Qb29sID0gbmV3IHNwaW5lLlBvb2woZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFycmF5KCk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMucG9seWdvbkluZGljZXNQb29sID0gbmV3IHNwaW5lLlBvb2woZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFycmF5KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0VHJpYW5ndWxhdG9yLnByb3RvdHlwZS50cmlhbmd1bGF0ZSA9IGZ1bmN0aW9uICh2ZXJ0aWNlc0FycmF5KSB7XG5cdFx0XHR2YXIgdmVydGljZXMgPSB2ZXJ0aWNlc0FycmF5O1xuXHRcdFx0dmFyIHZlcnRleENvdW50ID0gdmVydGljZXNBcnJheS5sZW5ndGggPj4gMTtcblx0XHRcdHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzQXJyYXk7XG5cdFx0XHRpbmRpY2VzLmxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXG5cdFx0XHRcdGluZGljZXNbaV0gPSBpO1xuXHRcdFx0dmFyIGlzQ29uY2F2ZSA9IHRoaXMuaXNDb25jYXZlQXJyYXk7XG5cdFx0XHRpc0NvbmNhdmUubGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdmVydGV4Q291bnQ7IGkgPCBuOyArK2kpXG5cdFx0XHRcdGlzQ29uY2F2ZVtpXSA9IFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUoaSwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcblx0XHRcdHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcztcblx0XHRcdHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuXHRcdFx0d2hpbGUgKHZlcnRleENvdW50ID4gMykge1xuXHRcdFx0XHR2YXIgcHJldmlvdXMgPSB2ZXJ0ZXhDb3VudCAtIDEsIGkgPSAwLCBuZXh0ID0gMTtcblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHRvdXRlcjogaWYgKCFpc0NvbmNhdmVbaV0pIHtcblx0XHRcdFx0XHRcdHZhciBwMSA9IGluZGljZXNbcHJldmlvdXNdIDw8IDEsIHAyID0gaW5kaWNlc1tpXSA8PCAxLCBwMyA9IGluZGljZXNbbmV4dF0gPDwgMTtcblx0XHRcdFx0XHRcdHZhciBwMXggPSB2ZXJ0aWNlc1twMV0sIHAxeSA9IHZlcnRpY2VzW3AxICsgMV07XG5cdFx0XHRcdFx0XHR2YXIgcDJ4ID0gdmVydGljZXNbcDJdLCBwMnkgPSB2ZXJ0aWNlc1twMiArIDFdO1xuXHRcdFx0XHRcdFx0dmFyIHAzeCA9IHZlcnRpY2VzW3AzXSwgcDN5ID0gdmVydGljZXNbcDMgKyAxXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gKG5leHQgKyAxKSAlIHZlcnRleENvdW50OyBpaSAhPSBwcmV2aW91czsgaWkgPSAoaWkgKyAxKSAlIHZlcnRleENvdW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmICghaXNDb25jYXZlW2lpXSlcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0dmFyIHYgPSBpbmRpY2VzW2lpXSA8PCAxO1xuXHRcdFx0XHRcdFx0XHR2YXIgdnggPSB2ZXJ0aWNlc1t2XSwgdnkgPSB2ZXJ0aWNlc1t2ICsgMV07XG5cdFx0XHRcdFx0XHRcdGlmIChUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhKHAzeCwgcDN5LCBwMXgsIHAxeSwgdngsIHZ5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhKHAxeCwgcDF5LCBwMngsIHAyeSwgdngsIHZ5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFRyaWFuZ3VsYXRvci5wb3NpdGl2ZUFyZWEocDJ4LCBwMnksIHAzeCwgcDN5LCB2eCwgdnkpKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmV4dCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdGlmICghaXNDb25jYXZlW2ldKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0XHR9IHdoaWxlIChpID4gMCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBpO1xuXHRcdFx0XHRcdGkgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQgPSAobmV4dCArIDEpICUgdmVydGV4Q291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goaW5kaWNlc1sodmVydGV4Q291bnQgKyBpIC0gMSkgJSB2ZXJ0ZXhDb3VudF0pO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChpbmRpY2VzW2ldKTtcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goaW5kaWNlc1soaSArIDEpICUgdmVydGV4Q291bnRdKTtcblx0XHRcdFx0aW5kaWNlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGlzQ29uY2F2ZS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdHZlcnRleENvdW50LS07XG5cdFx0XHRcdHZhciBwcmV2aW91c0luZGV4ID0gKHZlcnRleENvdW50ICsgaSAtIDEpICUgdmVydGV4Q291bnQ7XG5cdFx0XHRcdHZhciBuZXh0SW5kZXggPSBpID09IHZlcnRleENvdW50ID8gMCA6IGk7XG5cdFx0XHRcdGlzQ29uY2F2ZVtwcmV2aW91c0luZGV4XSA9IFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUocHJldmlvdXNJbmRleCwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcblx0XHRcdFx0aXNDb25jYXZlW25leHRJbmRleF0gPSBUcmlhbmd1bGF0b3IuaXNDb25jYXZlKG5leHRJbmRleCwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcblx0XHRcdH1cblx0XHRcdGlmICh2ZXJ0ZXhDb3VudCA9PSAzKSB7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKGluZGljZXNbMl0pO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChpbmRpY2VzWzBdKTtcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goaW5kaWNlc1sxXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJpYW5nbGVzO1xuXHRcdH07XG5cdFx0VHJpYW5ndWxhdG9yLnByb3RvdHlwZS5kZWNvbXBvc2UgPSBmdW5jdGlvbiAodmVydGljZXNBcnJheSwgdHJpYW5nbGVzKSB7XG5cdFx0XHR2YXIgdmVydGljZXMgPSB2ZXJ0aWNlc0FycmF5O1xuXHRcdFx0dmFyIGNvbnZleFBvbHlnb25zID0gdGhpcy5jb252ZXhQb2x5Z29ucztcblx0XHRcdHRoaXMucG9seWdvblBvb2wuZnJlZUFsbChjb252ZXhQb2x5Z29ucyk7XG5cdFx0XHRjb252ZXhQb2x5Z29ucy5sZW5ndGggPSAwO1xuXHRcdFx0dmFyIGNvbnZleFBvbHlnb25zSW5kaWNlcyA9IHRoaXMuY29udmV4UG9seWdvbnNJbmRpY2VzO1xuXHRcdFx0dGhpcy5wb2x5Z29uSW5kaWNlc1Bvb2wuZnJlZUFsbChjb252ZXhQb2x5Z29uc0luZGljZXMpO1xuXHRcdFx0Y29udmV4UG9seWdvbnNJbmRpY2VzLmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgcG9seWdvbkluZGljZXMgPSB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5vYnRhaW4oKTtcblx0XHRcdHBvbHlnb25JbmRpY2VzLmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgcG9seWdvbiA9IHRoaXMucG9seWdvblBvb2wub2J0YWluKCk7XG5cdFx0XHRwb2x5Z29uLmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgZmFuQmFzZUluZGV4ID0gLTEsIGxhc3RXaW5kaW5nID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IG47IGkgKz0gMykge1xuXHRcdFx0XHR2YXIgdDEgPSB0cmlhbmdsZXNbaV0gPDwgMSwgdDIgPSB0cmlhbmdsZXNbaSArIDFdIDw8IDEsIHQzID0gdHJpYW5nbGVzW2kgKyAyXSA8PCAxO1xuXHRcdFx0XHR2YXIgeDEgPSB2ZXJ0aWNlc1t0MV0sIHkxID0gdmVydGljZXNbdDEgKyAxXTtcblx0XHRcdFx0dmFyIHgyID0gdmVydGljZXNbdDJdLCB5MiA9IHZlcnRpY2VzW3QyICsgMV07XG5cdFx0XHRcdHZhciB4MyA9IHZlcnRpY2VzW3QzXSwgeTMgPSB2ZXJ0aWNlc1t0MyArIDFdO1xuXHRcdFx0XHR2YXIgbWVyZ2VkID0gZmFsc2U7XG5cdFx0XHRcdGlmIChmYW5CYXNlSW5kZXggPT0gdDEpIHtcblx0XHRcdFx0XHR2YXIgbyA9IHBvbHlnb24ubGVuZ3RoIC0gNDtcblx0XHRcdFx0XHR2YXIgd2luZGluZzEgPSBUcmlhbmd1bGF0b3Iud2luZGluZyhwb2x5Z29uW29dLCBwb2x5Z29uW28gKyAxXSwgcG9seWdvbltvICsgMl0sIHBvbHlnb25bbyArIDNdLCB4MywgeTMpO1xuXHRcdFx0XHRcdHZhciB3aW5kaW5nMiA9IFRyaWFuZ3VsYXRvci53aW5kaW5nKHgzLCB5MywgcG9seWdvblswXSwgcG9seWdvblsxXSwgcG9seWdvblsyXSwgcG9seWdvblszXSk7XG5cdFx0XHRcdFx0aWYgKHdpbmRpbmcxID09IGxhc3RXaW5kaW5nICYmIHdpbmRpbmcyID09IGxhc3RXaW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRwb2x5Z29uLnB1c2goeDMpO1xuXHRcdFx0XHRcdFx0cG9seWdvbi5wdXNoKHkzKTtcblx0XHRcdFx0XHRcdHBvbHlnb25JbmRpY2VzLnB1c2godDMpO1xuXHRcdFx0XHRcdFx0bWVyZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFtZXJnZWQpIHtcblx0XHRcdFx0XHRpZiAocG9seWdvbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb252ZXhQb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuXHRcdFx0XHRcdFx0Y29udmV4UG9seWdvbnNJbmRpY2VzLnB1c2gocG9seWdvbkluZGljZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucG9seWdvblBvb2wuZnJlZShwb2x5Z29uKTtcblx0XHRcdFx0XHRcdHRoaXMucG9seWdvbkluZGljZXNQb29sLmZyZWUocG9seWdvbkluZGljZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb2x5Z29uID0gdGhpcy5wb2x5Z29uUG9vbC5vYnRhaW4oKTtcblx0XHRcdFx0XHRwb2x5Z29uLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0cG9seWdvbi5wdXNoKHgxKTtcblx0XHRcdFx0XHRwb2x5Z29uLnB1c2goeTEpO1xuXHRcdFx0XHRcdHBvbHlnb24ucHVzaCh4Mik7XG5cdFx0XHRcdFx0cG9seWdvbi5wdXNoKHkyKTtcblx0XHRcdFx0XHRwb2x5Z29uLnB1c2goeDMpO1xuXHRcdFx0XHRcdHBvbHlnb24ucHVzaCh5Myk7XG5cdFx0XHRcdFx0cG9seWdvbkluZGljZXMgPSB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5vYnRhaW4oKTtcblx0XHRcdFx0XHRwb2x5Z29uSW5kaWNlcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdHBvbHlnb25JbmRpY2VzLnB1c2godDEpO1xuXHRcdFx0XHRcdHBvbHlnb25JbmRpY2VzLnB1c2godDIpO1xuXHRcdFx0XHRcdHBvbHlnb25JbmRpY2VzLnB1c2godDMpO1xuXHRcdFx0XHRcdGxhc3RXaW5kaW5nID0gVHJpYW5ndWxhdG9yLndpbmRpbmcoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG5cdFx0XHRcdFx0ZmFuQmFzZUluZGV4ID0gdDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwb2x5Z29uLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29udmV4UG9seWdvbnMucHVzaChwb2x5Z29uKTtcblx0XHRcdFx0Y29udmV4UG9seWdvbnNJbmRpY2VzLnB1c2gocG9seWdvbkluZGljZXMpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBjb252ZXhQb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0cG9seWdvbkluZGljZXMgPSBjb252ZXhQb2x5Z29uc0luZGljZXNbaV07XG5cdFx0XHRcdGlmIChwb2x5Z29uSW5kaWNlcy5sZW5ndGggPT0gMClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIGZpcnN0SW5kZXggPSBwb2x5Z29uSW5kaWNlc1swXTtcblx0XHRcdFx0dmFyIGxhc3RJbmRleCA9IHBvbHlnb25JbmRpY2VzW3BvbHlnb25JbmRpY2VzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRwb2x5Z29uID0gY29udmV4UG9seWdvbnNbaV07XG5cdFx0XHRcdHZhciBvID0gcG9seWdvbi5sZW5ndGggLSA0O1xuXHRcdFx0XHR2YXIgcHJldlByZXZYID0gcG9seWdvbltvXSwgcHJldlByZXZZID0gcG9seWdvbltvICsgMV07XG5cdFx0XHRcdHZhciBwcmV2WCA9IHBvbHlnb25bbyArIDJdLCBwcmV2WSA9IHBvbHlnb25bbyArIDNdO1xuXHRcdFx0XHR2YXIgZmlyc3RYID0gcG9seWdvblswXSwgZmlyc3RZID0gcG9seWdvblsxXTtcblx0XHRcdFx0dmFyIHNlY29uZFggPSBwb2x5Z29uWzJdLCBzZWNvbmRZID0gcG9seWdvblszXTtcblx0XHRcdFx0dmFyIHdpbmRpbmcgPSBUcmlhbmd1bGF0b3Iud2luZGluZyhwcmV2UHJldlgsIHByZXZQcmV2WSwgcHJldlgsIHByZXZZLCBmaXJzdFgsIGZpcnN0WSk7XG5cdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBuOyBpaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGlpID09IGkpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR2YXIgb3RoZXJJbmRpY2VzID0gY29udmV4UG9seWdvbnNJbmRpY2VzW2lpXTtcblx0XHRcdFx0XHRpZiAob3RoZXJJbmRpY2VzLmxlbmd0aCAhPSAzKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0dmFyIG90aGVyRmlyc3RJbmRleCA9IG90aGVySW5kaWNlc1swXTtcblx0XHRcdFx0XHR2YXIgb3RoZXJTZWNvbmRJbmRleCA9IG90aGVySW5kaWNlc1sxXTtcblx0XHRcdFx0XHR2YXIgb3RoZXJMYXN0SW5kZXggPSBvdGhlckluZGljZXNbMl07XG5cdFx0XHRcdFx0dmFyIG90aGVyUG9seSA9IGNvbnZleFBvbHlnb25zW2lpXTtcblx0XHRcdFx0XHR2YXIgeDMgPSBvdGhlclBvbHlbb3RoZXJQb2x5Lmxlbmd0aCAtIDJdLCB5MyA9IG90aGVyUG9seVtvdGhlclBvbHkubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0aWYgKG90aGVyRmlyc3RJbmRleCAhPSBmaXJzdEluZGV4IHx8IG90aGVyU2Vjb25kSW5kZXggIT0gbGFzdEluZGV4KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0dmFyIHdpbmRpbmcxID0gVHJpYW5ndWxhdG9yLndpbmRpbmcocHJldlByZXZYLCBwcmV2UHJldlksIHByZXZYLCBwcmV2WSwgeDMsIHkzKTtcblx0XHRcdFx0XHR2YXIgd2luZGluZzIgPSBUcmlhbmd1bGF0b3Iud2luZGluZyh4MywgeTMsIGZpcnN0WCwgZmlyc3RZLCBzZWNvbmRYLCBzZWNvbmRZKTtcblx0XHRcdFx0XHRpZiAod2luZGluZzEgPT0gd2luZGluZyAmJiB3aW5kaW5nMiA9PSB3aW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRvdGhlclBvbHkubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRcdG90aGVySW5kaWNlcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0cG9seWdvbi5wdXNoKHgzKTtcblx0XHRcdFx0XHRcdHBvbHlnb24ucHVzaCh5Myk7XG5cdFx0XHRcdFx0XHRwb2x5Z29uSW5kaWNlcy5wdXNoKG90aGVyTGFzdEluZGV4KTtcblx0XHRcdFx0XHRcdHByZXZQcmV2WCA9IHByZXZYO1xuXHRcdFx0XHRcdFx0cHJldlByZXZZID0gcHJldlk7XG5cdFx0XHRcdFx0XHRwcmV2WCA9IHgzO1xuXHRcdFx0XHRcdFx0cHJldlkgPSB5Mztcblx0XHRcdFx0XHRcdGlpID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBjb252ZXhQb2x5Z29ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRwb2x5Z29uID0gY29udmV4UG9seWdvbnNbaV07XG5cdFx0XHRcdGlmIChwb2x5Z29uLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0Y29udmV4UG9seWdvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHRoaXMucG9seWdvblBvb2wuZnJlZShwb2x5Z29uKTtcblx0XHRcdFx0XHRwb2x5Z29uSW5kaWNlcyA9IGNvbnZleFBvbHlnb25zSW5kaWNlc1tpXTtcblx0XHRcdFx0XHRjb252ZXhQb2x5Z29uc0luZGljZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHRoaXMucG9seWdvbkluZGljZXNQb29sLmZyZWUocG9seWdvbkluZGljZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udmV4UG9seWdvbnM7XG5cdFx0fTtcblx0XHRUcmlhbmd1bGF0b3IuaXNDb25jYXZlID0gZnVuY3Rpb24gKGluZGV4LCB2ZXJ0ZXhDb3VudCwgdmVydGljZXMsIGluZGljZXMpIHtcblx0XHRcdHZhciBwcmV2aW91cyA9IGluZGljZXNbKHZlcnRleENvdW50ICsgaW5kZXggLSAxKSAlIHZlcnRleENvdW50XSA8PCAxO1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBpbmRpY2VzW2luZGV4XSA8PCAxO1xuXHRcdFx0dmFyIG5leHQgPSBpbmRpY2VzWyhpbmRleCArIDEpICUgdmVydGV4Q291bnRdIDw8IDE7XG5cdFx0XHRyZXR1cm4gIXRoaXMucG9zaXRpdmVBcmVhKHZlcnRpY2VzW3ByZXZpb3VzXSwgdmVydGljZXNbcHJldmlvdXMgKyAxXSwgdmVydGljZXNbY3VycmVudF0sIHZlcnRpY2VzW2N1cnJlbnQgKyAxXSwgdmVydGljZXNbbmV4dF0sIHZlcnRpY2VzW25leHQgKyAxXSk7XG5cdFx0fTtcblx0XHRUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcblx0XHRcdHJldHVybiBwMXggKiAocDN5IC0gcDJ5KSArIHAyeCAqIChwMXkgLSBwM3kpICsgcDN4ICogKHAyeSAtIHAxeSkgPj0gMDtcblx0XHR9O1xuXHRcdFRyaWFuZ3VsYXRvci53aW5kaW5nID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcblx0XHRcdHZhciBweCA9IHAyeCAtIHAxeCwgcHkgPSBwMnkgLSBwMXk7XG5cdFx0XHRyZXR1cm4gcDN4ICogcHkgLSBwM3kgKiBweCArIHB4ICogcDF5IC0gcDF4ICogcHkgPj0gMCA/IDEgOiAtMTtcblx0XHR9O1xuXHRcdHJldHVybiBUcmlhbmd1bGF0b3I7XG5cdH0oKSk7XG5cdHNwaW5lLlRyaWFuZ3VsYXRvciA9IFRyaWFuZ3VsYXRvcjtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciBJbnRTZXQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIEludFNldCgpIHtcblx0XHRcdHRoaXMuYXJyYXkgPSBuZXcgQXJyYXkoKTtcblx0XHR9XG5cdFx0SW50U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHZhciBjb250YWlucyA9IHRoaXMuY29udGFpbnModmFsdWUpO1xuXHRcdFx0dGhpcy5hcnJheVt2YWx1ZSB8IDBdID0gdmFsdWUgfCAwO1xuXHRcdFx0cmV0dXJuICFjb250YWlucztcblx0XHR9O1xuXHRcdEludFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFycmF5W3ZhbHVlIHwgMF0gIT0gdW5kZWZpbmVkO1xuXHRcdH07XG5cdFx0SW50U2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHRoaXMuYXJyYXlbdmFsdWUgfCAwXSA9IHVuZGVmaW5lZDtcblx0XHR9O1xuXHRcdEludFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmFycmF5Lmxlbmd0aCA9IDA7XG5cdFx0fTtcblx0XHRyZXR1cm4gSW50U2V0O1xuXHR9KCkpO1xuXHRzcGluZS5JbnRTZXQgPSBJbnRTZXQ7XG5cdHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gQ29sb3IociwgZywgYiwgYSkge1xuXHRcdFx0aWYgKHIgPT09IHZvaWQgMCkgeyByID0gMDsgfVxuXHRcdFx0aWYgKGcgPT09IHZvaWQgMCkgeyBnID0gMDsgfVxuXHRcdFx0aWYgKGIgPT09IHZvaWQgMCkgeyBiID0gMDsgfVxuXHRcdFx0aWYgKGEgPT09IHZvaWQgMCkgeyBhID0gMDsgfVxuXHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdHRoaXMuZyA9IGc7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0dGhpcy5hID0gYTtcblx0XHR9XG5cdFx0Q29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XG5cdFx0XHR0aGlzLnIgPSByO1xuXHRcdFx0dGhpcy5nID0gZztcblx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHR0aGlzLmEgPSBhO1xuXHRcdFx0dGhpcy5jbGFtcCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRDb2xvci5wcm90b3R5cGUuc2V0RnJvbUNvbG9yID0gZnVuY3Rpb24gKGMpIHtcblx0XHRcdHRoaXMuciA9IGMucjtcblx0XHRcdHRoaXMuZyA9IGMuZztcblx0XHRcdHRoaXMuYiA9IGMuYjtcblx0XHRcdHRoaXMuYSA9IGMuYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0Q29sb3IucHJvdG90eXBlLnNldEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoaGV4KSB7XG5cdFx0XHRoZXggPSBoZXguY2hhckF0KDApID09ICcjJyA/IGhleC5zdWJzdHIoMSkgOiBoZXg7XG5cdFx0XHR0aGlzLnIgPSBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNikgLyAyNTUuMDtcblx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoMiwgMiksIDE2KSAvIDI1NS4wO1xuXHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoaGV4LnN1YnN0cig0LCAyKSwgMTYpIC8gMjU1LjA7XG5cdFx0XHR0aGlzLmEgPSAoaGV4Lmxlbmd0aCAhPSA4ID8gMjU1IDogcGFyc2VJbnQoaGV4LnN1YnN0cig2LCAyKSwgMTYpKSAvIDI1NS4wO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRDb2xvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcblx0XHRcdHRoaXMuciArPSByO1xuXHRcdFx0dGhpcy5nICs9IGc7XG5cdFx0XHR0aGlzLmIgKz0gYjtcblx0XHRcdHRoaXMuYSArPSBhO1xuXHRcdFx0dGhpcy5jbGFtcCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRDb2xvci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5yIDwgMClcblx0XHRcdFx0dGhpcy5yID0gMDtcblx0XHRcdGVsc2UgaWYgKHRoaXMuciA+IDEpXG5cdFx0XHRcdHRoaXMuciA9IDE7XG5cdFx0XHRpZiAodGhpcy5nIDwgMClcblx0XHRcdFx0dGhpcy5nID0gMDtcblx0XHRcdGVsc2UgaWYgKHRoaXMuZyA+IDEpXG5cdFx0XHRcdHRoaXMuZyA9IDE7XG5cdFx0XHRpZiAodGhpcy5iIDwgMClcblx0XHRcdFx0dGhpcy5iID0gMDtcblx0XHRcdGVsc2UgaWYgKHRoaXMuYiA+IDEpXG5cdFx0XHRcdHRoaXMuYiA9IDE7XG5cdFx0XHRpZiAodGhpcy5hIDwgMClcblx0XHRcdFx0dGhpcy5hID0gMDtcblx0XHRcdGVsc2UgaWYgKHRoaXMuYSA+IDEpXG5cdFx0XHRcdHRoaXMuYSA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdENvbG9yLldISVRFID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpO1xuXHRcdENvbG9yLlJFRCA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTtcblx0XHRDb2xvci5HUkVFTiA9IG5ldyBDb2xvcigwLCAxLCAwLCAxKTtcblx0XHRDb2xvci5CTFVFID0gbmV3IENvbG9yKDAsIDAsIDEsIDEpO1xuXHRcdENvbG9yLk1BR0VOVEEgPSBuZXcgQ29sb3IoMSwgMCwgMSwgMSk7XG5cdFx0cmV0dXJuIENvbG9yO1xuXHR9KCkpO1xuXHRzcGluZS5Db2xvciA9IENvbG9yO1xuXHR2YXIgTWF0aFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBNYXRoVXRpbHMoKSB7XG5cdFx0fVxuXHRcdE1hdGhVdGlscy5jbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcblx0XHRcdGlmICh2YWx1ZSA8IG1pbilcblx0XHRcdFx0cmV0dXJuIG1pbjtcblx0XHRcdGlmICh2YWx1ZSA+IG1heClcblx0XHRcdFx0cmV0dXJuIG1heDtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHRcdE1hdGhVdGlscy5jb3NEZWcgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdFx0cmV0dXJuIE1hdGguY29zKGRlZ3JlZXMgKiBNYXRoVXRpbHMuZGVnUmFkKTtcblx0XHR9O1xuXHRcdE1hdGhVdGlscy5zaW5EZWcgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdFx0cmV0dXJuIE1hdGguc2luKGRlZ3JlZXMgKiBNYXRoVXRpbHMuZGVnUmFkKTtcblx0XHR9O1xuXHRcdE1hdGhVdGlscy5zaWdudW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHJldHVybiB2YWx1ZSA+IDAgPyAxIDogdmFsdWUgPCAwID8gLTEgOiAwO1xuXHRcdH07XG5cdFx0TWF0aFV0aWxzLnRvSW50ID0gZnVuY3Rpb24gKHgpIHtcblx0XHRcdHJldHVybiB4ID4gMCA/IE1hdGguZmxvb3IoeCkgOiBNYXRoLmNlaWwoeCk7XG5cdFx0fTtcblx0XHRNYXRoVXRpbHMuY2JydCA9IGZ1bmN0aW9uICh4KSB7XG5cdFx0XHR2YXIgeSA9IE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG5cdFx0XHRyZXR1cm4geCA8IDAgPyAteSA6IHk7XG5cdFx0fTtcblx0XHRNYXRoVXRpbHMuUEkgPSAzLjE0MTU5Mjc7XG5cdFx0TWF0aFV0aWxzLlBJMiA9IE1hdGhVdGlscy5QSSAqIDI7XG5cdFx0TWF0aFV0aWxzLnJhZGlhbnNUb0RlZ3JlZXMgPSAxODAgLyBNYXRoVXRpbHMuUEk7XG5cdFx0TWF0aFV0aWxzLnJhZERlZyA9IE1hdGhVdGlscy5yYWRpYW5zVG9EZWdyZWVzO1xuXHRcdE1hdGhVdGlscy5kZWdyZWVzVG9SYWRpYW5zID0gTWF0aFV0aWxzLlBJIC8gMTgwO1xuXHRcdE1hdGhVdGlscy5kZWdSYWQgPSBNYXRoVXRpbHMuZGVncmVlc1RvUmFkaWFucztcblx0XHRyZXR1cm4gTWF0aFV0aWxzO1xuXHR9KCkpO1xuXHRzcGluZS5NYXRoVXRpbHMgPSBNYXRoVXRpbHM7XG5cdHZhciBVdGlscyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVXRpbHMoKSB7XG5cdFx0fVxuXHRcdFV0aWxzLmFycmF5Q29weSA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZVN0YXJ0LCBkZXN0LCBkZXN0U3RhcnQsIG51bUVsZW1lbnRzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gc291cmNlU3RhcnQsIGogPSBkZXN0U3RhcnQ7IGkgPCBzb3VyY2VTdGFydCArIG51bUVsZW1lbnRzOyBpKyssIGorKykge1xuXHRcdFx0XHRkZXN0W2pdID0gc291cmNlW2ldO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VXRpbHMuc2V0QXJyYXlTaXplID0gZnVuY3Rpb24gKGFycmF5LCBzaXplLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAwOyB9XG5cdFx0XHR2YXIgb2xkU2l6ZSA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdGlmIChvbGRTaXplID09IHNpemUpXG5cdFx0XHRcdHJldHVybiBhcnJheTtcblx0XHRcdGFycmF5Lmxlbmd0aCA9IHNpemU7XG5cdFx0XHRpZiAob2xkU2l6ZSA8IHNpemUpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IG9sZFNpemU7IGkgPCBzaXplOyBpKyspXG5cdFx0XHRcdFx0YXJyYXlbaV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9O1xuXHRcdFV0aWxzLmVuc3VyZUFycmF5Q2FwYWNpdHkgPSBmdW5jdGlvbiAoYXJyYXksIHNpemUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDA7IH1cblx0XHRcdGlmIChhcnJheS5sZW5ndGggPj0gc2l6ZSlcblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdFx0cmV0dXJuIFV0aWxzLnNldEFycmF5U2l6ZShhcnJheSwgc2l6ZSwgdmFsdWUpO1xuXHRcdH07XG5cdFx0VXRpbHMubmV3QXJyYXkgPSBmdW5jdGlvbiAoc2l6ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcblx0XHRcdFx0YXJyYXlbaV0gPSBkZWZhdWx0VmFsdWU7XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fTtcblx0XHRVdGlscy5uZXdGbG9hdEFycmF5ID0gZnVuY3Rpb24gKHNpemUpIHtcblx0XHRcdGlmIChVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGFycmF5W2ldID0gMDtcblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VXRpbHMubmV3U2hvcnRBcnJheSA9IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0XHRpZiAoVXRpbHMuU1VQUE9SVFNfVFlQRURfQVJSQVlTKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSW50MTZBcnJheShzaXplKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0YXJyYXlbaV0gPSAwO1xuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRVdGlscy50b0Zsb2F0QXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcblx0XHRcdHJldHVybiBVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMgPyBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSA6IGFycmF5O1xuXHRcdH07XG5cdFx0VXRpbHMuU1VQUE9SVFNfVFlQRURfQVJSQVlTID0gdHlwZW9mIChGbG9hdDMyQXJyYXkpICE9PSBcInVuZGVmaW5lZFwiO1xuXHRcdHJldHVybiBVdGlscztcblx0fSgpKTtcblx0c3BpbmUuVXRpbHMgPSBVdGlscztcblx0dmFyIERlYnVnVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIERlYnVnVXRpbHMoKSB7XG5cdFx0fVxuXHRcdERlYnVnVXRpbHMubG9nQm9uZXMgPSBmdW5jdGlvbiAoc2tlbGV0b24pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1tpXTtcblx0XHRcdFx0Y29uc29sZS5sb2coYm9uZS5kYXRhLm5hbWUgKyBcIiwgXCIgKyBib25lLmEgKyBcIiwgXCIgKyBib25lLmIgKyBcIiwgXCIgKyBib25lLmMgKyBcIiwgXCIgKyBib25lLmQgKyBcIiwgXCIgKyBib25lLndvcmxkWCArIFwiLCBcIiArIGJvbmUud29ybGRZKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBEZWJ1Z1V0aWxzO1xuXHR9KCkpO1xuXHRzcGluZS5EZWJ1Z1V0aWxzID0gRGVidWdVdGlscztcblx0dmFyIFBvb2wgPSAoZnVuY3Rpb24gKCkge1xuXHRcdGZ1bmN0aW9uIFBvb2woaW5zdGFudGlhdG9yKSB7XG5cdFx0XHR0aGlzLml0ZW1zID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLmluc3RhbnRpYXRvciA9IGluc3RhbnRpYXRvcjtcblx0XHR9XG5cdFx0UG9vbC5wcm90b3R5cGUub2J0YWluID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID4gMCA/IHRoaXMuaXRlbXMucG9wKCkgOiB0aGlzLmluc3RhbnRpYXRvcigpO1xuXHRcdH07XG5cdFx0UG9vbC5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5yZXNldClcblx0XHRcdFx0aXRlbS5yZXNldCgpO1xuXHRcdFx0dGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdH07XG5cdFx0UG9vbC5wcm90b3R5cGUuZnJlZUFsbCA9IGZ1bmN0aW9uIChpdGVtcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaXRlbXNbaV0ucmVzZXQpXG5cdFx0XHRcdFx0aXRlbXNbaV0ucmVzZXQoKTtcblx0XHRcdFx0dGhpcy5pdGVtc1tpXSA9IGl0ZW1zW2ldO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UG9vbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLml0ZW1zLmxlbmd0aCA9IDA7XG5cdFx0fTtcblx0XHRyZXR1cm4gUG9vbDtcblx0fSgpKTtcblx0c3BpbmUuUG9vbCA9IFBvb2w7XG5cdHZhciBWZWN0b3IyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBWZWN0b3IyKHgsIHkpIHtcblx0XHRcdGlmICh4ID09PSB2b2lkIDApIHsgeCA9IDA7IH1cblx0XHRcdGlmICh5ID09PSB2b2lkIDApIHsgeSA9IDA7IH1cblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdH1cblx0XHRWZWN0b3IyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFZlY3RvcjIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdFx0dmFyIHkgPSB0aGlzLnk7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdH07XG5cdFx0VmVjdG9yMi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuICE9IDApIHtcblx0XHRcdFx0dGhpcy54IC89IGxlbjtcblx0XHRcdFx0dGhpcy55IC89IGxlbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0cmV0dXJuIFZlY3RvcjI7XG5cdH0oKSk7XG5cdHNwaW5lLlZlY3RvcjIgPSBWZWN0b3IyO1xuXHR2YXIgVGltZUtlZXBlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVGltZUtlZXBlcigpIHtcblx0XHRcdHRoaXMubWF4RGVsdGEgPSAwLjA2NDtcblx0XHRcdHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gMDtcblx0XHRcdHRoaXMuZGVsdGEgPSAwO1xuXHRcdFx0dGhpcy50b3RhbFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5sYXN0VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuXHRcdFx0dGhpcy5mcmFtZUNvdW50ID0gMDtcblx0XHRcdHRoaXMuZnJhbWVUaW1lID0gMDtcblx0XHR9XG5cdFx0VGltZUtlZXBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuXHRcdFx0dGhpcy5kZWx0YSA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XG5cdFx0XHR0aGlzLmZyYW1lVGltZSArPSB0aGlzLmRlbHRhO1xuXHRcdFx0dGhpcy50b3RhbFRpbWUgKz0gdGhpcy5kZWx0YTtcblx0XHRcdGlmICh0aGlzLmRlbHRhID4gdGhpcy5tYXhEZWx0YSlcblx0XHRcdFx0dGhpcy5kZWx0YSA9IHRoaXMubWF4RGVsdGE7XG5cdFx0XHR0aGlzLmxhc3RUaW1lID0gbm93O1xuXHRcdFx0dGhpcy5mcmFtZUNvdW50Kys7XG5cdFx0XHRpZiAodGhpcy5mcmFtZVRpbWUgPiAxKSB7XG5cdFx0XHRcdHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gdGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcmFtZVRpbWU7XG5cdFx0XHRcdHRoaXMuZnJhbWVUaW1lID0gMDtcblx0XHRcdFx0dGhpcy5mcmFtZUNvdW50ID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBUaW1lS2VlcGVyO1xuXHR9KCkpO1xuXHRzcGluZS5UaW1lS2VlcGVyID0gVGltZUtlZXBlcjtcblx0dmFyIFdpbmRvd2VkTWVhbiA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gV2luZG93ZWRNZWFuKHdpbmRvd1NpemUpIHtcblx0XHRcdGlmICh3aW5kb3dTaXplID09PSB2b2lkIDApIHsgd2luZG93U2l6ZSA9IDMyOyB9XG5cdFx0XHR0aGlzLmFkZGVkVmFsdWVzID0gMDtcblx0XHRcdHRoaXMubGFzdFZhbHVlID0gMDtcblx0XHRcdHRoaXMubWVhbiA9IDA7XG5cdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdHRoaXMudmFsdWVzID0gbmV3IEFycmF5KHdpbmRvd1NpemUpO1xuXHRcdH1cblx0XHRXaW5kb3dlZE1lYW4ucHJvdG90eXBlLmhhc0Vub3VnaERhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRlZFZhbHVlcyA+PSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cdFx0fTtcblx0XHRXaW5kb3dlZE1lYW4ucHJvdG90eXBlLmFkZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy5hZGRlZFZhbHVlcyA8IHRoaXMudmFsdWVzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5hZGRlZFZhbHVlcysrO1xuXHRcdFx0dGhpcy52YWx1ZXNbdGhpcy5sYXN0VmFsdWUrK10gPSB2YWx1ZTtcblx0XHRcdGlmICh0aGlzLmxhc3RWYWx1ZSA+IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdHRoaXMubGFzdFZhbHVlID0gMDtcblx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXHRcdH07XG5cdFx0V2luZG93ZWRNZWFuLnByb3RvdHlwZS5nZXRNZWFuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuaGFzRW5vdWdoRGF0YSgpKSB7XG5cdFx0XHRcdGlmICh0aGlzLmRpcnR5KSB7XG5cdFx0XHRcdFx0dmFyIG1lYW4gPSAwO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdG1lYW4gKz0gdGhpcy52YWx1ZXNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMubWVhbiA9IG1lYW4gLyB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm1lYW47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gV2luZG93ZWRNZWFuO1xuXHR9KCkpO1xuXHRzcGluZS5XaW5kb3dlZE1lYW4gPSBXaW5kb3dlZE1lYW47XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgd2ViZ2w7XG5cdChmdW5jdGlvbiAod2ViZ2wpIHtcblx0XHR2YXIgQXNzZXRNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRcdF9fZXh0ZW5kcyhBc3NldE1hbmFnZXIsIF9zdXBlcik7XG5cdFx0XHRmdW5jdGlvbiBBc3NldE1hbmFnZXIoY29udGV4dCwgcGF0aFByZWZpeCkge1xuXHRcdFx0XHRpZiAocGF0aFByZWZpeCA9PT0gdm9pZCAwKSB7IHBhdGhQcmVmaXggPSBcIlwiOyB9XG5cdFx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChpbWFnZSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgc3BpbmUud2ViZ2wuR0xUZXh0dXJlKGNvbnRleHQsIGltYWdlKTtcblx0XHRcdFx0fSwgcGF0aFByZWZpeCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQXNzZXRNYW5hZ2VyO1xuXHRcdH0oc3BpbmUuQXNzZXRNYW5hZ2VyKSk7XG5cdFx0d2ViZ2wuQXNzZXRNYW5hZ2VyID0gQXNzZXRNYW5hZ2VyO1xuXHR9KSh3ZWJnbCA9IHNwaW5lLndlYmdsIHx8IChzcGluZS53ZWJnbCA9IHt9KSk7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgd2ViZ2w7XG5cdChmdW5jdGlvbiAod2ViZ2wpIHtcblx0XHR2YXIgT3J0aG9DYW1lcmEgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ZnVuY3Rpb24gT3J0aG9DYW1lcmEodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpIHtcblx0XHRcdFx0dGhpcy5wb3NpdGlvbiA9IG5ldyB3ZWJnbC5WZWN0b3IzKDAsIDAsIDApO1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbiA9IG5ldyB3ZWJnbC5WZWN0b3IzKDAsIDAsIC0xKTtcblx0XHRcdFx0dGhpcy51cCA9IG5ldyB3ZWJnbC5WZWN0b3IzKDAsIDEsIDApO1xuXHRcdFx0XHR0aGlzLm5lYXIgPSAwO1xuXHRcdFx0XHR0aGlzLmZhciA9IDEwMDtcblx0XHRcdFx0dGhpcy56b29tID0gMTtcblx0XHRcdFx0dGhpcy52aWV3cG9ydFdpZHRoID0gMDtcblx0XHRcdFx0dGhpcy52aWV3cG9ydEhlaWdodCA9IDA7XG5cdFx0XHRcdHRoaXMucHJvamVjdGlvblZpZXcgPSBuZXcgd2ViZ2wuTWF0cml4NCgpO1xuXHRcdFx0XHR0aGlzLmludmVyc2VQcm9qZWN0aW9uVmlldyA9IG5ldyB3ZWJnbC5NYXRyaXg0KCk7XG5cdFx0XHRcdHRoaXMucHJvamVjdGlvbiA9IG5ldyB3ZWJnbC5NYXRyaXg0KCk7XG5cdFx0XHRcdHRoaXMudmlldyA9IG5ldyB3ZWJnbC5NYXRyaXg0KCk7XG5cdFx0XHRcdHRoaXMudG1wID0gbmV3IHdlYmdsLlZlY3RvcjMoKTtcblx0XHRcdFx0dGhpcy52aWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aDtcblx0XHRcdFx0dGhpcy52aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0O1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0T3J0aG9DYW1lcmEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHByb2plY3Rpb24gPSB0aGlzLnByb2plY3Rpb247XG5cdFx0XHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdFx0XHR2YXIgcHJvamVjdGlvblZpZXcgPSB0aGlzLnByb2plY3Rpb25WaWV3O1xuXHRcdFx0XHR2YXIgaW52ZXJzZVByb2plY3Rpb25WaWV3ID0gdGhpcy5pbnZlcnNlUHJvamVjdGlvblZpZXc7XG5cdFx0XHRcdHZhciB6b29tID0gdGhpcy56b29tLCB2aWV3cG9ydFdpZHRoID0gdGhpcy52aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCA9IHRoaXMudmlld3BvcnRIZWlnaHQ7XG5cdFx0XHRcdHByb2plY3Rpb24ub3J0aG8oem9vbSAqICgtdmlld3BvcnRXaWR0aCAvIDIpLCB6b29tICogKHZpZXdwb3J0V2lkdGggLyAyKSwgem9vbSAqICgtdmlld3BvcnRIZWlnaHQgLyAyKSwgem9vbSAqICh2aWV3cG9ydEhlaWdodCAvIDIpLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcblx0XHRcdFx0dmlldy5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGhpcy5kaXJlY3Rpb24sIHRoaXMudXApO1xuXHRcdFx0XHRwcm9qZWN0aW9uVmlldy5zZXQocHJvamVjdGlvbi52YWx1ZXMpO1xuXHRcdFx0XHRwcm9qZWN0aW9uVmlldy5tdWx0aXBseSh2aWV3KTtcblx0XHRcdFx0aW52ZXJzZVByb2plY3Rpb25WaWV3LnNldChwcm9qZWN0aW9uVmlldy52YWx1ZXMpLmludmVydCgpO1xuXHRcdFx0fTtcblx0XHRcdE9ydGhvQ2FtZXJhLnByb3RvdHlwZS5zY3JlZW5Ub1dvcmxkID0gZnVuY3Rpb24gKHNjcmVlbkNvb3Jkcywgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuXHRcdFx0XHR2YXIgeCA9IHNjcmVlbkNvb3Jkcy54LCB5ID0gc2NyZWVuSGVpZ2h0IC0gc2NyZWVuQ29vcmRzLnkgLSAxO1xuXHRcdFx0XHR2YXIgdG1wID0gdGhpcy50bXA7XG5cdFx0XHRcdHRtcC54ID0gKDIgKiB4KSAvIHNjcmVlbldpZHRoIC0gMTtcblx0XHRcdFx0dG1wLnkgPSAoMiAqIHkpIC8gc2NyZWVuSGVpZ2h0IC0gMTtcblx0XHRcdFx0dG1wLnogPSAoMiAqIHNjcmVlbkNvb3Jkcy56KSAtIDE7XG5cdFx0XHRcdHRtcC5wcm9qZWN0KHRoaXMuaW52ZXJzZVByb2plY3Rpb25WaWV3KTtcblx0XHRcdFx0c2NyZWVuQ29vcmRzLnNldCh0bXAueCwgdG1wLnksIHRtcC56KTtcblx0XHRcdFx0cmV0dXJuIHNjcmVlbkNvb3Jkcztcblx0XHRcdH07XG5cdFx0XHRPcnRob0NhbWVyYS5wcm90b3R5cGUuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpIHtcblx0XHRcdFx0dGhpcy52aWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aDtcblx0XHRcdFx0dGhpcy52aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBPcnRob0NhbWVyYTtcblx0XHR9KCkpO1xuXHRcdHdlYmdsLk9ydGhvQ2FtZXJhID0gT3J0aG9DYW1lcmE7XG5cdH0pKHdlYmdsID0gc3BpbmUud2ViZ2wgfHwgKHNwaW5lLndlYmdsID0ge30pKTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciB3ZWJnbDtcblx0KGZ1bmN0aW9uICh3ZWJnbCkge1xuXHRcdHZhciBHTFRleHR1cmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdFx0X19leHRlbmRzKEdMVGV4dHVyZSwgX3N1cGVyKTtcblx0XHRcdGZ1bmN0aW9uIEdMVGV4dHVyZShjb250ZXh0LCBpbWFnZSwgdXNlTWlwTWFwcykge1xuXHRcdFx0XHRpZiAodXNlTWlwTWFwcyA9PT0gdm9pZCAwKSB7IHVzZU1pcE1hcHMgPSBmYWxzZTsgfVxuXHRcdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZSk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuYm91bmRVbml0ID0gMDtcblx0XHRcdFx0dGhpcy51c2VNaXBNYXBzID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0ID8gY29udGV4dCA6IG5ldyB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0KGNvbnRleHQpO1xuXHRcdFx0XHR0aGlzLnVzZU1pcE1hcHMgPSB1c2VNaXBNYXBzO1xuXHRcdFx0XHR0aGlzLnJlc3RvcmUoKTtcblx0XHRcdFx0dGhpcy5jb250ZXh0LmFkZFJlc3RvcmFibGUodGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRHTFRleHR1cmUucHJvdG90eXBlLnNldEZpbHRlcnMgPSBmdW5jdGlvbiAobWluRmlsdGVyLCBtYWdGaWx0ZXIpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIG1pbkZpbHRlcik7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWdGaWx0ZXIpO1xuXHRcdFx0fTtcblx0XHRcdEdMVGV4dHVyZS5wcm90b3R5cGUuc2V0V3JhcHMgPSBmdW5jdGlvbiAodVdyYXAsIHZXcmFwKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHVXcmFwKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdldyYXApO1xuXHRcdFx0fTtcblx0XHRcdEdMVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHVzZU1pcE1hcHMpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHRpZiAoIXRoaXMudGV4dHVyZSkge1xuXHRcdFx0XHRcdHRoaXMudGV4dHVyZSA9IHRoaXMuY29udGV4dC5nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5faW1hZ2UpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHVzZU1pcE1hcHMgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLkxJTkVBUik7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0aWYgKHVzZU1pcE1hcHMpXG5cdFx0XHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cdFx0XHR9O1xuXHRcdFx0R0xUZXh0dXJlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnRleHR1cmUgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSh0aGlzLnVzZU1pcE1hcHMpO1xuXHRcdFx0fTtcblx0XHRcdEdMVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh1bml0KSB7XG5cdFx0XHRcdGlmICh1bml0ID09PSB2b2lkIDApIHsgdW5pdCA9IDA7IH1cblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHR0aGlzLmJvdW5kVW5pdCA9IHVuaXQ7XG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcblx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblx0XHRcdH07XG5cdFx0XHRHTFRleHR1cmUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5ib3VuZFVuaXQpO1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHRcdH07XG5cdFx0XHRHTFRleHR1cmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5yZW1vdmVSZXN0b3JhYmxlKHRoaXMpO1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdGdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gR0xUZXh0dXJlO1xuXHRcdH0oc3BpbmUuVGV4dHVyZSkpO1xuXHRcdHdlYmdsLkdMVGV4dHVyZSA9IEdMVGV4dHVyZTtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIHdlYmdsO1xuXHQoZnVuY3Rpb24gKHdlYmdsKSB7XG5cdFx0dmFyIElucHV0ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIElucHV0KGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5sYXN0WCA9IDA7XG5cdFx0XHRcdHRoaXMubGFzdFkgPSAwO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkRvd24gPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5jdXJyVG91Y2ggPSBudWxsO1xuXHRcdFx0XHR0aGlzLnRvdWNoZXNQb29sID0gbmV3IHNwaW5lLlBvb2woZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgc3BpbmUud2ViZ2wuVG91Y2goMCwgMCwgMCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmxpc3RlbmVycyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0XHR0aGlzLnNldHVwQ2FsbGJhY2tzKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0SW5wdXQucHJvdG90eXBlLnNldHVwQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHRcdGlmIChldiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRcdHZhciB4ID0gZXYuY2xpZW50WCAtIHJlY3QubGVmdDtcblx0XHRcdFx0XHRcdHZhciB5ID0gZXYuY2xpZW50WSAtIHJlY3QudG9wO1xuXHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IF90aGlzLmxpc3RlbmVycztcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5kb3duKHgsIHkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3RoaXMubGFzdFggPSB4O1xuXHRcdFx0XHRcdFx0X3RoaXMubGFzdFkgPSB5O1xuXHRcdFx0XHRcdFx0X3RoaXMuYnV0dG9uRG93biA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHRcdGlmIChldiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRcdHZhciB4ID0gZXYuY2xpZW50WCAtIHJlY3QubGVmdDtcblx0XHRcdFx0XHRcdHZhciB5ID0gZXYuY2xpZW50WSAtIHJlY3QudG9wO1xuXHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IF90aGlzLmxpc3RlbmVycztcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfdGhpcy5idXR0b25Eb3duKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmRyYWdnZWQoeCwgeSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLm1vdmVkKHgsIHkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfdGhpcy5sYXN0WCA9IHg7XG5cdFx0XHRcdFx0XHRfdGhpcy5sYXN0WSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdFx0XHRpZiAoZXYgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IGV2LmNsaWVudFggLSByZWN0LmxlZnQ7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGV2LmNsaWVudFkgLSByZWN0LnRvcDtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lcnMgPSBfdGhpcy5saXN0ZW5lcnM7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0udXAoeCwgeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfdGhpcy5sYXN0WCA9IHg7XG5cdFx0XHRcdFx0XHRfdGhpcy5sYXN0WSA9IHk7XG5cdFx0XHRcdFx0XHRfdGhpcy5idXR0b25Eb3duID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdFx0XHRpZiAoX3RoaXMuY3VyclRvdWNoICE9IG51bGwpXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0dmFyIHRvdWNoZXMgPSBldi5jaGFuZ2VkVG91Y2hlcztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG5cdFx0XHRcdFx0XHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IHRvdWNoLmNsaWVudFggLSByZWN0LmxlZnQ7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IHRvdWNoLmNsaWVudFkgLSByZWN0LnRvcDtcblx0XHRcdFx0XHRcdF90aGlzLmN1cnJUb3VjaCA9IF90aGlzLnRvdWNoZXNQb29sLm9idGFpbigpO1xuXHRcdFx0XHRcdFx0X3RoaXMuY3VyclRvdWNoLmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXHRcdFx0XHRcdFx0X3RoaXMuY3VyclRvdWNoLnggPSB4O1xuXHRcdFx0XHRcdFx0X3RoaXMuY3VyclRvdWNoLnkgPSB5O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBsaXN0ZW5lcnMgPSBfdGhpcy5saXN0ZW5lcnM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaV8xID0gMDsgaV8xIDwgbGlzdGVuZXJzLmxlbmd0aDsgaV8xKyspIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpXzFdLmRvd24oX3RoaXMuY3VyclRvdWNoLngsIF90aGlzLmN1cnJUb3VjaC55KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJTdGFydCBcIiArIF90aGlzLmN1cnJUb3VjaC54ICsgXCIsIFwiICsgX3RoaXMuY3VyclRvdWNoLnkpO1xuXHRcdFx0XHRcdF90aGlzLmxhc3RYID0gX3RoaXMuY3VyclRvdWNoLng7XG5cdFx0XHRcdFx0X3RoaXMubGFzdFkgPSBfdGhpcy5jdXJyVG91Y2gueTtcblx0XHRcdFx0XHRfdGhpcy5idXR0b25Eb3duID0gdHJ1ZTtcblx0XHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9LCBmYWxzZSk7XG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHRcdHZhciB0b3VjaGVzID0gZXYuY2hhbmdlZFRvdWNoZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKF90aGlzLmN1cnJUb3VjaC5pZGVudGlmaWVyID09PSB0b3VjaC5pZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHggPSBfdGhpcy5jdXJyVG91Y2gueCA9IHRvdWNoLmNsaWVudFggLSByZWN0LmxlZnQ7XG5cdFx0XHRcdFx0XHRcdHZhciB5ID0gX3RoaXMuY3VyclRvdWNoLnkgPSB0b3VjaC5jbGllbnRZIC0gcmVjdC50b3A7XG5cdFx0XHRcdFx0XHRcdF90aGlzLnRvdWNoZXNQb29sLmZyZWUoX3RoaXMuY3VyclRvdWNoKTtcblx0XHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IF90aGlzLmxpc3RlbmVycztcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaV8yID0gMDsgaV8yIDwgbGlzdGVuZXJzLmxlbmd0aDsgaV8yKyspIHtcblx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV8yXS51cCh4LCB5KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkVuZCBcIiArIHggKyBcIiwgXCIgKyB5KTtcblx0XHRcdFx0XHRcdFx0X3RoaXMubGFzdFggPSB4O1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5sYXN0WSA9IHk7XG5cdFx0XHRcdFx0XHRcdF90aGlzLmJ1dHRvbkRvd24gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuY3VyclRvdWNoID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdFx0dmFyIHRvdWNoZXMgPSBldi5jaGFuZ2VkVG91Y2hlcztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoX3RoaXMuY3VyclRvdWNoLmlkZW50aWZpZXIgPT09IHRvdWNoLmlkZW50aWZpZXIpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgeCA9IF90aGlzLmN1cnJUb3VjaC54ID0gdG91Y2guY2xpZW50WCAtIHJlY3QubGVmdDtcblx0XHRcdFx0XHRcdFx0dmFyIHkgPSBfdGhpcy5jdXJyVG91Y2gueSA9IHRvdWNoLmNsaWVudFkgLSByZWN0LnRvcDtcblx0XHRcdFx0XHRcdFx0X3RoaXMudG91Y2hlc1Bvb2wuZnJlZShfdGhpcy5jdXJyVG91Y2gpO1xuXHRcdFx0XHRcdFx0XHR2YXIgbGlzdGVuZXJzID0gX3RoaXMubGlzdGVuZXJzO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpXzMgPSAwOyBpXzMgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpXzMrKykge1xuXHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpXzNdLnVwKHgsIHkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiRW5kIFwiICsgeCArIFwiLCBcIiArIHkpO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5sYXN0WCA9IHg7XG5cdFx0XHRcdFx0XHRcdF90aGlzLmxhc3RZID0geTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuYnV0dG9uRG93biA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5jdXJyVG91Y2ggPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdFx0aWYgKF90aGlzLmN1cnJUb3VjaCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdHZhciB0b3VjaGVzID0gZXYuY2hhbmdlZFRvdWNoZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKF90aGlzLmN1cnJUb3VjaC5pZGVudGlmaWVyID09PSB0b3VjaC5pZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHggPSB0b3VjaC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuXHRcdFx0XHRcdFx0XHR2YXIgeSA9IHRvdWNoLmNsaWVudFkgLSByZWN0LnRvcDtcblx0XHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IF90aGlzLmxpc3RlbmVycztcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaV80ID0gMDsgaV80IDwgbGlzdGVuZXJzLmxlbmd0aDsgaV80KyspIHtcblx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV80XS5kcmFnZ2VkKHgsIHkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiRHJhZyBcIiArIHggKyBcIiwgXCIgKyB5KTtcblx0XHRcdFx0XHRcdFx0X3RoaXMubGFzdFggPSBfdGhpcy5jdXJyVG91Y2gueCA9IHg7XG5cdFx0XHRcdFx0XHRcdF90aGlzLmxhc3RZID0gX3RoaXMuY3VyclRvdWNoLnkgPSB5O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0fTtcblx0XHRcdElucHV0LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXHRcdFx0XHR0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdH07XG5cdFx0XHRJbnB1dC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcblx0XHRcdFx0dmFyIGlkeCA9IHRoaXMubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAoaWR4ID4gLTEpIHtcblx0XHRcdFx0XHR0aGlzLmxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBJbnB1dDtcblx0XHR9KCkpO1xuXHRcdHdlYmdsLklucHV0ID0gSW5wdXQ7XG5cdFx0dmFyIFRvdWNoID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFRvdWNoKGlkZW50aWZpZXIsIHgsIHkpIHtcblx0XHRcdFx0dGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcblx0XHRcdFx0dGhpcy54ID0geDtcblx0XHRcdFx0dGhpcy55ID0geTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBUb3VjaDtcblx0XHR9KCkpO1xuXHRcdHdlYmdsLlRvdWNoID0gVG91Y2g7XG5cdH0pKHdlYmdsID0gc3BpbmUud2ViZ2wgfHwgKHNwaW5lLndlYmdsID0ge30pKTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciB3ZWJnbDtcblx0KGZ1bmN0aW9uICh3ZWJnbCkge1xuXHRcdHZhciBMb2FkaW5nU2NyZWVuID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIExvYWRpbmdTY3JlZW4ocmVuZGVyZXIpIHtcblx0XHRcdFx0dGhpcy5sb2dvID0gbnVsbDtcblx0XHRcdFx0dGhpcy5zcGlubmVyID0gbnVsbDtcblx0XHRcdFx0dGhpcy5hbmdsZSA9IDA7XG5cdFx0XHRcdHRoaXMuZmFkZU91dCA9IDA7XG5cdFx0XHRcdHRoaXMudGltZUtlZXBlciA9IG5ldyBzcGluZS5UaW1lS2VlcGVyKCk7XG5cdFx0XHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IHNwaW5lLkNvbG9yKDAuMTM1LCAwLjEzNSwgMC4xMzUsIDEpO1xuXHRcdFx0XHR0aGlzLnRlbXBDb2xvciA9IG5ldyBzcGluZS5Db2xvcigpO1xuXHRcdFx0XHR0aGlzLmZpcnN0RHJhdyA9IDA7XG5cdFx0XHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHRcdFx0dGhpcy50aW1lS2VlcGVyLm1heERlbHRhID0gOTtcblx0XHRcdFx0aWYgKExvYWRpbmdTY3JlZW4ubG9nb0ltZyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBpc1NhZmFyaSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSA+IC0xO1xuXHRcdFx0XHRcdExvYWRpbmdTY3JlZW4ubG9nb0ltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdFx0XHRcdExvYWRpbmdTY3JlZW4ubG9nb0ltZy5zcmMgPSBMb2FkaW5nU2NyZWVuLlNQSU5FX0xPR09fREFUQTtcblx0XHRcdFx0XHRpZiAoIWlzU2FmYXJpKVxuXHRcdFx0XHRcdFx0TG9hZGluZ1NjcmVlbi5sb2dvSW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcblx0XHRcdFx0XHRMb2FkaW5nU2NyZWVuLmxvZ29JbWcub25sb2FkID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0XHRcdFx0XHRMb2FkaW5nU2NyZWVuLmxvYWRlZCsrO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0TG9hZGluZ1NjcmVlbi5zcGlubmVySW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRcdFx0TG9hZGluZ1NjcmVlbi5zcGlubmVySW1nLnNyYyA9IExvYWRpbmdTY3JlZW4uU1BJTk5FUl9EQVRBO1xuXHRcdFx0XHRcdGlmICghaXNTYWZhcmkpXG5cdFx0XHRcdFx0XHRMb2FkaW5nU2NyZWVuLnNwaW5uZXJJbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuXHRcdFx0XHRcdExvYWRpbmdTY3JlZW4uc3Bpbm5lckltZy5vbmxvYWQgPSBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdFx0XHRcdExvYWRpbmdTY3JlZW4ubG9hZGVkKys7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0TG9hZGluZ1NjcmVlbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjb21wbGV0ZSkge1xuXHRcdFx0XHRpZiAoY29tcGxldGUgPT09IHZvaWQgMCkgeyBjb21wbGV0ZSA9IGZhbHNlOyB9XG5cdFx0XHRcdGlmIChjb21wbGV0ZSAmJiB0aGlzLmZhZGVPdXQgPiBMb2FkaW5nU2NyZWVuLkZBREVfU0VDT05EUylcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMudGltZUtlZXBlci51cGRhdGUoKTtcblx0XHRcdFx0dmFyIGEgPSBNYXRoLmFicyhNYXRoLnNpbih0aGlzLnRpbWVLZWVwZXIudG90YWxUaW1lICsgMC43NSkpO1xuXHRcdFx0XHR0aGlzLmFuZ2xlIC09IHRoaXMudGltZUtlZXBlci5kZWx0YSAqIDM2MCAqICgxICsgMS41ICogTWF0aC5wb3coYSwgNSkpO1xuXHRcdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXHRcdFx0XHR2YXIgY2FudmFzID0gcmVuZGVyZXIuY2FudmFzO1xuXHRcdFx0XHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0LmdsO1xuXHRcdFx0XHR2YXIgb2xkWCA9IHJlbmRlcmVyLmNhbWVyYS5wb3NpdGlvbi54LCBvbGRZID0gcmVuZGVyZXIuY2FtZXJhLnBvc2l0aW9uLnk7XG5cdFx0XHRcdHJlbmRlcmVyLmNhbWVyYS5wb3NpdGlvbi5zZXQoY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIsIDApO1xuXHRcdFx0XHRyZW5kZXJlci5jYW1lcmEudmlld3BvcnRXaWR0aCA9IGNhbnZhcy53aWR0aDtcblx0XHRcdFx0cmVuZGVyZXIuY2FtZXJhLnZpZXdwb3J0SGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblx0XHRcdFx0cmVuZGVyZXIucmVzaXplKHdlYmdsLlJlc2l6ZU1vZGUuU3RyZXRjaCk7XG5cdFx0XHRcdGlmICghY29tcGxldGUpIHtcblx0XHRcdFx0XHRnbC5jbGVhckNvbG9yKHRoaXMuYmFja2dyb3VuZENvbG9yLnIsIHRoaXMuYmFja2dyb3VuZENvbG9yLmcsIHRoaXMuYmFja2dyb3VuZENvbG9yLmIsIHRoaXMuYmFja2dyb3VuZENvbG9yLmEpO1xuXHRcdFx0XHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXHRcdFx0XHRcdHRoaXMudGVtcENvbG9yLmEgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZmFkZU91dCArPSB0aGlzLnRpbWVLZWVwZXIuZGVsdGEgKiAodGhpcy50aW1lS2VlcGVyLnRvdGFsVGltZSA8IDEgPyAyIDogMSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuZmFkZU91dCA+IExvYWRpbmdTY3JlZW4uRkFERV9TRUNPTkRTKSB7XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5jYW1lcmEucG9zaXRpb24uc2V0KG9sZFgsIG9sZFksIDApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhID0gMSAtIHRoaXMuZmFkZU91dCAvIExvYWRpbmdTY3JlZW4uRkFERV9TRUNPTkRTO1xuXHRcdFx0XHRcdHRoaXMudGVtcENvbG9yLnNldEZyb21Db2xvcih0aGlzLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRcdFx0dGhpcy50ZW1wQ29sb3IuYSA9IDEgLSAoYSAtIDEpICogKGEgLSAxKTtcblx0XHRcdFx0XHRyZW5kZXJlci5iZWdpbigpO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnF1YWQodHJ1ZSwgMCwgMCwgY2FudmFzLndpZHRoLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIDAsIGNhbnZhcy5oZWlnaHQsIHRoaXMudGVtcENvbG9yLCB0aGlzLnRlbXBDb2xvciwgdGhpcy50ZW1wQ29sb3IsIHRoaXMudGVtcENvbG9yKTtcblx0XHRcdFx0XHRyZW5kZXJlci5lbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRlbXBDb2xvci5zZXQoMSwgMSwgMSwgdGhpcy50ZW1wQ29sb3IuYSk7XG5cdFx0XHRcdGlmIChMb2FkaW5nU2NyZWVuLmxvYWRlZCAhPSAyKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0aWYgKHRoaXMubG9nbyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMubG9nbyA9IG5ldyB3ZWJnbC5HTFRleHR1cmUocmVuZGVyZXIuY29udGV4dCwgTG9hZGluZ1NjcmVlbi5sb2dvSW1nKTtcblx0XHRcdFx0XHR0aGlzLnNwaW5uZXIgPSBuZXcgd2ViZ2wuR0xUZXh0dXJlKHJlbmRlcmVyLmNvbnRleHQsIExvYWRpbmdTY3JlZW4uc3Bpbm5lckltZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sb2dvLnVwZGF0ZShmYWxzZSk7XG5cdFx0XHRcdHRoaXMuc3Bpbm5lci51cGRhdGUoZmFsc2UpO1xuXHRcdFx0XHR2YXIgbG9nb1dpZHRoID0gdGhpcy5sb2dvLmdldEltYWdlKCkud2lkdGg7XG5cdFx0XHRcdHZhciBsb2dvSGVpZ2h0ID0gdGhpcy5sb2dvLmdldEltYWdlKCkuaGVpZ2h0O1xuXHRcdFx0XHR2YXIgc3Bpbm5lcldpZHRoID0gdGhpcy5zcGlubmVyLmdldEltYWdlKCkud2lkdGg7XG5cdFx0XHRcdHZhciBzcGlubmVySGVpZ2h0ID0gdGhpcy5zcGlubmVyLmdldEltYWdlKCkuaGVpZ2h0O1xuXHRcdFx0XHRyZW5kZXJlci5iYXRjaGVyLnNldEJsZW5kTW9kZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdFx0XHRyZW5kZXJlci5iZWdpbigpO1xuXHRcdFx0XHRyZW5kZXJlci5kcmF3VGV4dHVyZSh0aGlzLmxvZ28sIChjYW52YXMud2lkdGggLSBsb2dvV2lkdGgpIC8gMiwgKGNhbnZhcy5oZWlnaHQgLSBsb2dvSGVpZ2h0KSAvIDIsIGxvZ29XaWR0aCwgbG9nb0hlaWdodCwgdGhpcy50ZW1wQ29sb3IpO1xuXHRcdFx0XHRyZW5kZXJlci5kcmF3VGV4dHVyZVJvdGF0ZWQodGhpcy5zcGlubmVyLCAoY2FudmFzLndpZHRoIC0gc3Bpbm5lcldpZHRoKSAvIDIsIChjYW52YXMuaGVpZ2h0IC0gc3Bpbm5lckhlaWdodCkgLyAyLCBzcGlubmVyV2lkdGgsIHNwaW5uZXJIZWlnaHQsIHNwaW5uZXJXaWR0aCAvIDIsIHNwaW5uZXJIZWlnaHQgLyAyLCB0aGlzLmFuZ2xlLCB0aGlzLnRlbXBDb2xvcik7XG5cdFx0XHRcdHJlbmRlcmVyLmVuZCgpO1xuXHRcdFx0XHRyZW5kZXJlci5jYW1lcmEucG9zaXRpb24uc2V0KG9sZFgsIG9sZFksIDApO1xuXHRcdFx0fTtcblx0XHRcdExvYWRpbmdTY3JlZW4uRkFERV9TRUNPTkRTID0gMTtcblx0XHRcdExvYWRpbmdTY3JlZW4ubG9hZGVkID0gMDtcblx0XHRcdExvYWRpbmdTY3JlZW4uc3Bpbm5lckltZyA9IG51bGw7XG5cdFx0XHRMb2FkaW5nU2NyZWVuLmxvZ29JbWcgPSBudWxsO1xuXHRcdFx0TG9hZGluZ1NjcmVlbi5TUElOTkVSX0RBVEEgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBS0FBQUFDaENBTUFBQUIzVFVTNkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBWU5RVEZSRkFBQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQS8wQUEvMEFBLzBBQWtURFJ5QUFBQUlCMFVrNVRBQUFCQWdNRUJRWUhDQWtLQ3d3T0R4QVJFaE1VRlJZWEdCa2FIQjBlSUNFaUl5UWxKaWNvS1NvckxDMHVMekF4TWpNME56ZzVPanM4UFQ0L1FFRkRSVWxLUzB4TlRrOVFVbFJXV0ZsYlhGMWVZV0pqWm1oc2NIRjBkM2g1ZTN4K2Y0Q0lpWXVNajVHU2xKV1htNTZpbzZhcnI3ckF4Y2pPMGRYZTZPbnI4Zm1iNXNPT0FBQUR1RWxFUVZRWUdlM0IrM3ZUVkJ3SDRNLzNuQ1J0MTNicjJMb3podWcycTI1Z1lRdWJjeHFWS1lvTUNZb0tqRXNVZFNwZWlCYzBLbDd5cDl0MnphMzlwZWx5N1BGNXp2dWlRS2MrL2UyZjhLK2Y5ZzJveVE3N0FnNFZHWCtIa2V0UTBYWVllMEpRMENkaG9nd0YrV0ZpQmdyNkpreFVvS0NETU1HZ29QMHc5Z2RVdEIzR2ZvQ0tWc1BZQVZRMEg4WXVRVVdWTUhZR0t1SmhyQWtsUFFrakpwVDBiZGozTzlTMEZmWjlBRFh4UDhNalZTaXFGZmE4QjJWVlY4K2RmMTRRdEI0aXduK0JwdVpFZ3lNMzhXTVFIRFlobmJrZ3VrckloNXlnWjQ4Z2x5bjZLc2hsTCtqYmhWUmN4Q3prMEFwaUM1Q0k1a1ZzZ1RBeTlqaUkvV3hCR21xSUZCTWpxd1lwaHdSWmFpTE53c2pxUWRvVlNGSVNHUndqTTRPTUZVakJSY1lDWVdUMFhaRDJTd1VTMEx6SUtDR0gyU0RqYTBMeEtpSmpDcm0wZ293VkZJNmFJczFDVG91UGc1UXZVVGdTS1hNTXVWVWVCU21Fb3BGSVRCUEd3TzhIQ1liQ1RZdEltVEFXZWp1STNDTVVqbVpGVDVOamJNLzlHdlFjTWtoQURkRlJJeHhEN2F1ZzR3R0RGR1NWVGNMeDBNenV0UTJDcG1tYXBtbWFwbW1hcG1tYXBtbWFwaFdCbUdGVjZyTk5jYUxDMEdVdXYzTFJPZnRVbzh3SmswYTEwMjA3c1ZFRDZJSWYrOTY3M0xJd1FlVzJQYUNFSlgvQSt4WW1oVGJ0UVV1NDZnOTZTSmdRWmc5Wnd4ZitFQU1Ud3V3aG0zamtEN0V3SWR3ZUJuK1loUWxoOXBBMkh2cERURXdJczRlczRHTi9DTWVrTk94Qko5RDJCMTBuVEF5Zlc3ZlQxaGpZZ1oveFlJVXdVY3ljYWl3dXYyaDN0T2NaQURyN3VkLzEyYzBydTJjV1N3UTFVQWNpeElnSW1xWnBtcVpwbXFacG1xWnBtcVpwMnY4SE1TSWNGMTg2dDhvZ2hibmxPSnQxd25Id2w3eU9HeHdTbEhhY3JqV0c4ZFZ1ZWowM09BcG43amhIdGl5TWlaYTl5RDZoYUxZVGViV09zYkRYdlFSSHdjaEpXU1RrVi9yUVMrRW9XdHRKYVRIa0plNTZLWGNKUlp0MjBqWTQ4bm5CeTloRTRXakxTYnZBa0lmd01tNXpGRy9LeVdnUlJrZTN2WXdHWkRqcFpIQ01ydUpsdENBRnJUdHBWWXh1MWt0ekNIS3diU2RsR3FPcmV5blhHR1FwT3lsbGpJNXVlYkZiQnVTWmMySWJoQnhtdmNqOUdpU2laNTIrSFFPNW5QYjZUa0lxYWpzOUw1ZVFrN2puZGR4WmdHVDBqTk94WVNJMzYrS2RqOW9HNU9QVjZRcEI2eUp1R0FZbnFJcmVjTHZlWWxEVUtmZklPdFJFbDkwK0JpV1YzY2dNbE5SMEkwOURTUzAzMG9hU3R0eklMcFQwcGh1NUJCV1JteUFvaUxrSmdvSU1OOEdnb0pLYjRGQlF6VTBZVUZEZFRSaFFVTlZOY0NqSWRCTUVCZEU3YnVROGxGUnorOTdsVUZONWZlK3F1Ly9hTWtlQi9nVTJhZTl5MkhnYm5nQUFBQUJKUlU1RXJrSmdnZz09XCI7XG5cdFx0XHRMb2FkaW5nU2NyZWVuLlNQSU5FX0xPR09fREFUQSA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGSUFBQUFaQ0FZQUFBQ2lzM2swQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF0TkpSRUZVYU43dG1UMkkxRUFVeHdOK29XZ1JUMEhGS28wV0NrSjZPYm1BV0Z3WmJDeHNYR3lzTE5KYWlDeUlvRGFTd2s0RVR6dmhtbkJhQ1JiQldvUTAxaG80UHdvdGpQOGNFMzM3bU15OFRMSzc1N21CSDNmTFRXYmUvUGJONTNuZU5uaXFaVzhGdkFWdlFBcXVnd3ZnRERnTzluaUxSeVR5SmFnTS9BQ1BGNmJzSWw5WlJEYWMvQ2M2dExuNXhRZFJRNDk2UWxLUEx4RDVRQ0R4TzlqdEdNOFFmWW9JZ1VsZ0NpcEdDUkpMNVZ2bHlPZENVMDlpRVhrQ2ZMU0lmQ3JzN0ZhYjZuT3NpYWZ1MDZpRHdFUzl3L3VVMVFuREMrZWtrVlM5dkVhRHNnVmVCMGQrejFWRHRPR3hSYVlQYm9QM0dva2I0R2dYa1pwNGNoWlBKS2d2WjNVMFhrcmlLL1RJdDlZVURsbEZnVEFqR3dvYW9IcWZCaE1JNTh5RDRCUTRWNi9hSFlkZnhUb2Z0dnc5RjJTaVZyb2F3VTIvQ3Y1QzRUaHYwS0I5UzVueGxPZDRTVHhqd1VqelNkWWxncllpancyQnNFZmdzYUZjTTA5bGhpeXM5NHhYUVF3dWdjdmdKcmdGTGpyRUU3V1VpVHVXQ1F6dC9aWE43RmZxR3d1R0NseVZ5MnhaQUZtZkRRdk50d0ZGU3NwTURHc0QrVVRXcXUxS29WbVZvb0ZFSmdLUlh3MGlmODVScElTRXp3c2p6ZXFXemtqa0M0UElKM01VbVFnSVRBSGxRd1RGaG5aaEVMa0VudGZaUndSK0F2ZkFnWG1KSE9xVTAyWGxpZ1dUOHBwZzY3TlhiZENYZXE3YWZVUTZMOEMyRGFsRVpOdDJZeVE5NFF5OC9la2pNcEJNYmZ5bDVpVGpHN1lBSThjTmVjUk9BYjRrSm1UamFYQUYzQUd2d1Fld09pdVJ4RXRsU2FUNGoyaDJsTXNVdWVRRW9NbElLcFR2QW1LaHhQTXRDODc2akVYNnJFOGw4VE54L0tWYm42eGxXVTlOV2NTRFVzTzROR1dwUU9UWkZwSFBPb29NWGNzd21XMlhGazNpeGIydjBOcStYVktQMDBRTmFmZkJMeVd3QkkvQWtUbGZNWVpEWE1mMTJrYzZ5andFam9GZE8vNW1lNW9pLzZ0bnlobFpYNk90Z21YMWMyVWgwazNraG1iQjJiOVRSZnBkL2pmVFVlUkRKdkhkWWc1d0U3a1BYQU4zd1Exd2VEdkgreHVmRWdwaTVxSWwzUUFBQUFCSlJVNUVya0pnZ2c9PVwiO1xuXHRcdFx0cmV0dXJuIExvYWRpbmdTY3JlZW47XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5Mb2FkaW5nU2NyZWVuID0gTG9hZGluZ1NjcmVlbjtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIHdlYmdsO1xuXHQoZnVuY3Rpb24gKHdlYmdsKSB7XG5cdFx0d2ViZ2wuTTAwID0gMDtcblx0XHR3ZWJnbC5NMDEgPSA0O1xuXHRcdHdlYmdsLk0wMiA9IDg7XG5cdFx0d2ViZ2wuTTAzID0gMTI7XG5cdFx0d2ViZ2wuTTEwID0gMTtcblx0XHR3ZWJnbC5NMTEgPSA1O1xuXHRcdHdlYmdsLk0xMiA9IDk7XG5cdFx0d2ViZ2wuTTEzID0gMTM7XG5cdFx0d2ViZ2wuTTIwID0gMjtcblx0XHR3ZWJnbC5NMjEgPSA2O1xuXHRcdHdlYmdsLk0yMiA9IDEwO1xuXHRcdHdlYmdsLk0yMyA9IDE0O1xuXHRcdHdlYmdsLk0zMCA9IDM7XG5cdFx0d2ViZ2wuTTMxID0gNztcblx0XHR3ZWJnbC5NMzIgPSAxMTtcblx0XHR3ZWJnbC5NMzMgPSAxNTtcblx0XHR2YXIgTWF0cml4NCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRmdW5jdGlvbiBNYXRyaXg0KCkge1xuXHRcdFx0XHR0aGlzLnRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhbHVlcztcblx0XHRcdFx0dlt3ZWJnbC5NMDBdID0gMTtcblx0XHRcdFx0dlt3ZWJnbC5NMTFdID0gMTtcblx0XHRcdFx0dlt3ZWJnbC5NMjJdID0gMTtcblx0XHRcdFx0dlt3ZWJnbC5NMzNdID0gMTtcblx0XHRcdH1cblx0XHRcdE1hdHJpeDQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0XHRcdFx0dGhpcy52YWx1ZXMuc2V0KHZhbHVlcyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdE1hdHJpeDQucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLnRlbXA7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YWx1ZXM7XG5cdFx0XHRcdHRbd2ViZ2wuTTAwXSA9IHZbd2ViZ2wuTTAwXTtcblx0XHRcdFx0dFt3ZWJnbC5NMDFdID0gdlt3ZWJnbC5NMTBdO1xuXHRcdFx0XHR0W3dlYmdsLk0wMl0gPSB2W3dlYmdsLk0yMF07XG5cdFx0XHRcdHRbd2ViZ2wuTTAzXSA9IHZbd2ViZ2wuTTMwXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTBdID0gdlt3ZWJnbC5NMDFdO1xuXHRcdFx0XHR0W3dlYmdsLk0xMV0gPSB2W3dlYmdsLk0xMV07XG5cdFx0XHRcdHRbd2ViZ2wuTTEyXSA9IHZbd2ViZ2wuTTIxXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTNdID0gdlt3ZWJnbC5NMzFdO1xuXHRcdFx0XHR0W3dlYmdsLk0yMF0gPSB2W3dlYmdsLk0wMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTIxXSA9IHZbd2ViZ2wuTTEyXTtcblx0XHRcdFx0dFt3ZWJnbC5NMjJdID0gdlt3ZWJnbC5NMjJdO1xuXHRcdFx0XHR0W3dlYmdsLk0yM10gPSB2W3dlYmdsLk0zMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTMwXSA9IHZbd2ViZ2wuTTAzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMzFdID0gdlt3ZWJnbC5NMTNdO1xuXHRcdFx0XHR0W3dlYmdsLk0zMl0gPSB2W3dlYmdsLk0yM107XG5cdFx0XHRcdHRbd2ViZ2wuTTMzXSA9IHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHQpO1xuXHRcdFx0fTtcblx0XHRcdE1hdHJpeDQucHJvdG90eXBlLmlkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2W3dlYmdsLk0wMF0gPSAxO1xuXHRcdFx0XHR2W3dlYmdsLk0wMV0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0wMl0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0wM10gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0xMF0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0xMV0gPSAxO1xuXHRcdFx0XHR2W3dlYmdsLk0xMl0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0xM10gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0yMF0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0yMV0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0yMl0gPSAxO1xuXHRcdFx0XHR2W3dlYmdsLk0yM10gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0zMF0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0zMV0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0zMl0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0zM10gPSAxO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YWx1ZXM7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50ZW1wO1xuXHRcdFx0XHR2YXIgbF9kZXQgPSB2W3dlYmdsLk0zMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0wM10gLSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0wM10gLSB2W3dlYmdsLk0zMF0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0wM11cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTAzXSArIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTAzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTAzXVxuXHRcdFx0XHRcdC0gdlt3ZWJnbC5NMzBdICogdlt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzFdICogdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMzBdICogdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMTNdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0zMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0xM10gLSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0zMl0gKiB2W3dlYmdsLk0xM10gKyB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMl0gKiB2W3dlYmdsLk0xM11cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSAtIHZbd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIzXVxuXHRcdFx0XHRcdCsgdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMzFdICogdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjNdICsgdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMzJdICogdlt3ZWJnbC5NMjNdIC0gdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMzJdICogdlt3ZWJnbC5NMjNdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0zM10gKyB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0zM10gKyB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0zM11cblx0XHRcdFx0XHQtIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTMzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMzXSArIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0aWYgKGxfZGV0ID09IDApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9uLWludmVydGlibGUgbWF0cml4XCIpO1xuXHRcdFx0XHR2YXIgaW52X2RldCA9IDEuMCAvIGxfZGV0O1xuXHRcdFx0XHR0W3dlYmdsLk0wMF0gPSB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zMV0gLSB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0zMV0gKyB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMl1cblx0XHRcdFx0XHQtIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIzXSAqIHZbd2ViZ2wuTTMyXSAtIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMzXSArIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMDFdID0gdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMzFdIC0gdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMjNdICogdlt3ZWJnbC5NMzFdIC0gdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMzJdXG5cdFx0XHRcdFx0KyB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zMl0gKyB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zM10gLSB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0zM107XG5cdFx0XHRcdHRbd2ViZ2wuTTAyXSA9IHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTMxXSAtIHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTMxXSArIHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTMyXVxuXHRcdFx0XHRcdC0gdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMzJdIC0gdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMzNdICsgdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMzNdO1xuXHRcdFx0XHR0W3dlYmdsLk0wM10gPSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMV0gLSB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0yMV0gLSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0yMl1cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTIyXSArIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIzXSAtIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTBdID0gdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMzBdIC0gdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjNdICogdlt3ZWJnbC5NMzBdIC0gdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzJdXG5cdFx0XHRcdFx0KyB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zMl0gKyB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zM10gLSB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0zM107XG5cdFx0XHRcdHRbd2ViZ2wuTTExXSA9IHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSAqIHZbd2ViZ2wuTTMwXSAtIHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMwXSArIHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTMyXVxuXHRcdFx0XHRcdC0gdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMjNdICogdlt3ZWJnbC5NMzJdIC0gdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzNdICsgdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMzNdO1xuXHRcdFx0XHR0W3dlYmdsLk0xMl0gPSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0zMl1cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTMyXSArIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMzXSAtIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTNdID0gdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMjBdIC0gdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjBdICsgdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMjJdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0yMl0gLSB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yM10gKyB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yM107XG5cdFx0XHRcdHRbd2ViZ2wuTTIwXSA9IHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIzXSAqIHZbd2ViZ2wuTTMwXSAtIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMwXSArIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTMxXVxuXHRcdFx0XHRcdC0gdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMjNdICogdlt3ZWJnbC5NMzFdIC0gdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzNdICsgdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMzNdO1xuXHRcdFx0XHR0W3dlYmdsLk0yMV0gPSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0wM10gKiB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zMV1cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTIzXSAqIHZbd2ViZ2wuTTMxXSArIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTMzXSAtIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMjJdID0gdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMzBdIC0gdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMzBdICsgdlt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMzFdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0xM10gKiB2W3dlYmdsLk0zMV0gLSB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0zM10gKyB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0zM107XG5cdFx0XHRcdHRbd2ViZ2wuTTIzXSA9IHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIwXSAtIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTIwXSAtIHZbd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIxXVxuXHRcdFx0XHRcdCsgdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMjFdICsgdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMjNdIC0gdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMjNdO1xuXHRcdFx0XHR0W3dlYmdsLk0zMF0gPSB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0zMF0gLSB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zMV1cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMxXSArIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTMyXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMyXTtcblx0XHRcdFx0dFt3ZWJnbC5NMzFdID0gdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMzBdIC0gdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMzBdICsgdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzFdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0zMV0gLSB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zMl0gKyB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTMyXSA9IHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTMwXSAtIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTMwXSAtIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMxXVxuXHRcdFx0XHRcdCsgdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMzFdICsgdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMzJdIC0gdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMzJdO1xuXHRcdFx0XHR0W3dlYmdsLk0zM10gPSB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMF0gLSB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0yMF0gKyB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yMV1cblx0XHRcdFx0XHQtIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIxXSAtIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIyXSArIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIyXTtcblx0XHRcdFx0dlt3ZWJnbC5NMDBdID0gdFt3ZWJnbC5NMDBdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMDFdID0gdFt3ZWJnbC5NMDFdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMDJdID0gdFt3ZWJnbC5NMDJdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMDNdID0gdFt3ZWJnbC5NMDNdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMTBdID0gdFt3ZWJnbC5NMTBdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMTFdID0gdFt3ZWJnbC5NMTFdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMTJdID0gdFt3ZWJnbC5NMTJdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMTNdID0gdFt3ZWJnbC5NMTNdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMjBdID0gdFt3ZWJnbC5NMjBdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMjFdID0gdFt3ZWJnbC5NMjFdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMjJdID0gdFt3ZWJnbC5NMjJdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMjNdID0gdFt3ZWJnbC5NMjNdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMzBdID0gdFt3ZWJnbC5NMzBdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMzFdID0gdFt3ZWJnbC5NMzFdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMzJdID0gdFt3ZWJnbC5NMzJdICogaW52X2RldDtcblx0XHRcdFx0dlt3ZWJnbC5NMzNdID0gdFt3ZWJnbC5NMzNdICogaW52X2RldDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0TWF0cml4NC5wcm90b3R5cGUuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YWx1ZXM7XG5cdFx0XHRcdHJldHVybiB2W3dlYmdsLk0zMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0wM10gLSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0zMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0wM10gLSB2W3dlYmdsLk0zMF0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0wM11cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTAzXSArIHZbd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTAzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTAzXVxuXHRcdFx0XHRcdC0gdlt3ZWJnbC5NMzBdICogdlt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMzFdICogdlt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMzBdICogdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMTNdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0zMV0gKiB2W3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0xM10gLSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0zMl0gKiB2W3dlYmdsLk0xM10gKyB2W3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0zMl0gKiB2W3dlYmdsLk0xM11cblx0XHRcdFx0XHQrIHZbd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSAtIHZbd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIzXVxuXHRcdFx0XHRcdCsgdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMzFdICogdlt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjNdICsgdlt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMzJdICogdlt3ZWJnbC5NMjNdIC0gdlt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMzJdICogdlt3ZWJnbC5NMjNdXG5cdFx0XHRcdFx0LSB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0zM10gKyB2W3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0zM10gKyB2W3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0zM11cblx0XHRcdFx0XHQtIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTMzXSAtIHZbd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMzXSArIHZbd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2W3dlYmdsLk0wM10gKz0geDtcblx0XHRcdFx0dlt3ZWJnbC5NMTNdICs9IHk7XG5cdFx0XHRcdHZbd2ViZ2wuTTIzXSArPSB6O1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5zZXQodGhpcy52YWx1ZXMpO1xuXHRcdFx0fTtcblx0XHRcdE1hdHJpeDQucHJvdG90eXBlLnByb2plY3Rpb24gPSBmdW5jdGlvbiAobmVhciwgZmFyLCBmb3Z5LCBhc3BlY3RSYXRpbykge1xuXHRcdFx0XHR0aGlzLmlkZW50aXR5KCk7XG5cdFx0XHRcdHZhciBsX2ZkID0gKDEuMCAvIE1hdGgudGFuKChmb3Z5ICogKE1hdGguUEkgLyAxODApKSAvIDIuMCkpO1xuXHRcdFx0XHR2YXIgbF9hMSA9IChmYXIgKyBuZWFyKSAvIChuZWFyIC0gZmFyKTtcblx0XHRcdFx0dmFyIGxfYTIgPSAoMiAqIGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2W3dlYmdsLk0wMF0gPSBsX2ZkIC8gYXNwZWN0UmF0aW87XG5cdFx0XHRcdHZbd2ViZ2wuTTEwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTIwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTMwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTAxXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTExXSA9IGxfZmQ7XG5cdFx0XHRcdHZbd2ViZ2wuTTIxXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTMxXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTAyXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTEyXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTIyXSA9IGxfYTE7XG5cdFx0XHRcdHZbd2ViZ2wuTTMyXSA9IC0xO1xuXHRcdFx0XHR2W3dlYmdsLk0wM10gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0xM10gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0yM10gPSBsX2EyO1xuXHRcdFx0XHR2W3dlYmdsLk0zM10gPSAwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5vcnRobzJkID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3J0aG8oeCwgeCArIHdpZHRoLCB5LCB5ICsgaGVpZ2h0LCAwLCAxKTtcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5vcnRobyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuXHRcdFx0XHR0aGlzLmlkZW50aXR5KCk7XG5cdFx0XHRcdHZhciB4X29ydGggPSAyIC8gKHJpZ2h0IC0gbGVmdCk7XG5cdFx0XHRcdHZhciB5X29ydGggPSAyIC8gKHRvcCAtIGJvdHRvbSk7XG5cdFx0XHRcdHZhciB6X29ydGggPSAtMiAvIChmYXIgLSBuZWFyKTtcblx0XHRcdFx0dmFyIHR4ID0gLShyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCk7XG5cdFx0XHRcdHZhciB0eSA9IC0odG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xuXHRcdFx0XHR2YXIgdHogPSAtKGZhciArIG5lYXIpIC8gKGZhciAtIG5lYXIpO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2W3dlYmdsLk0wMF0gPSB4X29ydGg7XG5cdFx0XHRcdHZbd2ViZ2wuTTEwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTIwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTMwXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTAxXSA9IDA7XG5cdFx0XHRcdHZbd2ViZ2wuTTExXSA9IHlfb3J0aDtcblx0XHRcdFx0dlt3ZWJnbC5NMjFdID0gMDtcblx0XHRcdFx0dlt3ZWJnbC5NMzFdID0gMDtcblx0XHRcdFx0dlt3ZWJnbC5NMDJdID0gMDtcblx0XHRcdFx0dlt3ZWJnbC5NMTJdID0gMDtcblx0XHRcdFx0dlt3ZWJnbC5NMjJdID0gel9vcnRoO1xuXHRcdFx0XHR2W3dlYmdsLk0zMl0gPSAwO1xuXHRcdFx0XHR2W3dlYmdsLk0wM10gPSB0eDtcblx0XHRcdFx0dlt3ZWJnbC5NMTNdID0gdHk7XG5cdFx0XHRcdHZbd2ViZ2wuTTIzXSA9IHR6O1xuXHRcdFx0XHR2W3dlYmdsLk0zM10gPSAxO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLnRlbXA7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YWx1ZXM7XG5cdFx0XHRcdHZhciBtID0gbWF0cml4LnZhbHVlcztcblx0XHRcdFx0dFt3ZWJnbC5NMDBdID0gdlt3ZWJnbC5NMDBdICogbVt3ZWJnbC5NMDBdICsgdlt3ZWJnbC5NMDFdICogbVt3ZWJnbC5NMTBdICsgdlt3ZWJnbC5NMDJdICogbVt3ZWJnbC5NMjBdICsgdlt3ZWJnbC5NMDNdICogbVt3ZWJnbC5NMzBdO1xuXHRcdFx0XHR0W3dlYmdsLk0wMV0gPSB2W3dlYmdsLk0wMF0gKiBtW3dlYmdsLk0wMV0gKyB2W3dlYmdsLk0wMV0gKiBtW3dlYmdsLk0xMV0gKyB2W3dlYmdsLk0wMl0gKiBtW3dlYmdsLk0yMV0gKyB2W3dlYmdsLk0wM10gKiBtW3dlYmdsLk0zMV07XG5cdFx0XHRcdHRbd2ViZ2wuTTAyXSA9IHZbd2ViZ2wuTTAwXSAqIG1bd2ViZ2wuTTAyXSArIHZbd2ViZ2wuTTAxXSAqIG1bd2ViZ2wuTTEyXSArIHZbd2ViZ2wuTTAyXSAqIG1bd2ViZ2wuTTIyXSArIHZbd2ViZ2wuTTAzXSAqIG1bd2ViZ2wuTTMyXTtcblx0XHRcdFx0dFt3ZWJnbC5NMDNdID0gdlt3ZWJnbC5NMDBdICogbVt3ZWJnbC5NMDNdICsgdlt3ZWJnbC5NMDFdICogbVt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMDJdICogbVt3ZWJnbC5NMjNdICsgdlt3ZWJnbC5NMDNdICogbVt3ZWJnbC5NMzNdO1xuXHRcdFx0XHR0W3dlYmdsLk0xMF0gPSB2W3dlYmdsLk0xMF0gKiBtW3dlYmdsLk0wMF0gKyB2W3dlYmdsLk0xMV0gKiBtW3dlYmdsLk0xMF0gKyB2W3dlYmdsLk0xMl0gKiBtW3dlYmdsLk0yMF0gKyB2W3dlYmdsLk0xM10gKiBtW3dlYmdsLk0zMF07XG5cdFx0XHRcdHRbd2ViZ2wuTTExXSA9IHZbd2ViZ2wuTTEwXSAqIG1bd2ViZ2wuTTAxXSArIHZbd2ViZ2wuTTExXSAqIG1bd2ViZ2wuTTExXSArIHZbd2ViZ2wuTTEyXSAqIG1bd2ViZ2wuTTIxXSArIHZbd2ViZ2wuTTEzXSAqIG1bd2ViZ2wuTTMxXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTJdID0gdlt3ZWJnbC5NMTBdICogbVt3ZWJnbC5NMDJdICsgdlt3ZWJnbC5NMTFdICogbVt3ZWJnbC5NMTJdICsgdlt3ZWJnbC5NMTJdICogbVt3ZWJnbC5NMjJdICsgdlt3ZWJnbC5NMTNdICogbVt3ZWJnbC5NMzJdO1xuXHRcdFx0XHR0W3dlYmdsLk0xM10gPSB2W3dlYmdsLk0xMF0gKiBtW3dlYmdsLk0wM10gKyB2W3dlYmdsLk0xMV0gKiBtW3dlYmdsLk0xM10gKyB2W3dlYmdsLk0xMl0gKiBtW3dlYmdsLk0yM10gKyB2W3dlYmdsLk0xM10gKiBtW3dlYmdsLk0zM107XG5cdFx0XHRcdHRbd2ViZ2wuTTIwXSA9IHZbd2ViZ2wuTTIwXSAqIG1bd2ViZ2wuTTAwXSArIHZbd2ViZ2wuTTIxXSAqIG1bd2ViZ2wuTTEwXSArIHZbd2ViZ2wuTTIyXSAqIG1bd2ViZ2wuTTIwXSArIHZbd2ViZ2wuTTIzXSAqIG1bd2ViZ2wuTTMwXTtcblx0XHRcdFx0dFt3ZWJnbC5NMjFdID0gdlt3ZWJnbC5NMjBdICogbVt3ZWJnbC5NMDFdICsgdlt3ZWJnbC5NMjFdICogbVt3ZWJnbC5NMTFdICsgdlt3ZWJnbC5NMjJdICogbVt3ZWJnbC5NMjFdICsgdlt3ZWJnbC5NMjNdICogbVt3ZWJnbC5NMzFdO1xuXHRcdFx0XHR0W3dlYmdsLk0yMl0gPSB2W3dlYmdsLk0yMF0gKiBtW3dlYmdsLk0wMl0gKyB2W3dlYmdsLk0yMV0gKiBtW3dlYmdsLk0xMl0gKyB2W3dlYmdsLk0yMl0gKiBtW3dlYmdsLk0yMl0gKyB2W3dlYmdsLk0yM10gKiBtW3dlYmdsLk0zMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTIzXSA9IHZbd2ViZ2wuTTIwXSAqIG1bd2ViZ2wuTTAzXSArIHZbd2ViZ2wuTTIxXSAqIG1bd2ViZ2wuTTEzXSArIHZbd2ViZ2wuTTIyXSAqIG1bd2ViZ2wuTTIzXSArIHZbd2ViZ2wuTTIzXSAqIG1bd2ViZ2wuTTMzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMzBdID0gdlt3ZWJnbC5NMzBdICogbVt3ZWJnbC5NMDBdICsgdlt3ZWJnbC5NMzFdICogbVt3ZWJnbC5NMTBdICsgdlt3ZWJnbC5NMzJdICogbVt3ZWJnbC5NMjBdICsgdlt3ZWJnbC5NMzNdICogbVt3ZWJnbC5NMzBdO1xuXHRcdFx0XHR0W3dlYmdsLk0zMV0gPSB2W3dlYmdsLk0zMF0gKiBtW3dlYmdsLk0wMV0gKyB2W3dlYmdsLk0zMV0gKiBtW3dlYmdsLk0xMV0gKyB2W3dlYmdsLk0zMl0gKiBtW3dlYmdsLk0yMV0gKyB2W3dlYmdsLk0zM10gKiBtW3dlYmdsLk0zMV07XG5cdFx0XHRcdHRbd2ViZ2wuTTMyXSA9IHZbd2ViZ2wuTTMwXSAqIG1bd2ViZ2wuTTAyXSArIHZbd2ViZ2wuTTMxXSAqIG1bd2ViZ2wuTTEyXSArIHZbd2ViZ2wuTTMyXSAqIG1bd2ViZ2wuTTIyXSArIHZbd2ViZ2wuTTMzXSAqIG1bd2ViZ2wuTTMyXTtcblx0XHRcdFx0dFt3ZWJnbC5NMzNdID0gdlt3ZWJnbC5NMzBdICogbVt3ZWJnbC5NMDNdICsgdlt3ZWJnbC5NMzFdICogbVt3ZWJnbC5NMTNdICsgdlt3ZWJnbC5NMzJdICogbVt3ZWJnbC5NMjNdICsgdlt3ZWJnbC5NMzNdICogbVt3ZWJnbC5NMzNdO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQodGhpcy50ZW1wKTtcblx0XHRcdH07XG5cdFx0XHRNYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseUxlZnQgPSBmdW5jdGlvbiAobWF0cml4KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50ZW1wO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2YXIgbSA9IG1hdHJpeC52YWx1ZXM7XG5cdFx0XHRcdHRbd2ViZ2wuTTAwXSA9IG1bd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTAwXSArIG1bd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEwXSArIG1bd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIwXSArIG1bd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTMwXTtcblx0XHRcdFx0dFt3ZWJnbC5NMDFdID0gbVt3ZWJnbC5NMDBdICogdlt3ZWJnbC5NMDFdICsgbVt3ZWJnbC5NMDFdICogdlt3ZWJnbC5NMTFdICsgbVt3ZWJnbC5NMDJdICogdlt3ZWJnbC5NMjFdICsgbVt3ZWJnbC5NMDNdICogdlt3ZWJnbC5NMzFdO1xuXHRcdFx0XHR0W3dlYmdsLk0wMl0gPSBtW3dlYmdsLk0wMF0gKiB2W3dlYmdsLk0wMl0gKyBtW3dlYmdsLk0wMV0gKiB2W3dlYmdsLk0xMl0gKyBtW3dlYmdsLk0wMl0gKiB2W3dlYmdsLk0yMl0gKyBtW3dlYmdsLk0wM10gKiB2W3dlYmdsLk0zMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTAzXSA9IG1bd2ViZ2wuTTAwXSAqIHZbd2ViZ2wuTTAzXSArIG1bd2ViZ2wuTTAxXSAqIHZbd2ViZ2wuTTEzXSArIG1bd2ViZ2wuTTAyXSAqIHZbd2ViZ2wuTTIzXSArIG1bd2ViZ2wuTTAzXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTBdID0gbVt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMDBdICsgbVt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMTBdICsgbVt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjBdICsgbVt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMzBdO1xuXHRcdFx0XHR0W3dlYmdsLk0xMV0gPSBtW3dlYmdsLk0xMF0gKiB2W3dlYmdsLk0wMV0gKyBtW3dlYmdsLk0xMV0gKiB2W3dlYmdsLk0xMV0gKyBtW3dlYmdsLk0xMl0gKiB2W3dlYmdsLk0yMV0gKyBtW3dlYmdsLk0xM10gKiB2W3dlYmdsLk0zMV07XG5cdFx0XHRcdHRbd2ViZ2wuTTEyXSA9IG1bd2ViZ2wuTTEwXSAqIHZbd2ViZ2wuTTAyXSArIG1bd2ViZ2wuTTExXSAqIHZbd2ViZ2wuTTEyXSArIG1bd2ViZ2wuTTEyXSAqIHZbd2ViZ2wuTTIyXSArIG1bd2ViZ2wuTTEzXSAqIHZbd2ViZ2wuTTMyXTtcblx0XHRcdFx0dFt3ZWJnbC5NMTNdID0gbVt3ZWJnbC5NMTBdICogdlt3ZWJnbC5NMDNdICsgbVt3ZWJnbC5NMTFdICogdlt3ZWJnbC5NMTNdICsgbVt3ZWJnbC5NMTJdICogdlt3ZWJnbC5NMjNdICsgbVt3ZWJnbC5NMTNdICogdlt3ZWJnbC5NMzNdO1xuXHRcdFx0XHR0W3dlYmdsLk0yMF0gPSBtW3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wMF0gKyBtW3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0xMF0gKyBtW3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0yMF0gKyBtW3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zMF07XG5cdFx0XHRcdHRbd2ViZ2wuTTIxXSA9IG1bd2ViZ2wuTTIwXSAqIHZbd2ViZ2wuTTAxXSArIG1bd2ViZ2wuTTIxXSAqIHZbd2ViZ2wuTTExXSArIG1bd2ViZ2wuTTIyXSAqIHZbd2ViZ2wuTTIxXSArIG1bd2ViZ2wuTTIzXSAqIHZbd2ViZ2wuTTMxXTtcblx0XHRcdFx0dFt3ZWJnbC5NMjJdID0gbVt3ZWJnbC5NMjBdICogdlt3ZWJnbC5NMDJdICsgbVt3ZWJnbC5NMjFdICogdlt3ZWJnbC5NMTJdICsgbVt3ZWJnbC5NMjJdICogdlt3ZWJnbC5NMjJdICsgbVt3ZWJnbC5NMjNdICogdlt3ZWJnbC5NMzJdO1xuXHRcdFx0XHR0W3dlYmdsLk0yM10gPSBtW3dlYmdsLk0yMF0gKiB2W3dlYmdsLk0wM10gKyBtW3dlYmdsLk0yMV0gKiB2W3dlYmdsLk0xM10gKyBtW3dlYmdsLk0yMl0gKiB2W3dlYmdsLk0yM10gKyBtW3dlYmdsLk0yM10gKiB2W3dlYmdsLk0zM107XG5cdFx0XHRcdHRbd2ViZ2wuTTMwXSA9IG1bd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTAwXSArIG1bd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTEwXSArIG1bd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTIwXSArIG1bd2ViZ2wuTTMzXSAqIHZbd2ViZ2wuTTMwXTtcblx0XHRcdFx0dFt3ZWJnbC5NMzFdID0gbVt3ZWJnbC5NMzBdICogdlt3ZWJnbC5NMDFdICsgbVt3ZWJnbC5NMzFdICogdlt3ZWJnbC5NMTFdICsgbVt3ZWJnbC5NMzJdICogdlt3ZWJnbC5NMjFdICsgbVt3ZWJnbC5NMzNdICogdlt3ZWJnbC5NMzFdO1xuXHRcdFx0XHR0W3dlYmdsLk0zMl0gPSBtW3dlYmdsLk0zMF0gKiB2W3dlYmdsLk0wMl0gKyBtW3dlYmdsLk0zMV0gKiB2W3dlYmdsLk0xMl0gKyBtW3dlYmdsLk0zMl0gKiB2W3dlYmdsLk0yMl0gKyBtW3dlYmdsLk0zM10gKiB2W3dlYmdsLk0zMl07XG5cdFx0XHRcdHRbd2ViZ2wuTTMzXSA9IG1bd2ViZ2wuTTMwXSAqIHZbd2ViZ2wuTTAzXSArIG1bd2ViZ2wuTTMxXSAqIHZbd2ViZ2wuTTEzXSArIG1bd2ViZ2wuTTMyXSAqIHZbd2ViZ2wuTTIzXSArIG1bd2ViZ2wuTTMzXSAqIHZbd2ViZ2wuTTMzXTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHRoaXMudGVtcCk7XG5cdFx0XHR9O1xuXHRcdFx0TWF0cml4NC5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkaXJlY3Rpb24sIHVwKSB7XG5cdFx0XHRcdE1hdHJpeDQuaW5pdFRlbXBzKCk7XG5cdFx0XHRcdHZhciB4QXhpcyA9IE1hdHJpeDQueEF4aXMsIHlBeGlzID0gTWF0cml4NC55QXhpcywgekF4aXMgPSBNYXRyaXg0LnpBeGlzO1xuXHRcdFx0XHR6QXhpcy5zZXRGcm9tKGRpcmVjdGlvbikubm9ybWFsaXplKCk7XG5cdFx0XHRcdHhBeGlzLnNldEZyb20oZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0eEF4aXMuY3Jvc3ModXApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHR5QXhpcy5zZXRGcm9tKHhBeGlzKS5jcm9zcyh6QXhpcykubm9ybWFsaXplKCk7XG5cdFx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblx0XHRcdFx0dmFyIHZhbCA9IHRoaXMudmFsdWVzO1xuXHRcdFx0XHR2YWxbd2ViZ2wuTTAwXSA9IHhBeGlzLng7XG5cdFx0XHRcdHZhbFt3ZWJnbC5NMDFdID0geEF4aXMueTtcblx0XHRcdFx0dmFsW3dlYmdsLk0wMl0gPSB4QXhpcy56O1xuXHRcdFx0XHR2YWxbd2ViZ2wuTTEwXSA9IHlBeGlzLng7XG5cdFx0XHRcdHZhbFt3ZWJnbC5NMTFdID0geUF4aXMueTtcblx0XHRcdFx0dmFsW3dlYmdsLk0xMl0gPSB5QXhpcy56O1xuXHRcdFx0XHR2YWxbd2ViZ2wuTTIwXSA9IC16QXhpcy54O1xuXHRcdFx0XHR2YWxbd2ViZ2wuTTIxXSA9IC16QXhpcy55O1xuXHRcdFx0XHR2YWxbd2ViZ2wuTTIyXSA9IC16QXhpcy56O1xuXHRcdFx0XHRNYXRyaXg0LnRtcE1hdHJpeC5pZGVudGl0eSgpO1xuXHRcdFx0XHRNYXRyaXg0LnRtcE1hdHJpeC52YWx1ZXNbd2ViZ2wuTTAzXSA9IC1wb3NpdGlvbi54O1xuXHRcdFx0XHRNYXRyaXg0LnRtcE1hdHJpeC52YWx1ZXNbd2ViZ2wuTTEzXSA9IC1wb3NpdGlvbi55O1xuXHRcdFx0XHRNYXRyaXg0LnRtcE1hdHJpeC52YWx1ZXNbd2ViZ2wuTTIzXSA9IC1wb3NpdGlvbi56O1xuXHRcdFx0XHR0aGlzLm11bHRpcGx5KE1hdHJpeDQudG1wTWF0cml4KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0TWF0cml4NC5pbml0VGVtcHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChNYXRyaXg0LnhBeGlzID09PSBudWxsKVxuXHRcdFx0XHRcdE1hdHJpeDQueEF4aXMgPSBuZXcgd2ViZ2wuVmVjdG9yMygpO1xuXHRcdFx0XHRpZiAoTWF0cml4NC55QXhpcyA9PT0gbnVsbClcblx0XHRcdFx0XHRNYXRyaXg0LnlBeGlzID0gbmV3IHdlYmdsLlZlY3RvcjMoKTtcblx0XHRcdFx0aWYgKE1hdHJpeDQuekF4aXMgPT09IG51bGwpXG5cdFx0XHRcdFx0TWF0cml4NC56QXhpcyA9IG5ldyB3ZWJnbC5WZWN0b3IzKCk7XG5cdFx0XHR9O1xuXHRcdFx0TWF0cml4NC54QXhpcyA9IG51bGw7XG5cdFx0XHRNYXRyaXg0LnlBeGlzID0gbnVsbDtcblx0XHRcdE1hdHJpeDQuekF4aXMgPSBudWxsO1xuXHRcdFx0TWF0cml4NC50bXBNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0cmV0dXJuIE1hdHJpeDQ7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5NYXRyaXg0ID0gTWF0cml4NDtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIHdlYmdsO1xuXHQoZnVuY3Rpb24gKHdlYmdsKSB7XG5cdFx0dmFyIE1lc2ggPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ZnVuY3Rpb24gTWVzaChjb250ZXh0LCBhdHRyaWJ1dGVzLCBtYXhWZXJ0aWNlcywgbWF4SW5kaWNlcykge1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXHRcdFx0XHR0aGlzLnZlcnRpY2VzTGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5kaXJ0eVZlcnRpY2VzID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuaW5kaWNlc0xlbmd0aCA9IDA7XG5cdFx0XHRcdHRoaXMuZGlydHlJbmRpY2VzID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZWxlbWVudHNQZXJWZXJ0ZXggPSAwO1xuXHRcdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2Ygd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/IGNvbnRleHQgOiBuZXcgd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dChjb250ZXh0KTtcblx0XHRcdFx0dGhpcy5lbGVtZW50c1BlclZlcnRleCA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNQZXJWZXJ0ZXggKz0gYXR0cmlidXRlc1tpXS5udW1FbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShtYXhWZXJ0aWNlcyAqIHRoaXMuZWxlbWVudHNQZXJWZXJ0ZXgpO1xuXHRcdFx0XHR0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobWF4SW5kaWNlcyk7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5hZGRSZXN0b3JhYmxlKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0TWVzaC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYXR0cmlidXRlczsgfTtcblx0XHRcdE1lc2gucHJvdG90eXBlLm1heFZlcnRpY2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyB0aGlzLmVsZW1lbnRzUGVyVmVydGV4OyB9O1xuXHRcdFx0TWVzaC5wcm90b3R5cGUubnVtVmVydGljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZlcnRpY2VzTGVuZ3RoIC8gdGhpcy5lbGVtZW50c1BlclZlcnRleDsgfTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnNldFZlcnRpY2VzTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLmRpcnR5VmVydGljZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnZlcnRpY2VzTGVuZ3RoID0gbGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmdldFZlcnRpY2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNlczsgfTtcblx0XHRcdE1lc2gucHJvdG90eXBlLm1heEluZGljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGljZXMubGVuZ3RoOyB9O1xuXHRcdFx0TWVzaC5wcm90b3R5cGUubnVtSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kaWNlc0xlbmd0aDsgfTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnNldEluZGljZXNMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuZGlydHlJbmRpY2VzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5pbmRpY2VzTGVuZ3RoID0gbGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmdldEluZGljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGljZXM7IH07XG5cdFx0XHQ7XG5cdFx0XHRNZXNoLnByb3RvdHlwZS5nZXRWZXJ0ZXhTaXplSW5GbG9hdHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBzaXplID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuXHRcdFx0XHRcdHNpemUgKz0gYXR0cmlidXRlLm51bUVsZW1lbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzaXplO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnNldFZlcnRpY2VzID0gZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG5cdFx0XHRcdHRoaXMuZGlydHlWZXJ0aWNlcyA9IHRydWU7XG5cdFx0XHRcdGlmICh2ZXJ0aWNlcy5sZW5ndGggPiB0aGlzLnZlcnRpY2VzLmxlbmd0aClcblx0XHRcdFx0XHR0aHJvdyBFcnJvcihcIk1lc2ggY2FuJ3Qgc3RvcmUgbW9yZSB0aGFuIFwiICsgdGhpcy5tYXhWZXJ0aWNlcygpICsgXCIgdmVydGljZXNcIik7XG5cdFx0XHRcdHRoaXMudmVydGljZXMuc2V0KHZlcnRpY2VzLCAwKTtcblx0XHRcdFx0dGhpcy52ZXJ0aWNlc0xlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRNZXNoLnByb3RvdHlwZS5zZXRJbmRpY2VzID0gZnVuY3Rpb24gKGluZGljZXMpIHtcblx0XHRcdFx0dGhpcy5kaXJ0eUluZGljZXMgPSB0cnVlO1xuXHRcdFx0XHRpZiAoaW5kaWNlcy5sZW5ndGggPiB0aGlzLmluZGljZXMubGVuZ3RoKVxuXHRcdFx0XHRcdHRocm93IEVycm9yKFwiTWVzaCBjYW4ndCBzdG9yZSBtb3JlIHRoYW4gXCIgKyB0aGlzLm1heEluZGljZXMoKSArIFwiIGluZGljZXNcIik7XG5cdFx0XHRcdHRoaXMuaW5kaWNlcy5zZXQoaW5kaWNlcywgMCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNlc0xlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoc2hhZGVyLCBwcmltaXRpdmVUeXBlKSB7XG5cdFx0XHRcdHRoaXMuZHJhd1dpdGhPZmZzZXQoc2hhZGVyLCBwcmltaXRpdmVUeXBlLCAwLCB0aGlzLmluZGljZXNMZW5ndGggPiAwID8gdGhpcy5pbmRpY2VzTGVuZ3RoIDogdGhpcy52ZXJ0aWNlc0xlbmd0aCAvIHRoaXMuZWxlbWVudHNQZXJWZXJ0ZXgpO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmRyYXdXaXRoT2Zmc2V0ID0gZnVuY3Rpb24gKHNoYWRlciwgcHJpbWl0aXZlVHlwZSwgb2Zmc2V0LCBjb3VudCkge1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdGlmICh0aGlzLmRpcnR5VmVydGljZXMgfHwgdGhpcy5kaXJ0eUluZGljZXMpXG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0dGhpcy5iaW5kKHNoYWRlcik7XG5cdFx0XHRcdGlmICh0aGlzLmluZGljZXNMZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKHByaW1pdGl2ZVR5cGUsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgb2Zmc2V0ICogMik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Z2wuZHJhd0FycmF5cyhwcmltaXRpdmVUeXBlLCBvZmZzZXQsIGNvdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuYmluZChzaGFkZXIpO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoc2hhZGVyKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXNCdWZmZXIpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuXHRcdFx0XHRcdHZhciBsb2NhdGlvbl8xID0gc2hhZGVyLmdldEF0dHJpYnV0ZUxvY2F0aW9uKGF0dHJpYi5uYW1lKTtcblx0XHRcdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbl8xKTtcblx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uXzEsIGF0dHJpYi5udW1FbGVtZW50cywgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLmVsZW1lbnRzUGVyVmVydGV4ICogNCwgb2Zmc2V0ICogNCk7XG5cdFx0XHRcdFx0b2Zmc2V0ICs9IGF0dHJpYi5udW1FbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5pbmRpY2VzTGVuZ3RoID4gMClcblx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXNCdWZmZXIpO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChzaGFkZXIpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG5cdFx0XHRcdFx0dmFyIGxvY2F0aW9uXzIgPSBzaGFkZXIuZ2V0QXR0cmlidXRlTG9jYXRpb24oYXR0cmliLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbl8yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdGlmICh0aGlzLmluZGljZXNMZW5ndGggPiAwKVxuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHRpZiAodGhpcy5kaXJ0eVZlcnRpY2VzKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnZlcnRpY2VzQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2VzQnVmZmVyKTtcblx0XHRcdFx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcy5zdWJhcnJheSgwLCB0aGlzLnZlcnRpY2VzTGVuZ3RoKSwgZ2wuRFlOQU1JQ19EUkFXKTtcblx0XHRcdFx0XHR0aGlzLmRpcnR5VmVydGljZXMgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5kaXJ0eUluZGljZXMpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuaW5kaWNlc0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5pbmRpY2VzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlc0J1ZmZlcik7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLnN1YmFycmF5KDAsIHRoaXMuaW5kaWNlc0xlbmd0aCksIGdsLkRZTkFNSUNfRFJBVyk7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eUluZGljZXMgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMudmVydGljZXNCdWZmZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmluZGljZXNCdWZmZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fTtcblx0XHRcdE1lc2gucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5yZW1vdmVSZXN0b3JhYmxlKHRoaXMpO1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRpY2VzQnVmZmVyKTtcblx0XHRcdFx0Z2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kaWNlc0J1ZmZlcik7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIE1lc2g7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5NZXNoID0gTWVzaDtcblx0XHR2YXIgVmVydGV4QXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFZlcnRleEF0dHJpYnV0ZShuYW1lLCB0eXBlLCBudW1FbGVtZW50cykge1xuXHRcdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0XHR0aGlzLm51bUVsZW1lbnRzID0gbnVtRWxlbWVudHM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gVmVydGV4QXR0cmlidXRlO1xuXHRcdH0oKSk7XG5cdFx0d2ViZ2wuVmVydGV4QXR0cmlidXRlID0gVmVydGV4QXR0cmlidXRlO1xuXHRcdHZhciBQb3NpdGlvbjJBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdFx0X19leHRlbmRzKFBvc2l0aW9uMkF0dHJpYnV0ZSwgX3N1cGVyKTtcblx0XHRcdGZ1bmN0aW9uIFBvc2l0aW9uMkF0dHJpYnV0ZSgpIHtcblx0XHRcdFx0X3N1cGVyLmNhbGwodGhpcywgd2ViZ2wuU2hhZGVyLlBPU0lUSU9OLCBWZXJ0ZXhBdHRyaWJ1dGVUeXBlLkZsb2F0LCAyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBQb3NpdGlvbjJBdHRyaWJ1dGU7XG5cdFx0fShWZXJ0ZXhBdHRyaWJ1dGUpKTtcblx0XHR3ZWJnbC5Qb3NpdGlvbjJBdHRyaWJ1dGUgPSBQb3NpdGlvbjJBdHRyaWJ1dGU7XG5cdFx0dmFyIFBvc2l0aW9uM0F0dHJpYnV0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdFx0XHRfX2V4dGVuZHMoUG9zaXRpb24zQXR0cmlidXRlLCBfc3VwZXIpO1xuXHRcdFx0ZnVuY3Rpb24gUG9zaXRpb24zQXR0cmlidXRlKCkge1xuXHRcdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCB3ZWJnbC5TaGFkZXIuUE9TSVRJT04sIFZlcnRleEF0dHJpYnV0ZVR5cGUuRmxvYXQsIDMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFBvc2l0aW9uM0F0dHJpYnV0ZTtcblx0XHR9KFZlcnRleEF0dHJpYnV0ZSkpO1xuXHRcdHdlYmdsLlBvc2l0aW9uM0F0dHJpYnV0ZSA9IFBvc2l0aW9uM0F0dHJpYnV0ZTtcblx0XHR2YXIgVGV4Q29vcmRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHRcdFx0X19leHRlbmRzKFRleENvb3JkQXR0cmlidXRlLCBfc3VwZXIpO1xuXHRcdFx0ZnVuY3Rpb24gVGV4Q29vcmRBdHRyaWJ1dGUodW5pdCkge1xuXHRcdFx0XHRpZiAodW5pdCA9PT0gdm9pZCAwKSB7IHVuaXQgPSAwOyB9XG5cdFx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIHdlYmdsLlNoYWRlci5URVhDT09SRFMgKyAodW5pdCA9PSAwID8gXCJcIiA6IHVuaXQpLCBWZXJ0ZXhBdHRyaWJ1dGVUeXBlLkZsb2F0LCAyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBUZXhDb29yZEF0dHJpYnV0ZTtcblx0XHR9KFZlcnRleEF0dHJpYnV0ZSkpO1xuXHRcdHdlYmdsLlRleENvb3JkQXR0cmlidXRlID0gVGV4Q29vcmRBdHRyaWJ1dGU7XG5cdFx0dmFyIENvbG9yQXR0cmlidXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRcdF9fZXh0ZW5kcyhDb2xvckF0dHJpYnV0ZSwgX3N1cGVyKTtcblx0XHRcdGZ1bmN0aW9uIENvbG9yQXR0cmlidXRlKCkge1xuXHRcdFx0XHRfc3VwZXIuY2FsbCh0aGlzLCB3ZWJnbC5TaGFkZXIuQ09MT1IsIFZlcnRleEF0dHJpYnV0ZVR5cGUuRmxvYXQsIDQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbG9yQXR0cmlidXRlO1xuXHRcdH0oVmVydGV4QXR0cmlidXRlKSk7XG5cdFx0d2ViZ2wuQ29sb3JBdHRyaWJ1dGUgPSBDb2xvckF0dHJpYnV0ZTtcblx0XHR2YXIgQ29sb3IyQXR0cmlidXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0XHRcdF9fZXh0ZW5kcyhDb2xvcjJBdHRyaWJ1dGUsIF9zdXBlcik7XG5cdFx0XHRmdW5jdGlvbiBDb2xvcjJBdHRyaWJ1dGUoKSB7XG5cdFx0XHRcdF9zdXBlci5jYWxsKHRoaXMsIHdlYmdsLlNoYWRlci5DT0xPUjIsIFZlcnRleEF0dHJpYnV0ZVR5cGUuRmxvYXQsIDQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbG9yMkF0dHJpYnV0ZTtcblx0XHR9KFZlcnRleEF0dHJpYnV0ZSkpO1xuXHRcdHdlYmdsLkNvbG9yMkF0dHJpYnV0ZSA9IENvbG9yMkF0dHJpYnV0ZTtcblx0XHQoZnVuY3Rpb24gKFZlcnRleEF0dHJpYnV0ZVR5cGUpIHtcblx0XHRcdFZlcnRleEF0dHJpYnV0ZVR5cGVbVmVydGV4QXR0cmlidXRlVHlwZVtcIkZsb2F0XCJdID0gMF0gPSBcIkZsb2F0XCI7XG5cdFx0fSkod2ViZ2wuVmVydGV4QXR0cmlidXRlVHlwZSB8fCAod2ViZ2wuVmVydGV4QXR0cmlidXRlVHlwZSA9IHt9KSk7XG5cdFx0dmFyIFZlcnRleEF0dHJpYnV0ZVR5cGUgPSB3ZWJnbC5WZXJ0ZXhBdHRyaWJ1dGVUeXBlO1xuXHR9KSh3ZWJnbCA9IHNwaW5lLndlYmdsIHx8IChzcGluZS53ZWJnbCA9IHt9KSk7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgd2ViZ2w7XG5cdChmdW5jdGlvbiAod2ViZ2wpIHtcblx0XHR2YXIgUG9seWdvbkJhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ZnVuY3Rpb24gUG9seWdvbkJhdGNoZXIoY29udGV4dCwgdHdvQ29sb3JUaW50LCBtYXhWZXJ0aWNlcykge1xuXHRcdFx0XHRpZiAodHdvQ29sb3JUaW50ID09PSB2b2lkIDApIHsgdHdvQ29sb3JUaW50ID0gdHJ1ZTsgfVxuXHRcdFx0XHRpZiAobWF4VmVydGljZXMgPT09IHZvaWQgMCkgeyBtYXhWZXJ0aWNlcyA9IDEwOTIwOyB9XG5cdFx0XHRcdHRoaXMuaXNEcmF3aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHRcdFx0dGhpcy5sYXN0VGV4dHVyZSA9IG51bGw7XG5cdFx0XHRcdHRoaXMudmVydGljZXNMZW5ndGggPSAwO1xuXHRcdFx0XHR0aGlzLmluZGljZXNMZW5ndGggPSAwO1xuXHRcdFx0XHRpZiAobWF4VmVydGljZXMgPiAxMDkyMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYXZlIG1vcmUgdGhhbiAxMDkyMCB0cmlhbmdsZXMgcGVyIGJhdGNoOiBcIiArIG1heFZlcnRpY2VzKTtcblx0XHRcdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIHdlYmdsLk1hbmFnZWRXZWJHTFJlbmRlcmluZ0NvbnRleHQgPyBjb250ZXh0IDogbmV3IHdlYmdsLk1hbmFnZWRXZWJHTFJlbmRlcmluZ0NvbnRleHQoY29udGV4dCk7XG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gdHdvQ29sb3JUaW50ID9cblx0XHRcdFx0XHRbbmV3IHdlYmdsLlBvc2l0aW9uMkF0dHJpYnV0ZSgpLCBuZXcgd2ViZ2wuQ29sb3JBdHRyaWJ1dGUoKSwgbmV3IHdlYmdsLlRleENvb3JkQXR0cmlidXRlKCksIG5ldyB3ZWJnbC5Db2xvcjJBdHRyaWJ1dGUoKV0gOlxuXHRcdFx0XHRcdFtuZXcgd2ViZ2wuUG9zaXRpb24yQXR0cmlidXRlKCksIG5ldyB3ZWJnbC5Db2xvckF0dHJpYnV0ZSgpLCBuZXcgd2ViZ2wuVGV4Q29vcmRBdHRyaWJ1dGUoKV07XG5cdFx0XHRcdHRoaXMubWVzaCA9IG5ldyB3ZWJnbC5NZXNoKGNvbnRleHQsIGF0dHJpYnV0ZXMsIG1heFZlcnRpY2VzLCBtYXhWZXJ0aWNlcyAqIDMpO1xuXHRcdFx0XHR0aGlzLnNyY0JsZW5kID0gdGhpcy5jb250ZXh0LmdsLlNSQ19BTFBIQTtcblx0XHRcdFx0dGhpcy5kc3RCbGVuZCA9IHRoaXMuY29udGV4dC5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuXHRcdFx0fVxuXHRcdFx0UG9seWdvbkJhdGNoZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKHNoYWRlcikge1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdGlmICh0aGlzLmlzRHJhd2luZylcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQb2x5Z29uQmF0Y2ggaXMgYWxyZWFkeSBkcmF3aW5nLiBDYWxsIFBvbHlnb25CYXRjaC5lbmQoKSBiZWZvcmUgY2FsbGluZyBQb2x5Z29uQmF0Y2guYmVnaW4oKVwiKTtcblx0XHRcdFx0dGhpcy5kcmF3Q2FsbHMgPSAwO1xuXHRcdFx0XHR0aGlzLnNoYWRlciA9IHNoYWRlcjtcblx0XHRcdFx0dGhpcy5sYXN0VGV4dHVyZSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuaXNEcmF3aW5nID0gdHJ1ZTtcblx0XHRcdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKHRoaXMuc3JjQmxlbmQsIHRoaXMuZHN0QmxlbmQpO1xuXHRcdFx0fTtcblx0XHRcdFBvbHlnb25CYXRjaGVyLnByb3RvdHlwZS5zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbiAoc3JjQmxlbmQsIGRzdEJsZW5kKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dGhpcy5zcmNCbGVuZCA9IHNyY0JsZW5kO1xuXHRcdFx0XHR0aGlzLmRzdEJsZW5kID0gZHN0QmxlbmQ7XG5cdFx0XHRcdGlmICh0aGlzLmlzRHJhd2luZykge1xuXHRcdFx0XHRcdHRoaXMuZmx1c2goKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmModGhpcy5zcmNCbGVuZCwgdGhpcy5kc3RCbGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRQb2x5Z29uQmF0Y2hlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB2ZXJ0aWNlcywgaW5kaWNlcykge1xuXHRcdFx0XHRpZiAodGV4dHVyZSAhPSB0aGlzLmxhc3RUZXh0dXJlKSB7XG5cdFx0XHRcdFx0dGhpcy5mbHVzaCgpO1xuXHRcdFx0XHRcdHRoaXMubGFzdFRleHR1cmUgPSB0ZXh0dXJlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMudmVydGljZXNMZW5ndGggKyB2ZXJ0aWNlcy5sZW5ndGggPiB0aGlzLm1lc2guZ2V0VmVydGljZXMoKS5sZW5ndGggfHxcblx0XHRcdFx0XHR0aGlzLmluZGljZXNMZW5ndGggKyBpbmRpY2VzLmxlbmd0aCA+IHRoaXMubWVzaC5nZXRJbmRpY2VzKCkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhpcy5mbHVzaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBpbmRleFN0YXJ0ID0gdGhpcy5tZXNoLm51bVZlcnRpY2VzKCk7XG5cdFx0XHRcdHRoaXMubWVzaC5nZXRWZXJ0aWNlcygpLnNldCh2ZXJ0aWNlcywgdGhpcy52ZXJ0aWNlc0xlbmd0aCk7XG5cdFx0XHRcdHRoaXMudmVydGljZXNMZW5ndGggKz0gdmVydGljZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLm1lc2guc2V0VmVydGljZXNMZW5ndGgodGhpcy52ZXJ0aWNlc0xlbmd0aCk7XG5cdFx0XHRcdHZhciBpbmRpY2VzQXJyYXkgPSB0aGlzLm1lc2guZ2V0SW5kaWNlcygpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdGhpcy5pbmRpY2VzTGVuZ3RoLCBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyBpKyssIGorKylcblx0XHRcdFx0XHRpbmRpY2VzQXJyYXlbaV0gPSBpbmRpY2VzW2pdICsgaW5kZXhTdGFydDtcblx0XHRcdFx0dGhpcy5pbmRpY2VzTGVuZ3RoICs9IGluZGljZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLm1lc2guc2V0SW5kaWNlc0xlbmd0aCh0aGlzLmluZGljZXNMZW5ndGgpO1xuXHRcdFx0fTtcblx0XHRcdFBvbHlnb25CYXRjaGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHRpZiAodGhpcy52ZXJ0aWNlc0xlbmd0aCA9PSAwKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0dGhpcy5sYXN0VGV4dHVyZS5iaW5kKCk7XG5cdFx0XHRcdHRoaXMubWVzaC5kcmF3KHRoaXMuc2hhZGVyLCBnbC5UUklBTkdMRVMpO1xuXHRcdFx0XHR0aGlzLnZlcnRpY2VzTGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5pbmRpY2VzTGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5tZXNoLnNldFZlcnRpY2VzTGVuZ3RoKDApO1xuXHRcdFx0XHR0aGlzLm1lc2guc2V0SW5kaWNlc0xlbmd0aCgwKTtcblx0XHRcdFx0dGhpcy5kcmF3Q2FsbHMrKztcblx0XHRcdH07XG5cdFx0XHRQb2x5Z29uQmF0Y2hlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdGlmICghdGhpcy5pc0RyYXdpbmcpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUG9seWdvbkJhdGNoIGlzIG5vdCBkcmF3aW5nLiBDYWxsIFBvbHlnb25CYXRjaC5iZWdpbigpIGJlZm9yZSBjYWxsaW5nIFBvbHlnb25CYXRjaC5lbmQoKVwiKTtcblx0XHRcdFx0aWYgKHRoaXMudmVydGljZXNMZW5ndGggPiAwIHx8IHRoaXMuaW5kaWNlc0xlbmd0aCA+IDApXG5cdFx0XHRcdFx0dGhpcy5mbHVzaCgpO1xuXHRcdFx0XHR0aGlzLnNoYWRlciA9IG51bGw7XG5cdFx0XHRcdHRoaXMubGFzdFRleHR1cmUgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xuXHRcdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdH07XG5cdFx0XHRQb2x5Z29uQmF0Y2hlci5wcm90b3R5cGUuZ2V0RHJhd0NhbGxzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kcmF3Q2FsbHM7IH07XG5cdFx0XHRQb2x5Z29uQmF0Y2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5tZXNoLmRpc3Bvc2UoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gUG9seWdvbkJhdGNoZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5Qb2x5Z29uQmF0Y2hlciA9IFBvbHlnb25CYXRjaGVyO1xuXHR9KSh3ZWJnbCA9IHNwaW5lLndlYmdsIHx8IChzcGluZS53ZWJnbCA9IHt9KSk7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgd2ViZ2w7XG5cdChmdW5jdGlvbiAod2ViZ2wpIHtcblx0XHR2YXIgU2NlbmVSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRmdW5jdGlvbiBTY2VuZVJlbmRlcmVyKGNhbnZhcywgY29udGV4dCwgdHdvQ29sb3JUaW50KSB7XG5cdFx0XHRcdGlmICh0d29Db2xvclRpbnQgPT09IHZvaWQgMCkgeyB0d29Db2xvclRpbnQgPSB0cnVlOyB9XG5cdFx0XHRcdHRoaXMudHdvQ29sb3JUaW50ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuYWN0aXZlUmVuZGVyZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLlFVQUQgPSBbXG5cdFx0XHRcdFx0MCwgMCwgMSwgMSwgMSwgMSwgMCwgMCxcblx0XHRcdFx0XHQwLCAwLCAxLCAxLCAxLCAxLCAwLCAwLFxuXHRcdFx0XHRcdDAsIDAsIDEsIDEsIDEsIDEsIDAsIDAsXG5cdFx0XHRcdFx0MCwgMCwgMSwgMSwgMSwgMSwgMCwgMCxcblx0XHRcdFx0XTtcblx0XHRcdFx0dGhpcy5RVUFEX1RSSUFOR0xFUyA9IFswLCAxLCAyLCAyLCAzLCAwXTtcblx0XHRcdFx0dGhpcy5XSElURSA9IG5ldyBzcGluZS5Db2xvcigxLCAxLCAxLCAxKTtcblx0XHRcdFx0dGhpcy5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0ID8gY29udGV4dCA6IG5ldyB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0KGNvbnRleHQpO1xuXHRcdFx0XHR0aGlzLnR3b0NvbG9yVGludCA9IHR3b0NvbG9yVGludDtcblx0XHRcdFx0dGhpcy5jYW1lcmEgPSBuZXcgd2ViZ2wuT3J0aG9DYW1lcmEoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5iYXRjaGVyU2hhZGVyID0gdHdvQ29sb3JUaW50ID8gd2ViZ2wuU2hhZGVyLm5ld1R3b0NvbG9yZWRUZXh0dXJlZCh0aGlzLmNvbnRleHQpIDogd2ViZ2wuU2hhZGVyLm5ld0NvbG9yZWRUZXh0dXJlZCh0aGlzLmNvbnRleHQpO1xuXHRcdFx0XHR0aGlzLmJhdGNoZXIgPSBuZXcgd2ViZ2wuUG9seWdvbkJhdGNoZXIodGhpcy5jb250ZXh0LCB0d29Db2xvclRpbnQpO1xuXHRcdFx0XHR0aGlzLnNoYXBlc1NoYWRlciA9IHdlYmdsLlNoYWRlci5uZXdDb2xvcmVkKHRoaXMuY29udGV4dCk7XG5cdFx0XHRcdHRoaXMuc2hhcGVzID0gbmV3IHdlYmdsLlNoYXBlUmVuZGVyZXIodGhpcy5jb250ZXh0KTtcblx0XHRcdFx0dGhpcy5za2VsZXRvblJlbmRlcmVyID0gbmV3IHdlYmdsLlNrZWxldG9uUmVuZGVyZXIodGhpcy5jb250ZXh0LCB0d29Db2xvclRpbnQpO1xuXHRcdFx0XHR0aGlzLnNrZWxldG9uRGVidWdSZW5kZXJlciA9IG5ldyB3ZWJnbC5Ta2VsZXRvbkRlYnVnUmVuZGVyZXIodGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmNhbWVyYS51cGRhdGUoKTtcblx0XHRcdFx0dGhpcy5lbmFibGVSZW5kZXJlcih0aGlzLmJhdGNoZXIpO1xuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTa2VsZXRvbiA9IGZ1bmN0aW9uIChza2VsZXRvbiwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRcdGlmIChwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHZvaWQgMCkgeyBwcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTsgfVxuXHRcdFx0XHR0aGlzLmVuYWJsZVJlbmRlcmVyKHRoaXMuYmF0Y2hlcik7XG5cdFx0XHRcdHRoaXMuc2tlbGV0b25SZW5kZXJlci5wcmVtdWx0aXBsaWVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XG5cdFx0XHRcdHRoaXMuc2tlbGV0b25SZW5kZXJlci5kcmF3KHRoaXMuYmF0Y2hlciwgc2tlbGV0b24pO1xuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTa2VsZXRvbkRlYnVnID0gZnVuY3Rpb24gKHNrZWxldG9uLCBwcmVtdWx0aXBsaWVkQWxwaGEsIGlnbm9yZWRCb25lcykge1xuXHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhID09PSB2b2lkIDApIHsgcHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7IH1cblx0XHRcdFx0aWYgKGlnbm9yZWRCb25lcyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRCb25lcyA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5lbmFibGVSZW5kZXJlcih0aGlzLnNoYXBlcyk7XG5cdFx0XHRcdHRoaXMuc2tlbGV0b25EZWJ1Z1JlbmRlcmVyLnByZW11bHRpcGxpZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdFx0dGhpcy5za2VsZXRvbkRlYnVnUmVuZGVyZXIuZHJhdyh0aGlzLnNoYXBlcywgc2tlbGV0b24sIGlnbm9yZWRCb25lcyk7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcblx0XHRcdFx0aWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBudWxsOyB9XG5cdFx0XHRcdHRoaXMuZW5hYmxlUmVuZGVyZXIodGhpcy5iYXRjaGVyKTtcblx0XHRcdFx0aWYgKGNvbG9yID09PSBudWxsKVxuXHRcdFx0XHRcdGNvbG9yID0gdGhpcy5XSElURTtcblx0XHRcdFx0dmFyIHF1YWQgPSB0aGlzLlFVQUQ7XG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0cXVhZFtpKytdID0geDtcblx0XHRcdFx0cXVhZFtpKytdID0geTtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3Iucjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuZztcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYTtcblx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0cXVhZFtpKytdID0gMTtcblx0XHRcdFx0aWYgKHRoaXMudHdvQ29sb3JUaW50KSB7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRxdWFkW2krK10gPSB4ICsgd2lkdGg7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHk7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDE7XG5cdFx0XHRcdGlmICh0aGlzLnR3b0NvbG9yVGludCkge1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVhZFtpKytdID0geCArIHdpZHRoO1xuXHRcdFx0XHRxdWFkW2krK10gPSB5ICsgaGVpZ2h0O1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5yO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5nO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5iO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5hO1xuXHRcdFx0XHRxdWFkW2krK10gPSAxO1xuXHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRpZiAodGhpcy50d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHg7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHkgKyBoZWlnaHQ7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLnR3b0NvbG9yVGludCkge1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5iYXRjaGVyLmRyYXcodGV4dHVyZSwgcXVhZCwgdGhpcy5RVUFEX1RSSUFOR0xFUyk7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1RleHR1cmVSb3RhdGVkID0gZnVuY3Rpb24gKHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBpdm90WCwgcGl2b3RZLCBhbmdsZSwgY29sb3IsIHByZW11bHRpcGxpZWRBbHBoYSkge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKHByZW11bHRpcGxpZWRBbHBoYSA9PT0gdm9pZCAwKSB7IHByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlOyB9XG5cdFx0XHRcdHRoaXMuZW5hYmxlUmVuZGVyZXIodGhpcy5iYXRjaGVyKTtcblx0XHRcdFx0aWYgKGNvbG9yID09PSBudWxsKVxuXHRcdFx0XHRcdGNvbG9yID0gdGhpcy5XSElURTtcblx0XHRcdFx0dmFyIHF1YWQgPSB0aGlzLlFVQUQ7XG5cdFx0XHRcdHZhciB3b3JsZE9yaWdpblggPSB4ICsgcGl2b3RYO1xuXHRcdFx0XHR2YXIgd29ybGRPcmlnaW5ZID0geSArIHBpdm90WTtcblx0XHRcdFx0dmFyIGZ4ID0gLXBpdm90WDtcblx0XHRcdFx0dmFyIGZ5ID0gLXBpdm90WTtcblx0XHRcdFx0dmFyIGZ4MiA9IHdpZHRoIC0gcGl2b3RYO1xuXHRcdFx0XHR2YXIgZnkyID0gaGVpZ2h0IC0gcGl2b3RZO1xuXHRcdFx0XHR2YXIgcDF4ID0gZng7XG5cdFx0XHRcdHZhciBwMXkgPSBmeTtcblx0XHRcdFx0dmFyIHAyeCA9IGZ4O1xuXHRcdFx0XHR2YXIgcDJ5ID0gZnkyO1xuXHRcdFx0XHR2YXIgcDN4ID0gZngyO1xuXHRcdFx0XHR2YXIgcDN5ID0gZnkyO1xuXHRcdFx0XHR2YXIgcDR4ID0gZngyO1xuXHRcdFx0XHR2YXIgcDR5ID0gZnk7XG5cdFx0XHRcdHZhciB4MSA9IDA7XG5cdFx0XHRcdHZhciB5MSA9IDA7XG5cdFx0XHRcdHZhciB4MiA9IDA7XG5cdFx0XHRcdHZhciB5MiA9IDA7XG5cdFx0XHRcdHZhciB4MyA9IDA7XG5cdFx0XHRcdHZhciB5MyA9IDA7XG5cdFx0XHRcdHZhciB4NCA9IDA7XG5cdFx0XHRcdHZhciB5NCA9IDA7XG5cdFx0XHRcdGlmIChhbmdsZSAhPSAwKSB7XG5cdFx0XHRcdFx0dmFyIGNvcyA9IHNwaW5lLk1hdGhVdGlscy5jb3NEZWcoYW5nbGUpO1xuXHRcdFx0XHRcdHZhciBzaW4gPSBzcGluZS5NYXRoVXRpbHMuc2luRGVnKGFuZ2xlKTtcblx0XHRcdFx0XHR4MSA9IGNvcyAqIHAxeCAtIHNpbiAqIHAxeTtcblx0XHRcdFx0XHR5MSA9IHNpbiAqIHAxeCArIGNvcyAqIHAxeTtcblx0XHRcdFx0XHR4NCA9IGNvcyAqIHAyeCAtIHNpbiAqIHAyeTtcblx0XHRcdFx0XHR5NCA9IHNpbiAqIHAyeCArIGNvcyAqIHAyeTtcblx0XHRcdFx0XHR4MyA9IGNvcyAqIHAzeCAtIHNpbiAqIHAzeTtcblx0XHRcdFx0XHR5MyA9IHNpbiAqIHAzeCArIGNvcyAqIHAzeTtcblx0XHRcdFx0XHR4MiA9IHgzICsgKHgxIC0geDQpO1xuXHRcdFx0XHRcdHkyID0geTMgKyAoeTEgLSB5NCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBwMXg7XG5cdFx0XHRcdFx0eTEgPSBwMXk7XG5cdFx0XHRcdFx0eDQgPSBwMng7XG5cdFx0XHRcdFx0eTQgPSBwMnk7XG5cdFx0XHRcdFx0eDMgPSBwM3g7XG5cdFx0XHRcdFx0eTMgPSBwM3k7XG5cdFx0XHRcdFx0eDIgPSBwNHg7XG5cdFx0XHRcdFx0eTIgPSBwNHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0eDEgKz0gd29ybGRPcmlnaW5YO1xuXHRcdFx0XHR5MSArPSB3b3JsZE9yaWdpblk7XG5cdFx0XHRcdHgyICs9IHdvcmxkT3JpZ2luWDtcblx0XHRcdFx0eTIgKz0gd29ybGRPcmlnaW5ZO1xuXHRcdFx0XHR4MyArPSB3b3JsZE9yaWdpblg7XG5cdFx0XHRcdHkzICs9IHdvcmxkT3JpZ2luWTtcblx0XHRcdFx0eDQgKz0gd29ybGRPcmlnaW5YO1xuXHRcdFx0XHR5NCArPSB3b3JsZE9yaWdpblk7XG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0cXVhZFtpKytdID0geDE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHkxO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5yO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5nO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5iO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5hO1xuXHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRxdWFkW2krK10gPSAxO1xuXHRcdFx0XHRpZiAodGhpcy50d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHgyO1xuXHRcdFx0XHRxdWFkW2krK10gPSB5Mjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3Iucjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuZztcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYTtcblx0XHRcdFx0cXVhZFtpKytdID0gMTtcblx0XHRcdFx0cXVhZFtpKytdID0gMTtcblx0XHRcdFx0aWYgKHRoaXMudHdvQ29sb3JUaW50KSB7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRxdWFkW2krK10gPSB4Mztcblx0XHRcdFx0cXVhZFtpKytdID0geTM7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLnR3b0NvbG9yVGludCkge1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVhZFtpKytdID0geDQ7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHk0O1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5yO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5nO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5iO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5hO1xuXHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRpZiAodGhpcy50d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYmF0Y2hlci5kcmF3KHRleHR1cmUsIHF1YWQsIHRoaXMuUVVBRF9UUklBTkdMRVMpO1xuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLmRyYXdSZWdpb24gPSBmdW5jdGlvbiAocmVnaW9uLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvciwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhID09PSB2b2lkIDApIHsgcHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7IH1cblx0XHRcdFx0dGhpcy5lbmFibGVSZW5kZXJlcih0aGlzLmJhdGNoZXIpO1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IgPSB0aGlzLldISVRFO1xuXHRcdFx0XHR2YXIgcXVhZCA9IHRoaXMuUVVBRDtcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHRxdWFkW2krK10gPSB4O1xuXHRcdFx0XHRxdWFkW2krK10gPSB5O1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5yO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5nO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5iO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5hO1xuXHRcdFx0XHRxdWFkW2krK10gPSByZWdpb24udTtcblx0XHRcdFx0cXVhZFtpKytdID0gcmVnaW9uLnYyO1xuXHRcdFx0XHRpZiAodGhpcy50d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHggKyB3aWR0aDtcblx0XHRcdFx0cXVhZFtpKytdID0geTtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3Iucjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuZztcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYjtcblx0XHRcdFx0cXVhZFtpKytdID0gY29sb3IuYTtcblx0XHRcdFx0cXVhZFtpKytdID0gcmVnaW9uLnUyO1xuXHRcdFx0XHRxdWFkW2krK10gPSByZWdpb24udjI7XG5cdFx0XHRcdGlmICh0aGlzLnR3b0NvbG9yVGludCkge1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVhZFtpKytdID0geCArIHdpZHRoO1xuXHRcdFx0XHRxdWFkW2krK10gPSB5ICsgaGVpZ2h0O1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5yO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5nO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5iO1xuXHRcdFx0XHRxdWFkW2krK10gPSBjb2xvci5hO1xuXHRcdFx0XHRxdWFkW2krK10gPSByZWdpb24udTI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHJlZ2lvbi52O1xuXHRcdFx0XHRpZiAodGhpcy50d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHg7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHkgKyBoZWlnaHQ7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmI7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IGNvbG9yLmE7XG5cdFx0XHRcdHF1YWRbaSsrXSA9IHJlZ2lvbi51O1xuXHRcdFx0XHRxdWFkW2krK10gPSByZWdpb24udjtcblx0XHRcdFx0aWYgKHRoaXMudHdvQ29sb3JUaW50KSB7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0XHRxdWFkW2krK10gPSAwO1xuXHRcdFx0XHRcdHF1YWRbaSsrXSA9IDA7XG5cdFx0XHRcdFx0cXVhZFtpKytdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmJhdGNoZXIuZHJhdyhyZWdpb24udGV4dHVyZSwgcXVhZCwgdGhpcy5RVUFEX1RSSUFOR0xFUyk7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yLCBjb2xvcjIpIHtcblx0XHRcdFx0aWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBudWxsOyB9XG5cdFx0XHRcdGlmIChjb2xvcjIgPT09IHZvaWQgMCkgeyBjb2xvcjIgPSBudWxsOyB9XG5cdFx0XHRcdHRoaXMuZW5hYmxlUmVuZGVyZXIodGhpcy5zaGFwZXMpO1xuXHRcdFx0XHR0aGlzLnNoYXBlcy5saW5lKHgsIHksIHgyLCB5MiwgY29sb3IpO1xuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24gKGZpbGxlZCwgeCwgeSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yLCBjb2xvcjIsIGNvbG9yMykge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMiA9PT0gdm9pZCAwKSB7IGNvbG9yMiA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMyA9PT0gdm9pZCAwKSB7IGNvbG9yMyA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5lbmFibGVSZW5kZXJlcih0aGlzLnNoYXBlcyk7XG5cdFx0XHRcdHRoaXMuc2hhcGVzLnRyaWFuZ2xlKGZpbGxlZCwgeCwgeSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yLCBjb2xvcjIsIGNvbG9yMyk7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUucXVhZCA9IGZ1bmN0aW9uIChmaWxsZWQsIHgsIHksIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGNvbG9yLCBjb2xvcjIsIGNvbG9yMywgY29sb3I0KSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHRpZiAoY29sb3IyID09PSB2b2lkIDApIHsgY29sb3IyID0gbnVsbDsgfVxuXHRcdFx0XHRpZiAoY29sb3IzID09PSB2b2lkIDApIHsgY29sb3IzID0gbnVsbDsgfVxuXHRcdFx0XHRpZiAoY29sb3I0ID09PSB2b2lkIDApIHsgY29sb3I0ID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLmVuYWJsZVJlbmRlcmVyKHRoaXMuc2hhcGVzKTtcblx0XHRcdFx0dGhpcy5zaGFwZXMucXVhZChmaWxsZWQsIHgsIHksIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGNvbG9yLCBjb2xvcjIsIGNvbG9yMywgY29sb3I0KTtcblx0XHRcdH07XG5cdFx0XHRTY2VuZVJlbmRlcmVyLnByb3RvdHlwZS5yZWN0ID0gZnVuY3Rpb24gKGZpbGxlZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcblx0XHRcdFx0aWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBudWxsOyB9XG5cdFx0XHRcdHRoaXMuZW5hYmxlUmVuZGVyZXIodGhpcy5zaGFwZXMpO1xuXHRcdFx0XHR0aGlzLnNoYXBlcy5yZWN0KGZpbGxlZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpO1xuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLnJlY3RMaW5lID0gZnVuY3Rpb24gKGZpbGxlZCwgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBjb2xvcikge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5lbmFibGVSZW5kZXJlcih0aGlzLnNoYXBlcyk7XG5cdFx0XHRcdHRoaXMuc2hhcGVzLnJlY3RMaW5lKGZpbGxlZCwgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBjb2xvcik7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uIChwb2x5Z29uVmVydGljZXMsIG9mZnNldCwgY291bnQsIGNvbG9yKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLmVuYWJsZVJlbmRlcmVyKHRoaXMuc2hhcGVzKTtcblx0XHRcdFx0dGhpcy5zaGFwZXMucG9seWdvbihwb2x5Z29uVmVydGljZXMsIG9mZnNldCwgY291bnQsIGNvbG9yKTtcblx0XHRcdH07XG5cdFx0XHRTY2VuZVJlbmRlcmVyLnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbiAoZmlsbGVkLCB4LCB5LCByYWRpdXMsIGNvbG9yLCBzZWdtZW50cykge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKHNlZ21lbnRzID09PSB2b2lkIDApIHsgc2VnbWVudHMgPSAwOyB9XG5cdFx0XHRcdHRoaXMuZW5hYmxlUmVuZGVyZXIodGhpcy5zaGFwZXMpO1xuXHRcdFx0XHR0aGlzLnNoYXBlcy5jaXJjbGUoZmlsbGVkLCB4LCB5LCByYWRpdXMsIGNvbG9yLCBzZWdtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUuY3VydmUgPSBmdW5jdGlvbiAoeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5Miwgc2VnbWVudHMsIGNvbG9yKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLmVuYWJsZVJlbmRlcmVyKHRoaXMuc2hhcGVzKTtcblx0XHRcdFx0dGhpcy5zaGFwZXMuY3VydmUoeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5Miwgc2VnbWVudHMsIGNvbG9yKTtcblx0XHRcdH07XG5cdFx0XHRTY2VuZVJlbmRlcmVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLmFjdGl2ZVJlbmRlcmVyID09PSB0aGlzLmJhdGNoZXIpXG5cdFx0XHRcdFx0dGhpcy5iYXRjaGVyLmVuZCgpO1xuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmFjdGl2ZVJlbmRlcmVyID09PSB0aGlzLnNoYXBlcylcblx0XHRcdFx0XHR0aGlzLnNoYXBlcy5lbmQoKTtcblx0XHRcdFx0dGhpcy5hY3RpdmVSZW5kZXJlciA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0U2NlbmVSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHJlc2l6ZU1vZGUpIHtcblx0XHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXHRcdFx0XHR2YXIgdyA9IGNhbnZhcy5jbGllbnRXaWR0aDtcblx0XHRcdFx0dmFyIGggPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuXHRcdFx0XHRpZiAoY2FudmFzLndpZHRoICE9IHcgfHwgY2FudmFzLmhlaWdodCAhPSBoKSB7XG5cdFx0XHRcdFx0Y2FudmFzLndpZHRoID0gdztcblx0XHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNvbnRleHQuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblx0XHRcdFx0aWYgKHJlc2l6ZU1vZGUgPT09IFJlc2l6ZU1vZGUuU3RyZXRjaCkge1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHJlc2l6ZU1vZGUgPT09IFJlc2l6ZU1vZGUuRXhwYW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5jYW1lcmEuc2V0Vmlld3BvcnQodywgaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocmVzaXplTW9kZSA9PT0gUmVzaXplTW9kZS5GaXQpIHtcblx0XHRcdFx0XHR2YXIgc291cmNlV2lkdGggPSBjYW52YXMud2lkdGgsIHNvdXJjZUhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cdFx0XHRcdFx0dmFyIHRhcmdldFdpZHRoID0gdGhpcy5jYW1lcmEudmlld3BvcnRXaWR0aCwgdGFyZ2V0SGVpZ2h0ID0gdGhpcy5jYW1lcmEudmlld3BvcnRIZWlnaHQ7XG5cdFx0XHRcdFx0dmFyIHRhcmdldFJhdGlvID0gdGFyZ2V0SGVpZ2h0IC8gdGFyZ2V0V2lkdGg7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZVJhdGlvID0gc291cmNlSGVpZ2h0IC8gc291cmNlV2lkdGg7XG5cdFx0XHRcdFx0dmFyIHNjYWxlID0gdGFyZ2V0UmF0aW8gPCBzb3VyY2VSYXRpbyA/IHRhcmdldFdpZHRoIC8gc291cmNlV2lkdGggOiB0YXJnZXRIZWlnaHQgLyBzb3VyY2VIZWlnaHQ7XG5cdFx0XHRcdFx0dGhpcy5jYW1lcmEudmlld3BvcnRXaWR0aCA9IHNvdXJjZVdpZHRoICogc2NhbGU7XG5cdFx0XHRcdFx0dGhpcy5jYW1lcmEudmlld3BvcnRIZWlnaHQgPSBzb3VyY2VIZWlnaHQgKiBzY2FsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNhbWVyYS51cGRhdGUoKTtcblx0XHRcdH07XG5cdFx0XHRTY2VuZVJlbmRlcmVyLnByb3RvdHlwZS5lbmFibGVSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuXHRcdFx0XHRpZiAodGhpcy5hY3RpdmVSZW5kZXJlciA9PT0gcmVuZGVyZXIpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLmVuZCgpO1xuXHRcdFx0XHRpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiB3ZWJnbC5Qb2x5Z29uQmF0Y2hlcikge1xuXHRcdFx0XHRcdHRoaXMuYmF0Y2hlclNoYWRlci5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5iYXRjaGVyU2hhZGVyLnNldFVuaWZvcm00eDRmKHdlYmdsLlNoYWRlci5NVlBfTUFUUklYLCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uVmlldy52YWx1ZXMpO1xuXHRcdFx0XHRcdHRoaXMuYmF0Y2hlclNoYWRlci5zZXRVbmlmb3JtaShcInVfdGV4dHVyZVwiLCAwKTtcblx0XHRcdFx0XHR0aGlzLmJhdGNoZXIuYmVnaW4odGhpcy5iYXRjaGVyU2hhZGVyKTtcblx0XHRcdFx0XHR0aGlzLmFjdGl2ZVJlbmRlcmVyID0gdGhpcy5iYXRjaGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2Ygd2ViZ2wuU2hhcGVSZW5kZXJlcikge1xuXHRcdFx0XHRcdHRoaXMuc2hhcGVzU2hhZGVyLmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLnNoYXBlc1NoYWRlci5zZXRVbmlmb3JtNHg0Zih3ZWJnbC5TaGFkZXIuTVZQX01BVFJJWCwgdGhpcy5jYW1lcmEucHJvamVjdGlvblZpZXcudmFsdWVzKTtcblx0XHRcdFx0XHR0aGlzLnNoYXBlcy5iZWdpbih0aGlzLnNoYXBlc1NoYWRlcik7XG5cdFx0XHRcdFx0dGhpcy5hY3RpdmVSZW5kZXJlciA9IHRoaXMuc2hhcGVzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYWN0aXZlUmVuZGVyZXIgPSB0aGlzLnNrZWxldG9uRGVidWdSZW5kZXJlcjtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNjZW5lUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuYmF0Y2hlci5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMuYmF0Y2hlclNoYWRlci5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMuc2hhcGVzLmRpc3Bvc2UoKTtcblx0XHRcdFx0dGhpcy5zaGFwZXNTaGFkZXIuZGlzcG9zZSgpO1xuXHRcdFx0XHR0aGlzLnNrZWxldG9uRGVidWdSZW5kZXJlci5kaXNwb3NlKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIFNjZW5lUmVuZGVyZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5TY2VuZVJlbmRlcmVyID0gU2NlbmVSZW5kZXJlcjtcblx0XHQoZnVuY3Rpb24gKFJlc2l6ZU1vZGUpIHtcblx0XHRcdFJlc2l6ZU1vZGVbUmVzaXplTW9kZVtcIlN0cmV0Y2hcIl0gPSAwXSA9IFwiU3RyZXRjaFwiO1xuXHRcdFx0UmVzaXplTW9kZVtSZXNpemVNb2RlW1wiRXhwYW5kXCJdID0gMV0gPSBcIkV4cGFuZFwiO1xuXHRcdFx0UmVzaXplTW9kZVtSZXNpemVNb2RlW1wiRml0XCJdID0gMl0gPSBcIkZpdFwiO1xuXHRcdH0pKHdlYmdsLlJlc2l6ZU1vZGUgfHwgKHdlYmdsLlJlc2l6ZU1vZGUgPSB7fSkpO1xuXHRcdHZhciBSZXNpemVNb2RlID0gd2ViZ2wuUmVzaXplTW9kZTtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIHdlYmdsO1xuXHQoZnVuY3Rpb24gKHdlYmdsKSB7XG5cdFx0dmFyIFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRmdW5jdGlvbiBTaGFkZXIoY29udGV4dCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuXHRcdFx0XHR0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcblx0XHRcdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuXHRcdFx0XHR0aGlzLnZzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5mcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdHRoaXMudG1wMngyID0gbmV3IEZsb2F0MzJBcnJheSgyICogMik7XG5cdFx0XHRcdHRoaXMudG1wM3gzID0gbmV3IEZsb2F0MzJBcnJheSgzICogMyk7XG5cdFx0XHRcdHRoaXMudG1wNHg0ID0gbmV3IEZsb2F0MzJBcnJheSg0ICogNCk7XG5cdFx0XHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0ID8gY29udGV4dCA6IG5ldyB3ZWJnbC5NYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0KGNvbnRleHQpO1xuXHRcdFx0XHR0aGlzLmNvbnRleHQuYWRkUmVzdG9yYWJsZSh0aGlzKTtcblx0XHRcdFx0dGhpcy5jb21waWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmdldFByb2dyYW0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnByb2dyYW07IH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmdldFZlcnRleFNoYWRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmVydGV4U2hhZGVyOyB9O1xuXHRcdFx0U2hhZGVyLnByb3RvdHlwZS5nZXRGcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnRTaGFkZXI7IH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLnZzID0gdGhpcy5jb21waWxlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIsIHRoaXMudmVydGV4U2hhZGVyKTtcblx0XHRcdFx0XHR0aGlzLmZzID0gdGhpcy5jb21waWxlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgdGhpcy5mcmFnbWVudFNoYWRlcik7XG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtID0gdGhpcy5jb21waWxlUHJvZ3JhbSh0aGlzLnZzLCB0aGlzLmZzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmNvbXBpbGVTaGFkZXIgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblx0XHRcdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcblx0XHRcdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXHRcdFx0XHRpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9IFwiQ291bGRuJ3QgY29tcGlsZSBzaGFkZXI6IFwiICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuXHRcdFx0XHRcdGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuXHRcdFx0XHRcdGlmICghZ2wuaXNDb250ZXh0TG9zdCgpKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2hhZGVyO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUuY29tcGlsZVByb2dyYW0gPSBmdW5jdGlvbiAodnMsIGZzKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdFx0XHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2cyk7XG5cdFx0XHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcyk7XG5cdFx0XHRcdGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXHRcdFx0XHRpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gXCJDb3VsZG4ndCBjb21waWxlIHNoYWRlciBwcm9ncmFtOiBcIiArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuXHRcdFx0XHRcdGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRcdFx0aWYgKCFnbC5pc0NvbnRleHRMb3N0KCkpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9ncmFtO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5jb21waWxlKCk7XG5cdFx0XHR9O1xuXHRcdFx0U2hhZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmNvbnRleHQuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmNvbnRleHQuZ2wudXNlUHJvZ3JhbShudWxsKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm1pID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5nbC51bmlmb3JtMWkodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybSksIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm1mID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5nbC51bmlmb3JtMWYodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybSksIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm0yZiA9IGZ1bmN0aW9uICh1bmlmb3JtLCB2YWx1ZSwgdmFsdWUyKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5nbC51bmlmb3JtMmYodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybSksIHZhbHVlLCB2YWx1ZTIpO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUuc2V0VW5pZm9ybTNmID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlLCB2YWx1ZTIsIHZhbHVlMykge1xuXHRcdFx0XHR0aGlzLmNvbnRleHQuZ2wudW5pZm9ybTNmKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm0pLCB2YWx1ZSwgdmFsdWUyLCB2YWx1ZTMpO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUuc2V0VW5pZm9ybTRmID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlLCB2YWx1ZTIsIHZhbHVlMywgdmFsdWU0KSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5nbC51bmlmb3JtNGYodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybSksIHZhbHVlLCB2YWx1ZTIsIHZhbHVlMywgdmFsdWU0KTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm0yeDJmID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dGhpcy50bXAyeDIuc2V0KHZhbHVlKTtcblx0XHRcdFx0Z2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtKSwgZmFsc2UsIHRoaXMudG1wMngyKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm0zeDNmID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dGhpcy50bXAzeDMuc2V0KHZhbHVlKTtcblx0XHRcdFx0Z2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtKSwgZmFsc2UsIHRoaXMudG1wM3gzKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm00eDRmID0gZnVuY3Rpb24gKHVuaWZvcm0sIHZhbHVlKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dGhpcy50bXA0eDQuc2V0KHZhbHVlKTtcblx0XHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtKSwgZmFsc2UsIHRoaXMudG1wNHg0KTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uICh1bmlmb3JtKSB7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0dmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdW5pZm9ybSk7XG5cdFx0XHRcdGlmICghbG9jYXRpb24gJiYgIWdsLmlzQ29udGV4dExvc3QoKSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGxvY2F0aW9uIGZvciB1bmlmb3JtIFwiICsgdW5pZm9ybSk7XG5cdFx0XHRcdHJldHVybiBsb2NhdGlvbjtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdHZhciBsb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXR0cmlidXRlKTtcblx0XHRcdFx0aWYgKGxvY2F0aW9uID09IC0xICYmICFnbC5pc0NvbnRleHRMb3N0KCkpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBsb2NhdGlvbiBmb3IgYXR0cmlidXRlIFwiICsgYXR0cmlidXRlKTtcblx0XHRcdFx0cmV0dXJuIGxvY2F0aW9uO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5jb250ZXh0LnJlbW92ZVJlc3RvcmFibGUodGhpcyk7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0aWYgKHRoaXMudnMpIHtcblx0XHRcdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy52cyk7XG5cdFx0XHRcdFx0dGhpcy52cyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZnMpIHtcblx0XHRcdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy5mcyk7XG5cdFx0XHRcdFx0dGhpcy5mcyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMucHJvZ3JhbSkge1xuXHRcdFx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U2hhZGVyLm5ld0NvbG9yZWRUZXh0dXJlZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHZhciB2cyA9IFwiXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlIHZlYzQgXCIgKyBTaGFkZXIuUE9TSVRJT04gKyBcIjtcXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgdmVjNCBcIiArIFNoYWRlci5DT0xPUiArIFwiO1xcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSB2ZWMyIFwiICsgU2hhZGVyLlRFWENPT1JEUyArIFwiO1xcblxcdFxcdFxcdFxcdHVuaWZvcm0gbWF0NCBcIiArIFNoYWRlci5NVlBfTUFUUklYICsgXCI7XFxuXFx0XFx0XFx0XFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFx0XFx0XFx0XFx0dmFyeWluZyB2ZWMyIHZfdGV4Q29vcmRzO1xcblxcblxcdFxcdFxcdFxcdHZvaWQgbWFpbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dl9jb2xvciA9IFwiICsgU2hhZGVyLkNPTE9SICsgXCI7XFxuXFx0XFx0XFx0XFx0XFx0dl90ZXhDb29yZHMgPSBcIiArIFNoYWRlci5URVhDT09SRFMgKyBcIjtcXG5cXHRcXHRcXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IFwiICsgU2hhZGVyLk1WUF9NQVRSSVggKyBcIiAqIFwiICsgU2hhZGVyLlBPU0lUSU9OICsgXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiO1xuXHRcdFx0XHR2YXIgZnMgPSBcIlxcblxcdFxcdFxcdFxcdCNpZmRlZiBHTF9FU1xcblxcdFxcdFxcdFxcdFxcdCNkZWZpbmUgTE9XUCBsb3dwXFxuXFx0XFx0XFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHRcXHQjZGVmaW5lIExPV1BcXG5cXHRcXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIExPV1AgdmVjNCB2X2NvbG9yO1xcblxcdFxcdFxcdFxcdHZhcnlpbmcgdmVjMiB2X3RleENvb3JkcztcXG5cXHRcXHRcXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0dm9pZCBtYWluICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhDb29yZHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIjtcblx0XHRcdFx0cmV0dXJuIG5ldyBTaGFkZXIoY29udGV4dCwgdnMsIGZzKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIubmV3VHdvQ29sb3JlZFRleHR1cmVkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRcdFx0dmFyIHZzID0gXCJcXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgdmVjNCBcIiArIFNoYWRlci5QT1NJVElPTiArIFwiO1xcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSB2ZWM0IFwiICsgU2hhZGVyLkNPTE9SICsgXCI7XFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlIHZlYzQgXCIgKyBTaGFkZXIuQ09MT1IyICsgXCI7XFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlIHZlYzIgXCIgKyBTaGFkZXIuVEVYQ09PUkRTICsgXCI7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybSBtYXQ0IFwiICsgU2hhZGVyLk1WUF9NQVRSSVggKyBcIjtcXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzQgdl9saWdodDtcXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzQgdl9kYXJrO1xcblxcdFxcdFxcdFxcdHZhcnlpbmcgdmVjMiB2X3RleENvb3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2b2lkIG1haW4gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZfbGlnaHQgPSBcIiArIFNoYWRlci5DT0xPUiArIFwiO1xcblxcdFxcdFxcdFxcdFxcdHZfZGFyayA9IFwiICsgU2hhZGVyLkNPTE9SMiArIFwiO1xcblxcdFxcdFxcdFxcdFxcdHZfdGV4Q29vcmRzID0gXCIgKyBTaGFkZXIuVEVYQ09PUkRTICsgXCI7XFxuXFx0XFx0XFx0XFx0XFx0Z2xfUG9zaXRpb24gPSBcIiArIFNoYWRlci5NVlBfTUFUUklYICsgXCIgKiBcIiArIFNoYWRlci5QT1NJVElPTiArIFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIjtcblx0XHRcdFx0dmFyIGZzID0gXCJcXG5cXHRcXHRcXHRcXHQjaWZkZWYgR0xfRVNcXG5cXHRcXHRcXHRcXHRcXHQjZGVmaW5lIExPV1AgbG93cFxcblxcdFxcdFxcdFxcdFxcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcdFxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0XFx0I2RlZmluZSBMT1dQXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0XFx0dmFyeWluZyBMT1dQIHZlYzQgdl9saWdodDtcXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIExPV1AgdmVjNCB2X2Rhcms7XFxuXFx0XFx0XFx0XFx0dmFyeWluZyB2ZWMyIHZfdGV4Q29vcmRzO1xcblxcdFxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHR2b2lkIG1haW4gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleENvb3Jkcyk7XFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgYWxwaGEgPSB0ZXhDb2xvci5hICogdl9saWdodC5hO1xcblxcdFxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuXFx0XFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiA9ICgxLjAgLSB0ZXhDb2xvci5yZ2IpICogdl9kYXJrLnJnYiAqIGFscGhhICsgdGV4Q29sb3IucmdiICogdl9saWdodC5yZ2I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiO1xuXHRcdFx0XHRyZXR1cm4gbmV3IFNoYWRlcihjb250ZXh0LCB2cywgZnMpO1xuXHRcdFx0fTtcblx0XHRcdFNoYWRlci5uZXdDb2xvcmVkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRcdFx0dmFyIHZzID0gXCJcXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgdmVjNCBcIiArIFNoYWRlci5QT1NJVElPTiArIFwiO1xcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSB2ZWM0IFwiICsgU2hhZGVyLkNPTE9SICsgXCI7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybSBtYXQ0IFwiICsgU2hhZGVyLk1WUF9NQVRSSVggKyBcIjtcXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5cXHRcXHRcXHRcXHR2b2lkIG1haW4gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZfY29sb3IgPSBcIiArIFNoYWRlci5DT0xPUiArIFwiO1xcblxcdFxcdFxcdFxcdFxcdGdsX1Bvc2l0aW9uID0gXCIgKyBTaGFkZXIuTVZQX01BVFJJWCArIFwiICogXCIgKyBTaGFkZXIuUE9TSVRJT04gKyBcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCI7XG5cdFx0XHRcdHZhciBmcyA9IFwiXFxuXFx0XFx0XFx0XFx0I2lmZGVmIEdMX0VTXFxuXFx0XFx0XFx0XFx0XFx0I2RlZmluZSBMT1dQIGxvd3BcXG5cXHRcXHRcXHRcXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXHRcXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdFxcdCNkZWZpbmUgTE9XUFxcblxcdFxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdFxcdHZhcnlpbmcgTE9XUCB2ZWM0IHZfY29sb3I7XFxuXFxuXFx0XFx0XFx0XFx0dm9pZCBtYWluICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIjtcblx0XHRcdFx0cmV0dXJuIG5ldyBTaGFkZXIoY29udGV4dCwgdnMsIGZzKTtcblx0XHRcdH07XG5cdFx0XHRTaGFkZXIuTVZQX01BVFJJWCA9IFwidV9wcm9qVHJhbnNcIjtcblx0XHRcdFNoYWRlci5QT1NJVElPTiA9IFwiYV9wb3NpdGlvblwiO1xuXHRcdFx0U2hhZGVyLkNPTE9SID0gXCJhX2NvbG9yXCI7XG5cdFx0XHRTaGFkZXIuQ09MT1IyID0gXCJhX2NvbG9yMlwiO1xuXHRcdFx0U2hhZGVyLlRFWENPT1JEUyA9IFwiYV90ZXhDb29yZHNcIjtcblx0XHRcdFNoYWRlci5TQU1QTEVSID0gXCJ1X3RleHR1cmVcIjtcblx0XHRcdHJldHVybiBTaGFkZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5TaGFkZXIgPSBTaGFkZXI7XG5cdH0pKHdlYmdsID0gc3BpbmUud2ViZ2wgfHwgKHNwaW5lLndlYmdsID0ge30pKTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciB3ZWJnbDtcblx0KGZ1bmN0aW9uICh3ZWJnbCkge1xuXHRcdHZhciBTaGFwZVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFNoYXBlUmVuZGVyZXIoY29udGV4dCwgbWF4VmVydGljZXMpIHtcblx0XHRcdFx0aWYgKG1heFZlcnRpY2VzID09PSB2b2lkIDApIHsgbWF4VmVydGljZXMgPSAxMDkyMDsgfVxuXHRcdFx0XHR0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnNoYXBlVHlwZSA9IFNoYXBlVHlwZS5GaWxsZWQ7XG5cdFx0XHRcdHRoaXMuY29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMSwgMSwgMSwgMSk7XG5cdFx0XHRcdHRoaXMudmVydGV4SW5kZXggPSAwO1xuXHRcdFx0XHR0aGlzLnRtcCA9IG5ldyBzcGluZS5WZWN0b3IyKCk7XG5cdFx0XHRcdGlmIChtYXhWZXJ0aWNlcyA+IDEwOTIwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbid0IGhhdmUgbW9yZSB0aGFuIDEwOTIwIHRyaWFuZ2xlcyBwZXIgYmF0Y2g6IFwiICsgbWF4VmVydGljZXMpO1xuXHRcdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2Ygd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/IGNvbnRleHQgOiBuZXcgd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dChjb250ZXh0KTtcblx0XHRcdFx0dGhpcy5tZXNoID0gbmV3IHdlYmdsLk1lc2goY29udGV4dCwgW25ldyB3ZWJnbC5Qb3NpdGlvbjJBdHRyaWJ1dGUoKSwgbmV3IHdlYmdsLkNvbG9yQXR0cmlidXRlKCldLCBtYXhWZXJ0aWNlcywgMCk7XG5cdFx0XHRcdHRoaXMuc3JjQmxlbmQgPSB0aGlzLmNvbnRleHQuZ2wuU1JDX0FMUEhBO1xuXHRcdFx0XHR0aGlzLmRzdEJsZW5kID0gdGhpcy5jb250ZXh0LmdsLk9ORV9NSU5VU19TUkNfQUxQSEE7XG5cdFx0XHR9XG5cdFx0XHRTaGFwZVJlbmRlcmVyLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uIChzaGFkZXIpIHtcblx0XHRcdFx0aWYgKHRoaXMuaXNEcmF3aW5nKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNoYXBlUmVuZGVyZXIuYmVnaW4oKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcblx0XHRcdFx0dGhpcy5zaGFkZXIgPSBzaGFkZXI7XG5cdFx0XHRcdHRoaXMudmVydGV4SW5kZXggPSAwO1xuXHRcdFx0XHR0aGlzLmlzRHJhd2luZyA9IHRydWU7XG5cdFx0XHRcdHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblx0XHRcdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKHRoaXMuc3JjQmxlbmQsIHRoaXMuZHN0QmxlbmQpO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnNldEJsZW5kTW9kZSA9IGZ1bmN0aW9uIChzcmNCbGVuZCwgZHN0QmxlbmQpIHtcblx0XHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0XHR0aGlzLnNyY0JsZW5kID0gc3JjQmxlbmQ7XG5cdFx0XHRcdHRoaXMuZHN0QmxlbmQgPSBkc3RCbGVuZDtcblx0XHRcdFx0aWYgKHRoaXMuaXNEcmF3aW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5mbHVzaCgpO1xuXHRcdFx0XHRcdGdsLmJsZW5kRnVuYyh0aGlzLnNyY0JsZW5kLCB0aGlzLmRzdEJsZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRcdHRoaXMuY29sb3Iuc2V0RnJvbUNvbG9yKGNvbG9yKTtcblx0XHRcdH07XG5cdFx0XHRTaGFwZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRDb2xvcldpdGggPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuXHRcdFx0XHR0aGlzLmNvbG9yLnNldChyLCBnLCBiLCBhKTtcblx0XHRcdH07XG5cdFx0XHRTaGFwZVJlbmRlcmVyLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvcikge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5jaGVjayhTaGFwZVR5cGUuUG9pbnQsIDEpO1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHR0aGlzLnZlcnRleCh4LCB5LCBjb2xvcik7XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLmNoZWNrKFNoYXBlVHlwZS5MaW5lLCAyKTtcblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5tZXNoLmdldFZlcnRpY2VzKCk7XG5cdFx0XHRcdHZhciBpZHggPSB0aGlzLnZlcnRleEluZGV4O1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHR0aGlzLnZlcnRleCh4LCB5LCBjb2xvcik7XG5cdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IpO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24gKGZpbGxlZCwgeCwgeSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yLCBjb2xvcjIsIGNvbG9yMykge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMiA9PT0gdm9pZCAwKSB7IGNvbG9yMiA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMyA9PT0gdm9pZCAwKSB7IGNvbG9yMyA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5jaGVjayhmaWxsZWQgPyBTaGFwZVR5cGUuRmlsbGVkIDogU2hhcGVUeXBlLkxpbmUsIDMpO1xuXHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLm1lc2guZ2V0VmVydGljZXMoKTtcblx0XHRcdFx0dmFyIGlkeCA9IHRoaXMudmVydGV4SW5kZXg7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gbnVsbClcblx0XHRcdFx0XHRjb2xvciA9IHRoaXMuY29sb3I7XG5cdFx0XHRcdGlmIChjb2xvcjIgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IyID0gdGhpcy5jb2xvcjtcblx0XHRcdFx0aWYgKGNvbG9yMyA9PT0gbnVsbClcblx0XHRcdFx0XHRjb2xvcjMgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHRpZiAoZmlsbGVkKSB7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCwgeSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IyKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MywgeTMsIGNvbG9yMyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCwgeSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IyKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MiwgeTIsIGNvbG9yKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MywgeTMsIGNvbG9yMik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDMsIHkzLCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCwgeSwgY29sb3IyKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnF1YWQgPSBmdW5jdGlvbiAoZmlsbGVkLCB4LCB5LCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBjb2xvciwgY29sb3IyLCBjb2xvcjMsIGNvbG9yNCkge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMiA9PT0gdm9pZCAwKSB7IGNvbG9yMiA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yMyA9PT0gdm9pZCAwKSB7IGNvbG9yMyA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvbG9yNCA9PT0gdm9pZCAwKSB7IGNvbG9yNCA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5jaGVjayhmaWxsZWQgPyBTaGFwZVR5cGUuRmlsbGVkIDogU2hhcGVUeXBlLkxpbmUsIDMpO1xuXHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLm1lc2guZ2V0VmVydGljZXMoKTtcblx0XHRcdFx0dmFyIGlkeCA9IHRoaXMudmVydGV4SW5kZXg7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gbnVsbClcblx0XHRcdFx0XHRjb2xvciA9IHRoaXMuY29sb3I7XG5cdFx0XHRcdGlmIChjb2xvcjIgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IyID0gdGhpcy5jb2xvcjtcblx0XHRcdFx0aWYgKGNvbG9yMyA9PT0gbnVsbClcblx0XHRcdFx0XHRjb2xvcjMgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHRpZiAoY29sb3I0ID09PSBudWxsKVxuXHRcdFx0XHRcdGNvbG9yNCA9IHRoaXMuY29sb3I7XG5cdFx0XHRcdGlmIChmaWxsZWQpIHtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4LCB5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDIsIHkyLCBjb2xvcjIpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgzLCB5MywgY29sb3IzKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MywgeTMsIGNvbG9yMyk7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDQsIHk0LCBjb2xvcjQpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgsIHksIGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4LCB5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDIsIHkyLCBjb2xvcjIpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IyKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MywgeTMsIGNvbG9yMyk7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDMsIHkzLCBjb2xvcjMpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHg0LCB5NCwgY29sb3I0KTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4NCwgeTQsIGNvbG9yNCk7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCwgeSwgY29sb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uIChmaWxsZWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLnF1YWQoZmlsbGVkLCB4LCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCwgY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IpO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnJlY3RMaW5lID0gZnVuY3Rpb24gKGZpbGxlZCwgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBjb2xvcikge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0dGhpcy5jaGVjayhmaWxsZWQgPyBTaGFwZVR5cGUuRmlsbGVkIDogU2hhcGVUeXBlLkxpbmUsIDgpO1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMudG1wLnNldCh5MiAtIHkxLCB4MSAtIHgyKTtcblx0XHRcdFx0dC5ub3JtYWxpemUoKTtcblx0XHRcdFx0d2lkdGggKj0gMC41O1xuXHRcdFx0XHR2YXIgdHggPSB0LnggKiB3aWR0aDtcblx0XHRcdFx0dmFyIHR5ID0gdC55ICogd2lkdGg7XG5cdFx0XHRcdGlmICghZmlsbGVkKSB7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDEgKyB0eCwgeTEgKyB0eSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgxIC0gdHgsIHkxIC0gdHksIGNvbG9yKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MiArIHR4LCB5MiArIHR5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDIgLSB0eCwgeTIgLSB0eSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyICsgdHgsIHkyICsgdHksIGNvbG9yKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MSArIHR4LCB5MSArIHR5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDIgLSB0eCwgeTIgLSB0eSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgxIC0gdHgsIHkxIC0gdHksIGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MSArIHR4LCB5MSArIHR5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDEgLSB0eCwgeTEgLSB0eSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyICsgdHgsIHkyICsgdHksIGNvbG9yKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4MiAtIHR4LCB5MiAtIHR5LCBjb2xvcik7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeDIgKyB0eCwgeTIgKyB0eSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgxIC0gdHgsIHkxIC0gdHksIGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSkge1xuXHRcdFx0XHR0aGlzLmxpbmUoeCAtIHNpemUsIHkgLSBzaXplLCB4ICsgc2l6ZSwgeSArIHNpemUpO1xuXHRcdFx0XHR0aGlzLmxpbmUoeCAtIHNpemUsIHkgKyBzaXplLCB4ICsgc2l6ZSwgeSAtIHNpemUpO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvblZlcnRpY2VzLCBvZmZzZXQsIGNvdW50LCBjb2xvcikge1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IG51bGw7IH1cblx0XHRcdFx0aWYgKGNvdW50IDwgMylcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQb2x5Z29uIG11c3QgY29udGFpbiBhdCBsZWFzdCAzIHZlcnRpY2VzXCIpO1xuXHRcdFx0XHR0aGlzLmNoZWNrKFNoYXBlVHlwZS5MaW5lLCBjb3VudCAqIDIpO1xuXHRcdFx0XHRpZiAoY29sb3IgPT09IG51bGwpXG5cdFx0XHRcdFx0Y29sb3IgPSB0aGlzLmNvbG9yO1xuXHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLm1lc2guZ2V0VmVydGljZXMoKTtcblx0XHRcdFx0dmFyIGlkeCA9IHRoaXMudmVydGV4SW5kZXg7XG5cdFx0XHRcdG9mZnNldCA8PD0gMTtcblx0XHRcdFx0Y291bnQgPDw9IDE7XG5cdFx0XHRcdHZhciBmaXJzdFggPSBwb2x5Z29uVmVydGljZXNbb2Zmc2V0XTtcblx0XHRcdFx0dmFyIGZpcnN0WSA9IHBvbHlnb25WZXJ0aWNlc1tvZmZzZXQgKyAxXTtcblx0XHRcdFx0dmFyIGxhc3QgPSBvZmZzZXQgKyBjb3VudDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IG9mZnNldCwgbiA9IG9mZnNldCArIGNvdW50IC0gMjsgaSA8IG47IGkgKz0gMikge1xuXHRcdFx0XHRcdHZhciB4MSA9IHBvbHlnb25WZXJ0aWNlc1tpXTtcblx0XHRcdFx0XHR2YXIgeTEgPSBwb2x5Z29uVmVydGljZXNbaSArIDFdO1xuXHRcdFx0XHRcdHZhciB4MiA9IDA7XG5cdFx0XHRcdFx0dmFyIHkyID0gMDtcblx0XHRcdFx0XHRpZiAoaSArIDIgPj0gbGFzdCkge1xuXHRcdFx0XHRcdFx0eDIgPSBmaXJzdFg7XG5cdFx0XHRcdFx0XHR5MiA9IGZpcnN0WTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR4MiA9IHBvbHlnb25WZXJ0aWNlc1tpICsgMl07XG5cdFx0XHRcdFx0XHR5MiA9IHBvbHlnb25WZXJ0aWNlc1tpICsgM107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgxLCB5MSwgY29sb3IpO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24gKGZpbGxlZCwgeCwgeSwgcmFkaXVzLCBjb2xvciwgc2VnbWVudHMpIHtcblx0XHRcdFx0aWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBudWxsOyB9XG5cdFx0XHRcdGlmIChzZWdtZW50cyA9PT0gdm9pZCAwKSB7IHNlZ21lbnRzID0gMDsgfVxuXHRcdFx0XHRpZiAoc2VnbWVudHMgPT09IDApXG5cdFx0XHRcdFx0c2VnbWVudHMgPSBNYXRoLm1heCgxLCAoNiAqIHNwaW5lLk1hdGhVdGlscy5jYnJ0KHJhZGl1cykpIHwgMCk7XG5cdFx0XHRcdGlmIChzZWdtZW50cyA8PSAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNlZ21lbnRzIG11c3QgYmUgPiAwLlwiKTtcblx0XHRcdFx0aWYgKGNvbG9yID09PSBudWxsKVxuXHRcdFx0XHRcdGNvbG9yID0gdGhpcy5jb2xvcjtcblx0XHRcdFx0dmFyIGFuZ2xlID0gMiAqIHNwaW5lLk1hdGhVdGlscy5QSSAvIHNlZ21lbnRzO1xuXHRcdFx0XHR2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHR2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHR2YXIgY3ggPSByYWRpdXMsIGN5ID0gMDtcblx0XHRcdFx0aWYgKCFmaWxsZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNoZWNrKFNoYXBlVHlwZS5MaW5lLCBzZWdtZW50cyAqIDIgKyAyKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMudmVydGV4KHggKyBjeCwgeSArIGN5LCBjb2xvcik7XG5cdFx0XHRcdFx0XHR2YXIgdGVtcF8xID0gY3g7XG5cdFx0XHRcdFx0XHRjeCA9IGNvcyAqIGN4IC0gc2luICogY3k7XG5cdFx0XHRcdFx0XHRjeSA9IHNpbiAqIHRlbXBfMSArIGNvcyAqIGN5O1xuXHRcdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCArIGN4LCB5ICsgY3ksIGNvbG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoeCArIGN4LCB5ICsgY3ksIGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNoZWNrKFNoYXBlVHlwZS5GaWxsZWQsIHNlZ21lbnRzICogMyArIDMpO1xuXHRcdFx0XHRcdHNlZ21lbnRzLS07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZlcnRleCh4LCB5LCBjb2xvcik7XG5cdFx0XHRcdFx0XHR0aGlzLnZlcnRleCh4ICsgY3gsIHkgKyBjeSwgY29sb3IpO1xuXHRcdFx0XHRcdFx0dmFyIHRlbXBfMiA9IGN4O1xuXHRcdFx0XHRcdFx0Y3ggPSBjb3MgKiBjeCAtIHNpbiAqIGN5O1xuXHRcdFx0XHRcdFx0Y3kgPSBzaW4gKiB0ZW1wXzIgKyBjb3MgKiBjeTtcblx0XHRcdFx0XHRcdHRoaXMudmVydGV4KHggKyBjeCwgeSArIGN5LCBjb2xvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudmVydGV4KHgsIHksIGNvbG9yKTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleCh4ICsgY3gsIHkgKyBjeSwgY29sb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0ZW1wID0gY3g7XG5cdFx0XHRcdGN4ID0gcmFkaXVzO1xuXHRcdFx0XHRjeSA9IDA7XG5cdFx0XHRcdHRoaXMudmVydGV4KHggKyBjeCwgeSArIGN5LCBjb2xvcik7XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUuY3VydmUgPSBmdW5jdGlvbiAoeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5Miwgc2VnbWVudHMsIGNvbG9yKSB7XG5cdFx0XHRcdGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLmNoZWNrKFNoYXBlVHlwZS5MaW5lLCBzZWdtZW50cyAqIDIgKyAyKTtcblx0XHRcdFx0aWYgKGNvbG9yID09PSBudWxsKVxuXHRcdFx0XHRcdGNvbG9yID0gdGhpcy5jb2xvcjtcblx0XHRcdFx0dmFyIHN1YmRpdl9zdGVwID0gMSAvIHNlZ21lbnRzO1xuXHRcdFx0XHR2YXIgc3ViZGl2X3N0ZXAyID0gc3ViZGl2X3N0ZXAgKiBzdWJkaXZfc3RlcDtcblx0XHRcdFx0dmFyIHN1YmRpdl9zdGVwMyA9IHN1YmRpdl9zdGVwICogc3ViZGl2X3N0ZXAgKiBzdWJkaXZfc3RlcDtcblx0XHRcdFx0dmFyIHByZTEgPSAzICogc3ViZGl2X3N0ZXA7XG5cdFx0XHRcdHZhciBwcmUyID0gMyAqIHN1YmRpdl9zdGVwMjtcblx0XHRcdFx0dmFyIHByZTQgPSA2ICogc3ViZGl2X3N0ZXAyO1xuXHRcdFx0XHR2YXIgcHJlNSA9IDYgKiBzdWJkaXZfc3RlcDM7XG5cdFx0XHRcdHZhciB0bXAxeCA9IHgxIC0gY3gxICogMiArIGN4Mjtcblx0XHRcdFx0dmFyIHRtcDF5ID0geTEgLSBjeTEgKiAyICsgY3kyO1xuXHRcdFx0XHR2YXIgdG1wMnggPSAoY3gxIC0gY3gyKSAqIDMgLSB4MSArIHgyO1xuXHRcdFx0XHR2YXIgdG1wMnkgPSAoY3kxIC0gY3kyKSAqIDMgLSB5MSArIHkyO1xuXHRcdFx0XHR2YXIgZnggPSB4MTtcblx0XHRcdFx0dmFyIGZ5ID0geTE7XG5cdFx0XHRcdHZhciBkZnggPSAoY3gxIC0geDEpICogcHJlMSArIHRtcDF4ICogcHJlMiArIHRtcDJ4ICogc3ViZGl2X3N0ZXAzO1xuXHRcdFx0XHR2YXIgZGZ5ID0gKGN5MSAtIHkxKSAqIHByZTEgKyB0bXAxeSAqIHByZTIgKyB0bXAyeSAqIHN1YmRpdl9zdGVwMztcblx0XHRcdFx0dmFyIGRkZnggPSB0bXAxeCAqIHByZTQgKyB0bXAyeCAqIHByZTU7XG5cdFx0XHRcdHZhciBkZGZ5ID0gdG1wMXkgKiBwcmU0ICsgdG1wMnkgKiBwcmU1O1xuXHRcdFx0XHR2YXIgZGRkZnggPSB0bXAyeCAqIHByZTU7XG5cdFx0XHRcdHZhciBkZGRmeSA9IHRtcDJ5ICogcHJlNTtcblx0XHRcdFx0d2hpbGUgKHNlZ21lbnRzLS0gPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoZngsIGZ5LCBjb2xvcik7XG5cdFx0XHRcdFx0ZnggKz0gZGZ4O1xuXHRcdFx0XHRcdGZ5ICs9IGRmeTtcblx0XHRcdFx0XHRkZnggKz0gZGRmeDtcblx0XHRcdFx0XHRkZnkgKz0gZGRmeTtcblx0XHRcdFx0XHRkZGZ4ICs9IGRkZGZ4O1xuXHRcdFx0XHRcdGRkZnkgKz0gZGRkZnk7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXgoZngsIGZ5LCBjb2xvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy52ZXJ0ZXgoZngsIGZ5LCBjb2xvcik7XG5cdFx0XHRcdHRoaXMudmVydGV4KHgyLCB5MiwgY29sb3IpO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLnZlcnRleCA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvcikge1xuXHRcdFx0XHR2YXIgaWR4ID0gdGhpcy52ZXJ0ZXhJbmRleDtcblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5tZXNoLmdldFZlcnRpY2VzKCk7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IHg7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IHk7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IGNvbG9yLmI7XG5cdFx0XHRcdHZlcnRpY2VzW2lkeCsrXSA9IGNvbG9yLmE7XG5cdFx0XHRcdHRoaXMudmVydGV4SW5kZXggPSBpZHg7XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuaXNEcmF3aW5nKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNoYXBlUmVuZGVyZXIuYmVnaW4oKSBoYXMgbm90IGJlZW4gY2FsbGVkXCIpO1xuXHRcdFx0XHR0aGlzLmZsdXNoKCk7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5nbC5kaXNhYmxlKHRoaXMuY29udGV4dC5nbC5CTEVORCk7XG5cdFx0XHRcdHRoaXMuaXNEcmF3aW5nID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0U2hhcGVSZW5kZXJlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLnZlcnRleEluZGV4ID09IDApXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLm1lc2guc2V0VmVydGljZXNMZW5ndGgodGhpcy52ZXJ0ZXhJbmRleCk7XG5cdFx0XHRcdHRoaXMubWVzaC5kcmF3KHRoaXMuc2hhZGVyLCB0aGlzLnNoYXBlVHlwZSk7XG5cdFx0XHRcdHRoaXMudmVydGV4SW5kZXggPSAwO1xuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKHNoYXBlVHlwZSwgbnVtVmVydGljZXMpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmlzRHJhd2luZylcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZVJlbmRlcmVyLmJlZ2luKCkgaGFzIG5vdCBiZWVuIGNhbGxlZFwiKTtcblx0XHRcdFx0aWYgKHRoaXMuc2hhcGVUeXBlID09IHNoYXBlVHlwZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLm1lc2gubWF4VmVydGljZXMoKSAtIHRoaXMubWVzaC5udW1WZXJ0aWNlcygpIDwgbnVtVmVydGljZXMpXG5cdFx0XHRcdFx0XHR0aGlzLmZsdXNoKCk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZmx1c2goKTtcblx0XHRcdFx0XHR0aGlzLnNoYXBlVHlwZSA9IHNoYXBlVHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNoYXBlUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMubWVzaC5kaXNwb3NlKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIFNoYXBlUmVuZGVyZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5TaGFwZVJlbmRlcmVyID0gU2hhcGVSZW5kZXJlcjtcblx0XHQoZnVuY3Rpb24gKFNoYXBlVHlwZSkge1xuXHRcdFx0U2hhcGVUeXBlW1NoYXBlVHlwZVtcIlBvaW50XCJdID0gMF0gPSBcIlBvaW50XCI7XG5cdFx0XHRTaGFwZVR5cGVbU2hhcGVUeXBlW1wiTGluZVwiXSA9IDFdID0gXCJMaW5lXCI7XG5cdFx0XHRTaGFwZVR5cGVbU2hhcGVUeXBlW1wiRmlsbGVkXCJdID0gNF0gPSBcIkZpbGxlZFwiO1xuXHRcdH0pKHdlYmdsLlNoYXBlVHlwZSB8fCAod2ViZ2wuU2hhcGVUeXBlID0ge30pKTtcblx0XHR2YXIgU2hhcGVUeXBlID0gd2ViZ2wuU2hhcGVUeXBlO1xuXHR9KSh3ZWJnbCA9IHNwaW5lLndlYmdsIHx8IChzcGluZS53ZWJnbCA9IHt9KSk7XG59KShzcGluZSB8fCAoc3BpbmUgPSB7fSkpO1xudmFyIHNwaW5lO1xuKGZ1bmN0aW9uIChzcGluZSkge1xuXHR2YXIgd2ViZ2w7XG5cdChmdW5jdGlvbiAod2ViZ2wpIHtcblx0XHR2YXIgU2tlbGV0b25EZWJ1Z1JlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFNrZWxldG9uRGVidWdSZW5kZXJlcihjb250ZXh0KSB7XG5cdFx0XHRcdHRoaXMuYm9uZUxpbmVDb2xvciA9IG5ldyBzcGluZS5Db2xvcigxLCAwLCAwLCAxKTtcblx0XHRcdFx0dGhpcy5ib25lT3JpZ2luQ29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMCwgMSwgMCwgMSk7XG5cdFx0XHRcdHRoaXMuYXR0YWNobWVudExpbmVDb2xvciA9IG5ldyBzcGluZS5Db2xvcigwLCAwLCAxLCAwLjUpO1xuXHRcdFx0XHR0aGlzLnRyaWFuZ2xlTGluZUNvbG9yID0gbmV3IHNwaW5lLkNvbG9yKDEsIDAuNjQsIDAsIDAuNSk7XG5cdFx0XHRcdHRoaXMucGF0aENvbG9yID0gbmV3IHNwaW5lLkNvbG9yKCkuc2V0RnJvbVN0cmluZyhcIkZGN0YwMFwiKTtcblx0XHRcdFx0dGhpcy5jbGlwQ29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMC44LCAwLCAwLCAyKTtcblx0XHRcdFx0dGhpcy5hYWJiQ29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoMCwgMSwgMCwgMC41KTtcblx0XHRcdFx0dGhpcy5kcmF3Qm9uZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmRyYXdSZWdpb25BdHRhY2htZW50cyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZHJhd0JvdW5kaW5nQm94ZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmRyYXdNZXNoSHVsbCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZHJhd01lc2hUcmlhbmdsZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmRyYXdQYXRocyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZHJhd1NrZWxldG9uWFkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5kcmF3Q2xpcHBpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHRcdFx0dGhpcy5ib25lV2lkdGggPSAyO1xuXHRcdFx0XHR0aGlzLmJvdW5kcyA9IG5ldyBzcGluZS5Ta2VsZXRvbkJvdW5kcygpO1xuXHRcdFx0XHR0aGlzLnRlbXAgPSBuZXcgQXJyYXkoKTtcblx0XHRcdFx0dGhpcy52ZXJ0aWNlcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkoMiAqIDEwMjQpO1xuXHRcdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2Ygd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/IGNvbnRleHQgOiBuZXcgd2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dChjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdFNrZWxldG9uRGVidWdSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChzaGFwZXMsIHNrZWxldG9uLCBpZ25vcmVkQm9uZXMpIHtcblx0XHRcdFx0aWYgKGlnbm9yZWRCb25lcyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRCb25lcyA9IG51bGw7IH1cblx0XHRcdFx0dmFyIHNrZWxldG9uWCA9IHNrZWxldG9uLng7XG5cdFx0XHRcdHZhciBza2VsZXRvblkgPSBza2VsZXRvbi55O1xuXHRcdFx0XHR2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cdFx0XHRcdHZhciBzcmNGdW5jID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPyBnbC5PTkUgOiBnbC5TUkNfQUxQSEE7XG5cdFx0XHRcdHNoYXBlcy5zZXRCbGVuZE1vZGUoc3JjRnVuYywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdFx0XHRcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xuXHRcdFx0XHRpZiAodGhpcy5kcmF3Qm9uZXMpIHtcblx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IodGhpcy5ib25lTGluZUNvbG9yKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdFx0XHRcdGlmIChpZ25vcmVkQm9uZXMgJiYgaWdub3JlZEJvbmVzLmluZGV4T2YoYm9uZS5kYXRhLm5hbWUpID4gLTEpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aWYgKGJvbmUucGFyZW50ID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0dmFyIHggPSBza2VsZXRvblggKyBib25lLmRhdGEubGVuZ3RoICogYm9uZS5hICsgYm9uZS53b3JsZFg7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IHNrZWxldG9uWSArIGJvbmUuZGF0YS5sZW5ndGggKiBib25lLmMgKyBib25lLndvcmxkWTtcblx0XHRcdFx0XHRcdHNoYXBlcy5yZWN0TGluZSh0cnVlLCBza2VsZXRvblggKyBib25lLndvcmxkWCwgc2tlbGV0b25ZICsgYm9uZS53b3JsZFksIHgsIHksIHRoaXMuYm9uZVdpZHRoICogdGhpcy5zY2FsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLmRyYXdTa2VsZXRvblhZKVxuXHRcdFx0XHRcdFx0c2hhcGVzLngoc2tlbGV0b25YLCBza2VsZXRvblksIDQgKiB0aGlzLnNjYWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5kcmF3UmVnaW9uQXR0YWNobWVudHMpIHtcblx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IodGhpcy5hdHRhY2htZW50TGluZUNvbG9yKTtcblx0XHRcdFx0XHR2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3QgPSBzbG90c1tpXTtcblx0XHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlZ2lvbkF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuXHRcdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHRcdFx0XHRyZWdpb25BdHRhY2htZW50LmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QuYm9uZSwgdmVydGljZXMsIDAsIDIpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh2ZXJ0aWNlc1swXSwgdmVydGljZXNbMV0sIHZlcnRpY2VzWzJdLCB2ZXJ0aWNlc1szXSk7XG5cdFx0XHRcdFx0XHRcdHNoYXBlcy5saW5lKHZlcnRpY2VzWzJdLCB2ZXJ0aWNlc1szXSwgdmVydGljZXNbNF0sIHZlcnRpY2VzWzVdKTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzLmxpbmUodmVydGljZXNbNF0sIHZlcnRpY2VzWzVdLCB2ZXJ0aWNlc1s2XSwgdmVydGljZXNbN10pO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh2ZXJ0aWNlc1s2XSwgdmVydGljZXNbN10sIHZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1sxXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmRyYXdNZXNoSHVsbCB8fCB0aGlzLmRyYXdNZXNoVHJpYW5nbGVzKSB7XG5cdFx0XHRcdFx0dmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBzbG90ID0gc2xvdHNbaV07XG5cdFx0XHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xuXHRcdFx0XHRcdFx0aWYgKCEoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLk1lc2hBdHRhY2htZW50KSlcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR2YXIgbWVzaCA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHRcdFx0bWVzaC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCBtZXNoLndvcmxkVmVydGljZXNMZW5ndGgsIHZlcnRpY2VzLCAwLCAyKTtcblx0XHRcdFx0XHRcdHZhciB0cmlhbmdsZXMgPSBtZXNoLnRyaWFuZ2xlcztcblx0XHRcdFx0XHRcdHZhciBodWxsTGVuZ3RoID0gbWVzaC5odWxsTGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZHJhd01lc2hUcmlhbmdsZXMpIHtcblx0XHRcdFx0XHRcdFx0c2hhcGVzLnNldENvbG9yKHRoaXMudHJpYW5nbGVMaW5lQ29sb3IpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IDAsIG5uID0gdHJpYW5nbGVzLmxlbmd0aDsgaWkgPCBubjsgaWkgKz0gMykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB2MSA9IHRyaWFuZ2xlc1tpaV0gKiAyLCB2MiA9IHRyaWFuZ2xlc1tpaSArIDFdICogMiwgdjMgPSB0cmlhbmdsZXNbaWkgKyAyXSAqIDI7XG5cdFx0XHRcdFx0XHRcdFx0c2hhcGVzLnRyaWFuZ2xlKGZhbHNlLCB2ZXJ0aWNlc1t2MV0sIHZlcnRpY2VzW3YxICsgMV0sIHZlcnRpY2VzW3YyXSwgdmVydGljZXNbdjIgKyAxXSwgdmVydGljZXNbdjNdLCB2ZXJ0aWNlc1t2MyArIDFdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZHJhd01lc2hIdWxsICYmIGh1bGxMZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHNoYXBlcy5zZXRDb2xvcih0aGlzLmF0dGFjaG1lbnRMaW5lQ29sb3IpO1xuXHRcdFx0XHRcdFx0XHRodWxsTGVuZ3RoID0gKGh1bGxMZW5ndGggPj4gMSkgKiAyO1xuXHRcdFx0XHRcdFx0XHR2YXIgbGFzdFggPSB2ZXJ0aWNlc1todWxsTGVuZ3RoIC0gMl0sIGxhc3RZID0gdmVydGljZXNbaHVsbExlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IDAsIG5uID0gaHVsbExlbmd0aDsgaWkgPCBubjsgaWkgKz0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4ID0gdmVydGljZXNbaWldLCB5ID0gdmVydGljZXNbaWkgKyAxXTtcblx0XHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh4LCB5LCBsYXN0WCwgbGFzdFkpO1xuXHRcdFx0XHRcdFx0XHRcdGxhc3RYID0geDtcblx0XHRcdFx0XHRcdFx0XHRsYXN0WSA9IHk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZHJhd0JvdW5kaW5nQm94ZXMpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5ib3VuZHM7XG5cdFx0XHRcdFx0Ym91bmRzLnVwZGF0ZShza2VsZXRvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0c2hhcGVzLnNldENvbG9yKHRoaXMuYWFiYkNvbG9yKTtcblx0XHRcdFx0XHRzaGFwZXMucmVjdChmYWxzZSwgYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZLCBib3VuZHMuZ2V0V2lkdGgoKSwgYm91bmRzLmdldEhlaWdodCgpKTtcblx0XHRcdFx0XHR2YXIgcG9seWdvbnMgPSBib3VuZHMucG9seWdvbnM7XG5cdFx0XHRcdFx0dmFyIGJveGVzID0gYm91bmRzLmJvdW5kaW5nQm94ZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBwb2x5Z29uID0gcG9seWdvbnNbaV07XG5cdFx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IoYm94ZXNbaV0uY29sb3IpO1xuXHRcdFx0XHRcdFx0c2hhcGVzLnBvbHlnb24ocG9seWdvbiwgMCwgcG9seWdvbi5sZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5kcmF3UGF0aHMpIHtcblx0XHRcdFx0XHR2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3QgPSBzbG90c1tpXTtcblx0XHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cdFx0XHRcdFx0XHRpZiAoIShhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUGF0aEF0dGFjaG1lbnQpKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdHZhciBwYXRoID0gYXR0YWNobWVudDtcblx0XHRcdFx0XHRcdHZhciBubiA9IHBhdGgud29ybGRWZXJ0aWNlc0xlbmd0aDtcblx0XHRcdFx0XHRcdHZhciB3b3JsZCA9IHRoaXMudGVtcCA9IHNwaW5lLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLnRlbXAsIG5uLCAwKTtcblx0XHRcdFx0XHRcdHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdCwgMCwgbm4sIHdvcmxkLCAwLCAyKTtcblx0XHRcdFx0XHRcdHZhciBjb2xvciA9IHRoaXMucGF0aENvbG9yO1xuXHRcdFx0XHRcdFx0dmFyIHgxID0gd29ybGRbMl0sIHkxID0gd29ybGRbM10sIHgyID0gMCwgeTIgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKHBhdGguY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHNoYXBlcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHRcdFx0XHRcdHZhciBjeDEgPSB3b3JsZFswXSwgY3kxID0gd29ybGRbMV0sIGN4MiA9IHdvcmxkW25uIC0gMl0sIGN5MiA9IHdvcmxkW25uIC0gMV07XG5cdFx0XHRcdFx0XHRcdHgyID0gd29ybGRbbm4gLSA0XTtcblx0XHRcdFx0XHRcdFx0eTIgPSB3b3JsZFtubiAtIDNdO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMuY3VydmUoeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5MiwgMzIpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IoU2tlbGV0b25EZWJ1Z1JlbmRlcmVyLkxJR0hUX0dSQVkpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh4MSwgeTEsIGN4MSwgY3kxKTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzLmxpbmUoeDIsIHkyLCBjeDIsIGN5Mik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRubiAtPSA0O1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSA0OyBpaSA8IG5uOyBpaSArPSA2KSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjeDEgPSB3b3JsZFtpaV0sIGN5MSA9IHdvcmxkW2lpICsgMV0sIGN4MiA9IHdvcmxkW2lpICsgMl0sIGN5MiA9IHdvcmxkW2lpICsgM107XG5cdFx0XHRcdFx0XHRcdHgyID0gd29ybGRbaWkgKyA0XTtcblx0XHRcdFx0XHRcdFx0eTIgPSB3b3JsZFtpaSArIDVdO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IoY29sb3IpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMuY3VydmUoeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5MiwgMzIpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMuc2V0Q29sb3IoU2tlbGV0b25EZWJ1Z1JlbmRlcmVyLkxJR0hUX0dSQVkpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh4MSwgeTEsIGN4MSwgY3kxKTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzLmxpbmUoeDIsIHkyLCBjeDIsIGN5Mik7XG5cdFx0XHRcdFx0XHRcdHgxID0geDI7XG5cdFx0XHRcdFx0XHRcdHkxID0geTI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmRyYXdCb25lcykge1xuXHRcdFx0XHRcdHNoYXBlcy5zZXRDb2xvcih0aGlzLmJvbmVPcmlnaW5Db2xvcik7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoaWdub3JlZEJvbmVzICYmIGlnbm9yZWRCb25lcy5pbmRleE9mKGJvbmUuZGF0YS5uYW1lKSA+IC0xKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdHNoYXBlcy5jaXJjbGUodHJ1ZSwgc2tlbGV0b25YICsgYm9uZS53b3JsZFgsIHNrZWxldG9uWSArIGJvbmUud29ybGRZLCAzICogdGhpcy5zY2FsZSwgU2tlbGV0b25EZWJ1Z1JlbmRlcmVyLkdSRUVOLCA4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZHJhd0NsaXBwaW5nKSB7XG5cdFx0XHRcdFx0dmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XG5cdFx0XHRcdFx0c2hhcGVzLnNldENvbG9yKHRoaXMuY2xpcENvbG9yKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3QgPSBzbG90c1tpXTtcblx0XHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cdFx0XHRcdFx0XHRpZiAoIShhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuQ2xpcHBpbmdBdHRhY2htZW50KSlcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR2YXIgY2xpcCA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0XHR2YXIgbm4gPSBjbGlwLndvcmxkVmVydGljZXNMZW5ndGg7XG5cdFx0XHRcdFx0XHR2YXIgd29ybGQgPSB0aGlzLnRlbXAgPSBzcGluZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy50ZW1wLCBubiwgMCk7XG5cdFx0XHRcdFx0XHRjbGlwLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIG5uLCB3b3JsZCwgMCwgMik7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpXzUgPSAwLCBuXzIgPSB3b3JsZC5sZW5ndGg7IGlfNSA8IG5fMjsgaV81ICs9IDIpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHggPSB3b3JsZFtpXzVdO1xuXHRcdFx0XHRcdFx0XHR2YXIgeSA9IHdvcmxkW2lfNSArIDFdO1xuXHRcdFx0XHRcdFx0XHR2YXIgeDIgPSB3b3JsZFsoaV81ICsgMikgJSB3b3JsZC5sZW5ndGhdO1xuXHRcdFx0XHRcdFx0XHR2YXIgeTIgPSB3b3JsZFsoaV81ICsgMykgJSB3b3JsZC5sZW5ndGhdO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXMubGluZSh4LCB5LCB4MiwgeTIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNrZWxldG9uRGVidWdSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdH07XG5cdFx0XHRTa2VsZXRvbkRlYnVnUmVuZGVyZXIuTElHSFRfR1JBWSA9IG5ldyBzcGluZS5Db2xvcigxOTIgLyAyNTUsIDE5MiAvIDI1NSwgMTkyIC8gMjU1LCAxKTtcblx0XHRcdFNrZWxldG9uRGVidWdSZW5kZXJlci5HUkVFTiA9IG5ldyBzcGluZS5Db2xvcigwLCAxLCAwLCAxKTtcblx0XHRcdHJldHVybiBTa2VsZXRvbkRlYnVnUmVuZGVyZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5Ta2VsZXRvbkRlYnVnUmVuZGVyZXIgPSBTa2VsZXRvbkRlYnVnUmVuZGVyZXI7XG5cdH0pKHdlYmdsID0gc3BpbmUud2ViZ2wgfHwgKHNwaW5lLndlYmdsID0ge30pKTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciB3ZWJnbDtcblx0KGZ1bmN0aW9uICh3ZWJnbCkge1xuXHRcdHZhciBSZW5kZXJhYmxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFJlbmRlcmFibGUodmVydGljZXMsIG51bVZlcnRpY2VzLCBudW1GbG9hdHMpIHtcblx0XHRcdFx0dGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXHRcdFx0XHR0aGlzLm51bVZlcnRpY2VzID0gbnVtVmVydGljZXM7XG5cdFx0XHRcdHRoaXMubnVtRmxvYXRzID0gbnVtRmxvYXRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFJlbmRlcmFibGU7XG5cdFx0fSgpKTtcblx0XHQ7XG5cdFx0dmFyIFNrZWxldG9uUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ZnVuY3Rpb24gU2tlbGV0b25SZW5kZXJlcihjb250ZXh0LCB0d29Db2xvclRpbnQpIHtcblx0XHRcdFx0aWYgKHR3b0NvbG9yVGludCA9PT0gdm9pZCAwKSB7IHR3b0NvbG9yVGludCA9IHRydWU7IH1cblx0XHRcdFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy50ZW1wQ29sb3IgPSBuZXcgc3BpbmUuQ29sb3IoKTtcblx0XHRcdFx0dGhpcy50ZW1wQ29sb3IyID0gbmV3IHNwaW5lLkNvbG9yKCk7XG5cdFx0XHRcdHRoaXMudmVydGV4U2l6ZSA9IDIgKyAyICsgNDtcblx0XHRcdFx0dGhpcy50d29Db2xvclRpbnQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5yZW5kZXJhYmxlID0gbmV3IFJlbmRlcmFibGUobnVsbCwgMCwgMCk7XG5cdFx0XHRcdHRoaXMuY2xpcHBlciA9IG5ldyBzcGluZS5Ta2VsZXRvbkNsaXBwaW5nKCk7XG5cdFx0XHRcdHRoaXMudHdvQ29sb3JUaW50ID0gdHdvQ29sb3JUaW50O1xuXHRcdFx0XHRpZiAodHdvQ29sb3JUaW50KVxuXHRcdFx0XHRcdHRoaXMudmVydGV4U2l6ZSArPSA0O1xuXHRcdFx0XHR0aGlzLnZlcnRpY2VzID0gc3BpbmUuVXRpbHMubmV3RmxvYXRBcnJheSh0aGlzLnZlcnRleFNpemUgKiAxMDI0KTtcblx0XHRcdH1cblx0XHRcdFNrZWxldG9uUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoYmF0Y2hlciwgc2tlbGV0b24pIHtcblx0XHRcdFx0dmFyIGNsaXBwZXIgPSB0aGlzLmNsaXBwZXI7XG5cdFx0XHRcdHZhciBwcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdFx0dmFyIHR3b0NvbG9yVGludCA9IHRoaXMudHdvQ29sb3JUaW50O1xuXHRcdFx0XHR2YXIgYmxlbmRNb2RlID0gbnVsbDtcblx0XHRcdFx0dmFyIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG5cdFx0XHRcdHZhciB1dnMgPSBudWxsO1xuXHRcdFx0XHR2YXIgdHJpYW5nbGVzID0gbnVsbDtcblx0XHRcdFx0dmFyIGRyYXdPcmRlciA9IHNrZWxldG9uLmRyYXdPcmRlcjtcblx0XHRcdFx0dmFyIGF0dGFjaG1lbnRDb2xvciA9IG51bGw7XG5cdFx0XHRcdHZhciBza2VsZXRvbkNvbG9yID0gc2tlbGV0b24uY29sb3I7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhTaXplID0gdHdvQ29sb3JUaW50ID8gMTIgOiA4O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2xpcHBlZFZlcnRleFNpemUgPSBjbGlwcGVyLmlzQ2xpcHBpbmcoKSA/IDIgOiB2ZXJ0ZXhTaXplO1xuXHRcdFx0XHRcdHZhciBzbG90ID0gZHJhd09yZGVyW2ldO1xuXHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cdFx0XHRcdFx0dmFyIHRleHR1cmUgPSBudWxsO1xuXHRcdFx0XHRcdGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUmVnaW9uQXR0YWNobWVudCkge1xuXHRcdFx0XHRcdFx0dmFyIHJlZ2lvbiA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0XHRyZW5kZXJhYmxlLnZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdHJlbmRlcmFibGUubnVtVmVydGljZXMgPSA0O1xuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZS5udW1GbG9hdHMgPSBjbGlwcGVkVmVydGV4U2l6ZSA8PCAyO1xuXHRcdFx0XHRcdFx0cmVnaW9uLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QuYm9uZSwgcmVuZGVyYWJsZS52ZXJ0aWNlcywgMCwgY2xpcHBlZFZlcnRleFNpemUpO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGVzID0gU2tlbGV0b25SZW5kZXJlci5RVUFEX1RSSUFOR0xFUztcblx0XHRcdFx0XHRcdHV2cyA9IHJlZ2lvbi51dnM7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gcmVnaW9uLnJlZ2lvbi5yZW5kZXJPYmplY3QudGV4dHVyZTtcblx0XHRcdFx0XHRcdGF0dGFjaG1lbnRDb2xvciA9IHJlZ2lvbi5jb2xvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLk1lc2hBdHRhY2htZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgbWVzaCA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdFx0XHRyZW5kZXJhYmxlLnZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdHJlbmRlcmFibGUubnVtVmVydGljZXMgPSAobWVzaC53b3JsZFZlcnRpY2VzTGVuZ3RoID4+IDEpO1xuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZS5udW1GbG9hdHMgPSByZW5kZXJhYmxlLm51bVZlcnRpY2VzICogY2xpcHBlZFZlcnRleFNpemU7XG5cdFx0XHRcdFx0XHRpZiAocmVuZGVyYWJsZS5udW1GbG9hdHMgPiByZW5kZXJhYmxlLnZlcnRpY2VzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJhYmxlLnZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyA9IHNwaW5lLlV0aWxzLm5ld0Zsb2F0QXJyYXkocmVuZGVyYWJsZS5udW1GbG9hdHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWVzaC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCBtZXNoLndvcmxkVmVydGljZXNMZW5ndGgsIHJlbmRlcmFibGUudmVydGljZXMsIDAsIGNsaXBwZWRWZXJ0ZXhTaXplKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlcyA9IG1lc2gudHJpYW5nbGVzO1xuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IG1lc2gucmVnaW9uLnJlbmRlck9iamVjdC50ZXh0dXJlO1xuXHRcdFx0XHRcdFx0dXZzID0gbWVzaC51dnM7XG5cdFx0XHRcdFx0XHRhdHRhY2htZW50Q29sb3IgPSBtZXNoLmNvbG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuQ2xpcHBpbmdBdHRhY2htZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgY2xpcCA9IChhdHRhY2htZW50KTtcblx0XHRcdFx0XHRcdGNsaXBwZXIuY2xpcFN0YXJ0KHNsb3QsIGNsaXApO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmICh0ZXh0dXJlICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBzbG90Q29sb3IgPSBzbG90LmNvbG9yO1xuXHRcdFx0XHRcdFx0dmFyIGZpbmFsQ29sb3IgPSB0aGlzLnRlbXBDb2xvcjtcblx0XHRcdFx0XHRcdGZpbmFsQ29sb3IuciA9IHNrZWxldG9uQ29sb3IuciAqIHNsb3RDb2xvci5yICogYXR0YWNobWVudENvbG9yLnI7XG5cdFx0XHRcdFx0XHRmaW5hbENvbG9yLmcgPSBza2VsZXRvbkNvbG9yLmcgKiBzbG90Q29sb3IuZyAqIGF0dGFjaG1lbnRDb2xvci5nO1xuXHRcdFx0XHRcdFx0ZmluYWxDb2xvci5iID0gc2tlbGV0b25Db2xvci5iICogc2xvdENvbG9yLmIgKiBhdHRhY2htZW50Q29sb3IuYjtcblx0XHRcdFx0XHRcdGZpbmFsQ29sb3IuYSA9IHNrZWxldG9uQ29sb3IuYSAqIHNsb3RDb2xvci5hICogYXR0YWNobWVudENvbG9yLmE7XG5cdFx0XHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRcdFx0XHRcdGZpbmFsQ29sb3IuciAqPSBmaW5hbENvbG9yLmE7XG5cdFx0XHRcdFx0XHRcdGZpbmFsQ29sb3IuZyAqPSBmaW5hbENvbG9yLmE7XG5cdFx0XHRcdFx0XHRcdGZpbmFsQ29sb3IuYiAqPSBmaW5hbENvbG9yLmE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgZGFya0NvbG9yID0gdGhpcy50ZW1wQ29sb3IyO1xuXHRcdFx0XHRcdFx0aWYgKHNsb3QuZGFya0NvbG9yID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGRhcmtDb2xvci5zZXQoMCwgMCwgMCwgMSk7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGRhcmtDb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXJrQ29sb3IpO1xuXHRcdFx0XHRcdFx0dmFyIHNsb3RCbGVuZE1vZGUgPSBzbG90LmRhdGEuYmxlbmRNb2RlO1xuXHRcdFx0XHRcdFx0aWYgKHNsb3RCbGVuZE1vZGUgIT0gYmxlbmRNb2RlKSB7XG5cdFx0XHRcdFx0XHRcdGJsZW5kTW9kZSA9IHNsb3RCbGVuZE1vZGU7XG5cdFx0XHRcdFx0XHRcdGJhdGNoZXIuc2V0QmxlbmRNb2RlKHdlYmdsLldlYkdMQmxlbmRNb2RlQ29udmVydGVyLmdldFNvdXJjZUdMQmxlbmRNb2RlKGJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZEFscGhhKSwgd2ViZ2wuV2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuZ2V0RGVzdEdMQmxlbmRNb2RlKGJsZW5kTW9kZSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGNsaXBwZXIuaXNDbGlwcGluZygpKSB7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZXIuY2xpcFRyaWFuZ2xlcyhyZW5kZXJhYmxlLnZlcnRpY2VzLCByZW5kZXJhYmxlLm51bUZsb2F0cywgdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoLCB1dnMsIGZpbmFsQ29sb3IsIGRhcmtDb2xvciwgdHdvQ29sb3JUaW50KTtcblx0XHRcdFx0XHRcdFx0dmFyIGNsaXBwZWRWZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoY2xpcHBlci5jbGlwcGVkVmVydGljZXMpO1xuXHRcdFx0XHRcdFx0XHR2YXIgY2xpcHBlZFRyaWFuZ2xlcyA9IGNsaXBwZXIuY2xpcHBlZFRyaWFuZ2xlcztcblx0XHRcdFx0XHRcdFx0YmF0Y2hlci5kcmF3KHRleHR1cmUsIGNsaXBwZWRWZXJ0aWNlcywgY2xpcHBlZFRyaWFuZ2xlcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZlcnRzID0gcmVuZGVyYWJsZS52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdFx0aWYgKCF0d29Db2xvclRpbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciB2ID0gMiwgdSA9IDAsIG5fMyA9IHJlbmRlcmFibGUubnVtRmxvYXRzOyB2IDwgbl8zOyB2ICs9IHZlcnRleFNpemUsIHUgKz0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmVydHNbdl0gPSBmaW5hbENvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgMV0gPSBmaW5hbENvbG9yLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgMl0gPSBmaW5hbENvbG9yLmI7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgM10gPSBmaW5hbENvbG9yLmE7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgNF0gPSB1dnNbdV07XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgNV0gPSB1dnNbdSArIDFdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciB2ID0gMiwgdSA9IDAsIG5fNCA9IHJlbmRlcmFibGUubnVtRmxvYXRzOyB2IDwgbl80OyB2ICs9IHZlcnRleFNpemUsIHUgKz0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmVydHNbdl0gPSBmaW5hbENvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgMV0gPSBmaW5hbENvbG9yLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgMl0gPSBmaW5hbENvbG9yLmI7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgM10gPSBmaW5hbENvbG9yLmE7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgNF0gPSB1dnNbdV07XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgNV0gPSB1dnNbdSArIDFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmVydHNbdiArIDZdID0gZGFya0NvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0c1t2ICsgN10gPSBkYXJrQ29sb3IuZztcblx0XHRcdFx0XHRcdFx0XHRcdHZlcnRzW3YgKyA4XSA9IGRhcmtDb2xvci5iO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmVydHNbdiArIDldID0gZGFya0NvbG9yLmE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhciB2aWV3ID0gcmVuZGVyYWJsZS52ZXJ0aWNlcy5zdWJhcnJheSgwLCByZW5kZXJhYmxlLm51bUZsb2F0cyk7XG5cdFx0XHRcdFx0XHRcdGJhdGNoZXIuZHJhdyh0ZXh0dXJlLCB2aWV3LCB0cmlhbmdsZXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGlwcGVyLmNsaXBFbmRXaXRoU2xvdChzbG90KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGlwcGVyLmNsaXBFbmQoKTtcblx0XHRcdH07XG5cdFx0XHRTa2VsZXRvblJlbmRlcmVyLlFVQURfVFJJQU5HTEVTID0gWzAsIDEsIDIsIDIsIDMsIDBdO1xuXHRcdFx0cmV0dXJuIFNrZWxldG9uUmVuZGVyZXI7XG5cdFx0fSgpKTtcblx0XHR3ZWJnbC5Ta2VsZXRvblJlbmRlcmVyID0gU2tlbGV0b25SZW5kZXJlcjtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIHdlYmdsO1xuXHQoZnVuY3Rpb24gKHdlYmdsKSB7XG5cdFx0dmFyIFZlY3RvcjMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ZnVuY3Rpb24gVmVjdG9yMyh4LCB5LCB6KSB7XG5cdFx0XHRcdGlmICh4ID09PSB2b2lkIDApIHsgeCA9IDA7IH1cblx0XHRcdFx0aWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gMDsgfVxuXHRcdFx0XHRpZiAoeiA9PT0gdm9pZCAwKSB7IHogPSAwOyB9XG5cdFx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMueiA9IDA7XG5cdFx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRcdHRoaXMueiA9IHo7XG5cdFx0XHR9XG5cdFx0XHRWZWN0b3IzLnByb3RvdHlwZS5zZXRGcm9tID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0XHRcdHRoaXMueiA9IHYuejtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0VmVjdG9yMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcblx0XHRcdFx0dGhpcy54ID0geDtcblx0XHRcdFx0dGhpcy55ID0geTtcblx0XHRcdFx0dGhpcy56ID0gejtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0VmVjdG9yMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0dGhpcy54ICs9IHYueDtcblx0XHRcdFx0dGhpcy55ICs9IHYueTtcblx0XHRcdFx0dGhpcy56ICs9IHYuejtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0VmVjdG9yMy5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0dGhpcy54IC09IHYueDtcblx0XHRcdFx0dGhpcy55IC09IHYueTtcblx0XHRcdFx0dGhpcy56IC09IHYuejtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0VmVjdG9yMy5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAocykge1xuXHRcdFx0XHR0aGlzLnggKj0gcztcblx0XHRcdFx0dGhpcy55ICo9IHM7XG5cdFx0XHRcdHRoaXMueiAqPSBzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRWZWN0b3IzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCgpO1xuXHRcdFx0XHRpZiAobGVuID09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdGxlbiA9IDEgLyBsZW47XG5cdFx0XHRcdHRoaXMueCAqPSBsZW47XG5cdFx0XHRcdHRoaXMueSAqPSBsZW47XG5cdFx0XHRcdHRoaXMueiAqPSBsZW47XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFZlY3RvcjMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHRoaXMueSAqIHYueiAtIHRoaXMueiAqIHYueSwgdGhpcy56ICogdi54IC0gdGhpcy54ICogdi56LCB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2LngpO1xuXHRcdFx0fTtcblx0XHRcdFZlY3RvcjMucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuXHRcdFx0XHR2YXIgbF9tYXQgPSBtYXRyaXgudmFsdWVzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQodGhpcy54ICogbF9tYXRbd2ViZ2wuTTAwXSArIHRoaXMueSAqIGxfbWF0W3dlYmdsLk0wMV0gKyB0aGlzLnogKiBsX21hdFt3ZWJnbC5NMDJdICsgbF9tYXRbd2ViZ2wuTTAzXSwgdGhpcy54ICogbF9tYXRbd2ViZ2wuTTEwXSArIHRoaXMueSAqIGxfbWF0W3dlYmdsLk0xMV0gKyB0aGlzLnogKiBsX21hdFt3ZWJnbC5NMTJdICsgbF9tYXRbd2ViZ2wuTTEzXSwgdGhpcy54ICogbF9tYXRbd2ViZ2wuTTIwXSArIHRoaXMueSAqIGxfbWF0W3dlYmdsLk0yMV0gKyB0aGlzLnogKiBsX21hdFt3ZWJnbC5NMjJdICsgbF9tYXRbd2ViZ2wuTTIzXSk7XG5cdFx0XHR9O1xuXHRcdFx0VmVjdG9yMy5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcblx0XHRcdFx0dmFyIGxfbWF0ID0gbWF0cml4LnZhbHVlcztcblx0XHRcdFx0dmFyIGxfdyA9IDEgLyAodGhpcy54ICogbF9tYXRbd2ViZ2wuTTMwXSArIHRoaXMueSAqIGxfbWF0W3dlYmdsLk0zMV0gKyB0aGlzLnogKiBsX21hdFt3ZWJnbC5NMzJdICsgbF9tYXRbd2ViZ2wuTTMzXSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldCgodGhpcy54ICogbF9tYXRbd2ViZ2wuTTAwXSArIHRoaXMueSAqIGxfbWF0W3dlYmdsLk0wMV0gKyB0aGlzLnogKiBsX21hdFt3ZWJnbC5NMDJdICsgbF9tYXRbd2ViZ2wuTTAzXSkgKiBsX3csICh0aGlzLnggKiBsX21hdFt3ZWJnbC5NMTBdICsgdGhpcy55ICogbF9tYXRbd2ViZ2wuTTExXSArIHRoaXMueiAqIGxfbWF0W3dlYmdsLk0xMl0gKyBsX21hdFt3ZWJnbC5NMTNdKSAqIGxfdywgKHRoaXMueCAqIGxfbWF0W3dlYmdsLk0yMF0gKyB0aGlzLnkgKiBsX21hdFt3ZWJnbC5NMjFdICsgdGhpcy56ICogbF9tYXRbd2ViZ2wuTTIyXSArIGxfbWF0W3dlYmdsLk0yM10pICogbF93KTtcblx0XHRcdH07XG5cdFx0XHRWZWN0b3IzLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAodikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXHRcdFx0fTtcblx0XHRcdFZlY3RvcjMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuXHRcdFx0fTtcblx0XHRcdFZlY3RvcjMucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnggLSB0aGlzLng7XG5cdFx0XHRcdHZhciBiID0gdi55IC0gdGhpcy55O1xuXHRcdFx0XHR2YXIgYyA9IHYueiAtIHRoaXMuejtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBWZWN0b3IzO1xuXHRcdH0oKSk7XG5cdFx0d2ViZ2wuVmVjdG9yMyA9IFZlY3RvcjM7XG5cdH0pKHdlYmdsID0gc3BpbmUud2ViZ2wgfHwgKHNwaW5lLndlYmdsID0ge30pKTtcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG52YXIgc3BpbmU7XG4oZnVuY3Rpb24gKHNwaW5lKSB7XG5cdHZhciB3ZWJnbDtcblx0KGZ1bmN0aW9uICh3ZWJnbCkge1xuXHRcdHZhciBNYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIE1hbmFnZWRXZWJHTFJlbmRlcmluZ0NvbnRleHQoY2FudmFzT3JDb250ZXh0LCBjb250ZXh0Q29uZmlnKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdGlmIChjb250ZXh0Q29uZmlnID09PSB2b2lkIDApIHsgY29udGV4dENvbmZpZyA9IHsgYWxwaGE6IFwidHJ1ZVwiIH07IH1cblx0XHRcdFx0dGhpcy5yZXN0b3JhYmxlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0XHRpZiAoY2FudmFzT3JDb250ZXh0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgY2FudmFzID0gY2FudmFzT3JDb250ZXh0O1xuXHRcdFx0XHRcdHRoaXMuZ2wgPSAoY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBjb250ZXh0Q29uZmlnKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBjb250ZXh0Q29uZmlnKSk7XG5cdFx0XHRcdFx0dGhpcy5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXZlbnQgPSBlO1xuXHRcdFx0XHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gX3RoaXMucmVzdG9yYWJsZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdF90aGlzLnJlc3RvcmFibGVzW2ldLnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmdsID0gY2FudmFzT3JDb250ZXh0O1xuXHRcdFx0XHRcdHRoaXMuY2FudmFzID0gdGhpcy5nbC5jYW52YXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdE1hbmFnZWRXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLmFkZFJlc3RvcmFibGUgPSBmdW5jdGlvbiAocmVzdG9yYWJsZSkge1xuXHRcdFx0XHR0aGlzLnJlc3RvcmFibGVzLnB1c2gocmVzdG9yYWJsZSk7XG5cdFx0XHR9O1xuXHRcdFx0TWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlUmVzdG9yYWJsZSA9IGZ1bmN0aW9uIChyZXN0b3JhYmxlKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IHRoaXMucmVzdG9yYWJsZXMuaW5kZXhPZihyZXN0b3JhYmxlKTtcblx0XHRcdFx0aWYgKGluZGV4ID4gLTEpXG5cdFx0XHRcdFx0dGhpcy5yZXN0b3JhYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBNYW5hZ2VkV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuXHRcdH0oKSk7XG5cdFx0d2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dCA9IE1hbmFnZWRXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cdFx0dmFyIFdlYkdMQmxlbmRNb2RlQ29udmVydGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFdlYkdMQmxlbmRNb2RlQ29udmVydGVyKCkge1xuXHRcdFx0fVxuXHRcdFx0V2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuZ2V0RGVzdEdMQmxlbmRNb2RlID0gZnVuY3Rpb24gKGJsZW5kTW9kZSkge1xuXHRcdFx0XHRzd2l0Y2ggKGJsZW5kTW9kZSkge1xuXHRcdFx0XHRcdGNhc2Ugc3BpbmUuQmxlbmRNb2RlLk5vcm1hbDogcmV0dXJuIFdlYkdMQmxlbmRNb2RlQ29udmVydGVyLk9ORV9NSU5VU19TUkNfQUxQSEE7XG5cdFx0XHRcdFx0Y2FzZSBzcGluZS5CbGVuZE1vZGUuQWRkaXRpdmU6IHJldHVybiBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkU7XG5cdFx0XHRcdFx0Y2FzZSBzcGluZS5CbGVuZE1vZGUuTXVsdGlwbHk6IHJldHVybiBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuXHRcdFx0XHRcdGNhc2Ugc3BpbmUuQmxlbmRNb2RlLlNjcmVlbjogcmV0dXJuIFdlYkdMQmxlbmRNb2RlQ29udmVydGVyLk9ORV9NSU5VU19TUkNfQUxQSEE7XG5cdFx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBibGVuZCBtb2RlOiBcIiArIGJsZW5kTW9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5nZXRTb3VyY2VHTEJsZW5kTW9kZSA9IGZ1bmN0aW9uIChibGVuZE1vZGUsIHByZW11bHRpcGxpZWRBbHBoYSkge1xuXHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhID09PSB2b2lkIDApIHsgcHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7IH1cblx0XHRcdFx0c3dpdGNoIChibGVuZE1vZGUpIHtcblx0XHRcdFx0XHRjYXNlIHNwaW5lLkJsZW5kTW9kZS5Ob3JtYWw6IHJldHVybiBwcmVtdWx0aXBsaWVkQWxwaGEgPyBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkUgOiBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5TUkNfQUxQSEE7XG5cdFx0XHRcdFx0Y2FzZSBzcGluZS5CbGVuZE1vZGUuQWRkaXRpdmU6IHJldHVybiBwcmVtdWx0aXBsaWVkQWxwaGEgPyBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkUgOiBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5TUkNfQUxQSEE7XG5cdFx0XHRcdFx0Y2FzZSBzcGluZS5CbGVuZE1vZGUuTXVsdGlwbHk6IHJldHVybiBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5EU1RfQ09MT1I7XG5cdFx0XHRcdFx0Y2FzZSBzcGluZS5CbGVuZE1vZGUuU2NyZWVuOiByZXR1cm4gV2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuT05FO1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYmxlbmQgbW9kZTogXCIgKyBibGVuZE1vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0V2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuWkVSTyA9IDA7XG5cdFx0XHRXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkUgPSAxO1xuXHRcdFx0V2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuU1JDX0NPTE9SID0gMHgwMzAwO1xuXHRcdFx0V2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuT05FX01JTlVTX1NSQ19DT0xPUiA9IDB4MDMwMTtcblx0XHRcdFdlYkdMQmxlbmRNb2RlQ29udmVydGVyLlNSQ19BTFBIQSA9IDB4MDMwMjtcblx0XHRcdFdlYkdMQmxlbmRNb2RlQ29udmVydGVyLk9ORV9NSU5VU19TUkNfQUxQSEEgPSAweDAzMDM7XG5cdFx0XHRXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5EU1RfQUxQSEEgPSAweDAzMDQ7XG5cdFx0XHRXZWJHTEJsZW5kTW9kZUNvbnZlcnRlci5PTkVfTUlOVVNfRFNUX0FMUEhBID0gMHgwMzA1O1xuXHRcdFx0V2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIuRFNUX0NPTE9SID0gMHgwMzA2O1xuXHRcdFx0cmV0dXJuIFdlYkdMQmxlbmRNb2RlQ29udmVydGVyO1xuXHRcdH0oKSk7XG5cdFx0d2ViZ2wuV2ViR0xCbGVuZE1vZGVDb252ZXJ0ZXIgPSBXZWJHTEJsZW5kTW9kZUNvbnZlcnRlcjtcblx0fSkod2ViZ2wgPSBzcGluZS53ZWJnbCB8fCAoc3BpbmUud2ViZ2wgPSB7fSkpO1xufSkoc3BpbmUgfHwgKHNwaW5lID0ge30pKTtcbnZhciBzcGluZTtcbihmdW5jdGlvbiAoc3BpbmUpIHtcblx0dmFyIFNwaW5lV2lkZ2V0ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBTcGluZVdpZGdldChlbGVtZW50LCBjb25maWcpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHR0aGlzLm12cCA9IG5ldyBzcGluZS53ZWJnbC5NYXRyaXg0KCk7XG5cdFx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5sYXN0RnJhbWVUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDAuMDtcblx0XHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IHNwaW5lLkNvbG9yKCk7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5ib3VuZHMgPSB7IG9mZnNldDogbmV3IHNwaW5lLlZlY3RvcjIoKSwgc2l6ZTogbmV3IHNwaW5lLlZlY3RvcjIoKSB9O1xuXHRcdFx0aWYgKCFlbGVtZW50KVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIERPTSBlbGVtZW50LCBlLmcuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteWVsZW1lbnQnKVwiKTtcblx0XHRcdGlmICghY29uZmlnKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGNvbmZpZ3VyYXRpb24sIHNwZWNpZnlpbmcgYXQgbGVhc3QgdGhlIGpzb24gZmlsZSwgYXRsYXMgZmlsZSBhbmQgYW5pbWF0aW9uIG5hbWVcIik7XG5cdFx0XHR2YXIgZWxlbWVudElkID0gZWxlbWVudDtcblx0XHRcdGlmICh0eXBlb2YgKGVsZW1lbnQpID09PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG5cdFx0XHRpZiAoZWxlbWVudCA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IFwiICsgZWxlbWVudElkICsgXCIgZG9lcyBub3QgZXhpc3RcIik7XG5cdFx0XHR0aGlzLnZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG5cdFx0XHR2YXIgZXhpc3RpbmdDYW52YXMgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuXHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzID0gZXhpc3RpbmdDYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuXHRcdFx0aWYgKCFleGlzdGluZ0NhbnZhcykge1xuXHRcdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cdFx0XHR9XG5cdFx0XHRjYW52YXMud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0dmFyIHdlYmdsQ29uZmlnID0geyBhbHBoYTogY29uZmlnLmFscGhhIH07XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBuZXcgc3BpbmUud2ViZ2wuTWFuYWdlZFdlYkdMUmVuZGVyaW5nQ29udGV4dChjYW52YXMsIHdlYmdsQ29uZmlnKTtcblx0XHRcdHRoaXMuc2hhZGVyID0gc3BpbmUud2ViZ2wuU2hhZGVyLm5ld1R3b0NvbG9yZWRUZXh0dXJlZCh0aGlzLmNvbnRleHQpO1xuXHRcdFx0dGhpcy5iYXRjaGVyID0gbmV3IHNwaW5lLndlYmdsLlBvbHlnb25CYXRjaGVyKHRoaXMuY29udGV4dCk7XG5cdFx0XHR0aGlzLm12cC5vcnRobzJkKDAsIDAsIGNhbnZhcy53aWR0aCAtIDEsIGNhbnZhcy5oZWlnaHQgLSAxKTtcblx0XHRcdHRoaXMuc2tlbGV0b25SZW5kZXJlciA9IG5ldyBzcGluZS53ZWJnbC5Ta2VsZXRvblJlbmRlcmVyKHRoaXMuY29udGV4dCk7XG5cdFx0XHR0aGlzLmRlYnVnU2hhZGVyID0gc3BpbmUud2ViZ2wuU2hhZGVyLm5ld0NvbG9yZWQodGhpcy5jb250ZXh0KTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJlciA9IG5ldyBzcGluZS53ZWJnbC5Ta2VsZXRvbkRlYnVnUmVuZGVyZXIodGhpcy5jb250ZXh0KTtcblx0XHRcdHRoaXMuc2hhcGVzID0gbmV3IHNwaW5lLndlYmdsLlNoYXBlUmVuZGVyZXIodGhpcy5jb250ZXh0KTtcblx0XHRcdHZhciBhc3NldHMgPSB0aGlzLmFzc2V0TWFuYWdlciA9IG5ldyBzcGluZS53ZWJnbC5Bc3NldE1hbmFnZXIodGhpcy5jb250ZXh0LCBjb25maWcuaW1hZ2VzUGF0aCA/IGNvbmZpZy5pbWFnZXNQYXRoIDogXCJcIik7XG5cdFx0XHRpZiAoIWNvbmZpZy5hdGxhc0NvbnRlbnQpIHtcblx0XHRcdFx0YXNzZXRzLmxvYWRUZXh0KGNvbmZpZy5hdGxhcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbmZpZy5qc29uQ29udGVudCkge1xuXHRcdFx0XHRhc3NldHMubG9hZFRleHQoY29uZmlnLmpzb24pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5hdGxhc1BhZ2VzID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGNvbmZpZy5hdGxhcykge1xuXHRcdFx0XHRcdHZhciBhdGxhc1BhZ2UgPSBjb25maWcuYXRsYXMucmVwbGFjZShcIi5hdGxhc1wiLCBcIi5wbmdcIik7XG5cdFx0XHRcdFx0aWYgKGF0bGFzUGFnZS5sYXN0SW5kZXhPZihjb25maWcuaW1hZ2VzUGF0aCkgPT0gMCkge1xuXHRcdFx0XHRcdFx0YXRsYXNQYWdlID0gYXRsYXNQYWdlLnN1YnN0cihjb25maWcuaW1hZ2VzUGF0aC5sZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhc3NldHMubG9hZFRleHR1cmUoYXRsYXNQYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgZmlyc3RMaW5lID0gY29uZmlnLmF0bGFzQ29udGVudC50cmltKCkuc3BsaXQoXCJcXG5cIilbMF07XG5cdFx0XHRcdFx0YXNzZXRzLmxvYWRUZXh0dXJlKGZpcnN0TGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5hdGxhc1BhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5hdGxhc1BhZ2VzQ29udGVudCAmJiBjb25maWcuYXRsYXNQYWdlc0NvbnRlbnRbaV0pIHtcblx0XHRcdFx0XHRcdGFzc2V0cy5sb2FkVGV4dHVyZURhdGEoY29uZmlnLmF0bGFzUGFnZXNbaV0sIGNvbmZpZy5hdGxhc1BhZ2VzQ29udGVudFswXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YXNzZXRzLmxvYWRUZXh0dXJlKGNvbmZpZy5hdGxhc1BhZ2VzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IF90aGlzLmxvYWQoKTsgfSk7XG5cdFx0fVxuXHRcdFNwaW5lV2lkZ2V0LnByb3RvdHlwZS52YWxpZGF0ZUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHRcdGlmICghY29uZmlnLmF0bGFzICYmICFjb25maWcuYXRsYXNDb250ZW50KVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBjb25maWcuYXRsYXMgb3IgY29uZmlnLmF0bGFzQ29udGVudFwiKTtcblx0XHRcdGlmICghY29uZmlnLmpzb24gJiYgIWNvbmZpZy5qc29uQ29udGVudClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgY29uZmlnLmpzb24gb3IgY29uZmlnLmpzb25Db250ZW50XCIpO1xuXHRcdFx0aWYgKCFjb25maWcuYW5pbWF0aW9uKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBjb25maWcuYW5pbWF0aW9uTmFtZVwiKTtcblx0XHRcdGlmICghY29uZmlnLnNjYWxlKVxuXHRcdFx0XHRjb25maWcuc2NhbGUgPSAxLjA7XG5cdFx0XHRpZiAoIWNvbmZpZy5za2luKVxuXHRcdFx0XHRjb25maWcuc2tpbiA9IFwiZGVmYXVsdFwiO1xuXHRcdFx0aWYgKGNvbmZpZy5sb29wID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGNvbmZpZy5sb29wID0gdHJ1ZTtcblx0XHRcdGlmICghY29uZmlnLngpXG5cdFx0XHRcdGNvbmZpZy54ID0gMDtcblx0XHRcdGlmICghY29uZmlnLnkpXG5cdFx0XHRcdGNvbmZpZy55ID0gMDtcblx0XHRcdGlmIChjb25maWcuZml0VG9DYW52YXMgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y29uZmlnLmZpdFRvQ2FudmFzID0gdHJ1ZTtcblx0XHRcdGlmICghY29uZmlnLmJhY2tncm91bmRDb2xvcilcblx0XHRcdFx0Y29uZmlnLmJhY2tncm91bmRDb2xvciA9IFwiIzU1NTU1NVwiO1xuXHRcdFx0aWYgKCFjb25maWcuaW1hZ2VzUGF0aCkge1xuXHRcdFx0XHRpZiAoY29uZmlnLmF0bGFzKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gY29uZmlnLmF0bGFzLmxhc3RJbmRleE9mKFwiL1wiKTtcblx0XHRcdFx0XHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHRcdFx0XHRcdGNvbmZpZy5pbWFnZXNQYXRoID0gY29uZmlnLmF0bGFzLnN1YnN0cigwLCBpbmRleCkgKyBcIi9cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25maWcuaW1hZ2VzUGF0aCA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbmZpZy5pbWFnZXNQYXRoID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5qc29uICYmIGNvbmZpZy5qc29uLmxhc3RJbmRleE9mKGNvbmZpZy5pbWFnZXNQYXRoKSA9PSAwKSB7XG5cdFx0XHRcdGNvbmZpZy5qc29uID0gY29uZmlnLmpzb24uc3Vic3RyKGNvbmZpZy5pbWFnZXNQYXRoLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLmF0bGFzICYmIGNvbmZpZy5hdGxhcy5sYXN0SW5kZXhPZihjb25maWcuaW1hZ2VzUGF0aCkgPT0gMCkge1xuXHRcdFx0XHRjb25maWcuYXRsYXMgPSBjb25maWcuYXRsYXMuc3Vic3RyKGNvbmZpZy5pbWFnZXNQYXRoLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbmZpZy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y29uZmlnLnByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlO1xuXHRcdFx0aWYgKCFjb25maWcuZGVidWcgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y29uZmlnLmRlYnVnID0gZmFsc2U7XG5cdFx0XHRpZiAoIWNvbmZpZy5hbHBoYSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRjb25maWcuYWxwaGEgPSB0cnVlO1xuXHRcdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3Iuc2V0RnJvbVN0cmluZyhjb25maWcuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xuXHRcdH07XG5cdFx0U3BpbmVXaWRnZXQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dmFyIGFzc2V0TWFuYWdlciA9IHRoaXMuYXNzZXRNYW5hZ2VyO1xuXHRcdFx0dmFyIGltYWdlc1BhdGggPSB0aGlzLmNvbmZpZy5pbWFnZXNQYXRoO1xuXHRcdFx0dmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHRcdFx0aWYgKGFzc2V0TWFuYWdlci5pc0xvYWRpbmdDb21wbGV0ZSgpKSB7XG5cdFx0XHRcdGlmIChhc3NldE1hbmFnZXIuaGFzRXJyb3JzKCkpIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmVycm9yKVxuXHRcdFx0XHRcdFx0Y29uZmlnLmVycm9yKHRoaXMsIFwiRmFpbGVkIHRvIGxvYWQgYXNzZXRzOiBcIiArIEpTT04uc3RyaW5naWZ5KGFzc2V0TWFuYWdlci5nZXRFcnJvcnMoKSkpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGFzc2V0czogXCIgKyBKU09OLnN0cmluZ2lmeShhc3NldE1hbmFnZXIuZ2V0RXJyb3JzKCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYXRsYXNDb250ZW50ID0gY29uZmlnLmF0bGFzQ29udGVudCA9PT0gdW5kZWZpbmVkID8gdGhpcy5hc3NldE1hbmFnZXIuZ2V0KHRoaXMuY29uZmlnLmF0bGFzKSA6IGNvbmZpZy5hdGxhc0NvbnRlbnQ7XG5cdFx0XHRcdHZhciBhdGxhcyA9IG5ldyBzcGluZS5UZXh0dXJlQXRsYXMoYXRsYXNDb250ZW50LCBmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gYXNzZXRNYW5hZ2VyLmdldChwYXRoKTtcblx0XHRcdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHZhciBhdGxhc0xvYWRlciA9IG5ldyBzcGluZS5BdGxhc0F0dGFjaG1lbnRMb2FkZXIoYXRsYXMpO1xuXHRcdFx0XHR2YXIgc2tlbGV0b25Kc29uID0gbmV3IHNwaW5lLlNrZWxldG9uSnNvbihhdGxhc0xvYWRlcik7XG5cdFx0XHRcdHNrZWxldG9uSnNvbi5zY2FsZSA9IGNvbmZpZy5zY2FsZTtcblx0XHRcdFx0dmFyIGpzb25Db250ZW50ID0gY29uZmlnLmpzb25Db250ZW50ID09PSB1bmRlZmluZWQgPyBhc3NldE1hbmFnZXIuZ2V0KGNvbmZpZy5qc29uKSA6IGNvbmZpZy5qc29uQ29udGVudDtcblx0XHRcdFx0dmFyIHNrZWxldG9uRGF0YSA9IHNrZWxldG9uSnNvbi5yZWFkU2tlbGV0b25EYXRhKGpzb25Db250ZW50KTtcblx0XHRcdFx0dmFyIHNrZWxldG9uID0gdGhpcy5za2VsZXRvbiA9IG5ldyBzcGluZS5Ta2VsZXRvbihza2VsZXRvbkRhdGEpO1xuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5ib3VuZHM7XG5cdFx0XHRcdHNrZWxldG9uLnNldFNraW5CeU5hbWUoY29uZmlnLnNraW4pO1xuXHRcdFx0XHRza2VsZXRvbi5zZXRUb1NldHVwUG9zZSgpO1xuXHRcdFx0XHRza2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xuXHRcdFx0XHRza2VsZXRvbi5nZXRCb3VuZHMoYm91bmRzLm9mZnNldCwgYm91bmRzLnNpemUsIFtdKTtcblx0XHRcdFx0aWYgKCFjb25maWcuZml0VG9DYW52YXMpIHtcblx0XHRcdFx0XHRza2VsZXRvbi54ID0gY29uZmlnLng7XG5cdFx0XHRcdFx0c2tlbGV0b24ueSA9IGNvbmZpZy55O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhbmltYXRpb25TdGF0ZSA9IHRoaXMuc3RhdGUgPSBuZXcgc3BpbmUuQW5pbWF0aW9uU3RhdGUobmV3IHNwaW5lLkFuaW1hdGlvblN0YXRlRGF0YShza2VsZXRvbi5kYXRhKSk7XG5cdFx0XHRcdGFuaW1hdGlvblN0YXRlLnNldEFuaW1hdGlvbigwLCBjb25maWcuYW5pbWF0aW9uLCBjb25maWcubG9vcCk7XG5cdFx0XHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGNvbmZpZy5zdWNjZXNzKVxuXHRcdFx0XHRcdGNvbmZpZy5zdWNjZXNzKHRoaXMpO1xuXHRcdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyBfdGhpcy5yZW5kZXIoKTsgfSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IF90aGlzLmxvYWQoKTsgfSk7XG5cdFx0fTtcblx0XHRTcGluZVdpZGdldC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcblx0XHRcdHZhciBkZWx0YSA9IG5vdyAtIHRoaXMubGFzdEZyYW1lVGltZTtcblx0XHRcdGlmIChkZWx0YSA+IDAuMSlcblx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0dGhpcy5sYXN0RnJhbWVUaW1lID0gbm93O1xuXHRcdFx0dmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXHRcdFx0dmFyIGNvbG9yID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHR0aGlzLnJlc2l6ZSgpO1xuXHRcdFx0Z2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcblx0XHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXHRcdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHRcdHZhciBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XG5cdFx0XHR2YXIgcHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5jb25maWcucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdFx0c3RhdGUudXBkYXRlKGRlbHRhKTtcblx0XHRcdHN0YXRlLmFwcGx5KHNrZWxldG9uKTtcblx0XHRcdHNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XG5cdFx0XHR2YXIgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG5cdFx0XHR2YXIgYmF0Y2hlciA9IHRoaXMuYmF0Y2hlcjtcblx0XHRcdHZhciBza2VsZXRvblJlbmRlcmVyID0gdGhpcy5za2VsZXRvblJlbmRlcmVyO1xuXHRcdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtaShzcGluZS53ZWJnbC5TaGFkZXIuU0FNUExFUiwgMCk7XG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybTR4NGYoc3BpbmUud2ViZ2wuU2hhZGVyLk1WUF9NQVRSSVgsIHRoaXMubXZwLnZhbHVlcyk7XG5cdFx0XHRiYXRjaGVyLmJlZ2luKHNoYWRlcik7XG5cdFx0XHRza2VsZXRvblJlbmRlcmVyLnByZW11bHRpcGxpZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdHNrZWxldG9uUmVuZGVyZXIuZHJhdyhiYXRjaGVyLCBza2VsZXRvbik7XG5cdFx0XHRiYXRjaGVyLmVuZCgpO1xuXHRcdFx0c2hhZGVyLnVuYmluZCgpO1xuXHRcdFx0aWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG5cdFx0XHRcdHZhciBzaGFkZXJfMSA9IHRoaXMuZGVidWdTaGFkZXI7XG5cdFx0XHRcdHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcztcblx0XHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5kZWJ1Z1JlbmRlcmVyO1xuXHRcdFx0XHRzaGFkZXJfMS5iaW5kKCk7XG5cdFx0XHRcdHNoYWRlcl8xLnNldFVuaWZvcm00eDRmKHNwaW5lLndlYmdsLlNoYWRlci5NVlBfTUFUUklYLCB0aGlzLm12cC52YWx1ZXMpO1xuXHRcdFx0XHRyZW5kZXJlci5wcmVtdWx0aXBsaWVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XG5cdFx0XHRcdHNoYXBlcy5iZWdpbihzaGFkZXJfMSk7XG5cdFx0XHRcdHJlbmRlcmVyLmRyYXcoc2hhcGVzLCBza2VsZXRvbik7XG5cdFx0XHRcdHNoYXBlcy5lbmQoKTtcblx0XHRcdFx0c2hhZGVyXzEudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMucGF1c2VkKVxuXHRcdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyBfdGhpcy5yZW5kZXIoKTsgfSk7XG5cdFx0fTtcblx0XHRTcGluZVdpZGdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXHRcdFx0dmFyIHcgPSBjYW52YXMuY2xpZW50V2lkdGg7XG5cdFx0XHR2YXIgaCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5ib3VuZHM7XG5cdFx0XHR2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0XHRpZiAoY2FudmFzLndpZHRoICE9IE1hdGguZmxvb3IodyAqIGRldmljZVBpeGVsUmF0aW8pIHx8IGNhbnZhcy5oZWlnaHQgIT0gTWF0aC5mbG9vcihoICogZGV2aWNlUGl4ZWxSYXRpbykpIHtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3ICogZGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGggKiBkZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmNvbmZpZy5maXRUb0NhbnZhcykge1xuXHRcdFx0XHR2YXIgY2VudGVyWCA9IGJvdW5kcy5vZmZzZXQueCArIGJvdW5kcy5zaXplLnggLyAyO1xuXHRcdFx0XHR2YXIgY2VudGVyWSA9IGJvdW5kcy5vZmZzZXQueSArIGJvdW5kcy5zaXplLnkgLyAyO1xuXHRcdFx0XHR2YXIgc2NhbGVYID0gYm91bmRzLnNpemUueCAvIHc7XG5cdFx0XHRcdHZhciBzY2FsZVkgPSBib3VuZHMuc2l6ZS55IC8gaDtcblx0XHRcdFx0dmFyIHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpICogMS4yO1xuXHRcdFx0XHRpZiAoc2NhbGUgPCAxKVxuXHRcdFx0XHRcdHNjYWxlID0gMTtcblx0XHRcdFx0dmFyIHdpZHRoID0gdyAqIHNjYWxlO1xuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gaCAqIHNjYWxlO1xuXHRcdFx0XHR0aGlzLnNrZWxldG9uLnggPSB0aGlzLnNrZWxldG9uLnkgPSAwO1xuXHRcdFx0XHR0aGlzLm12cC5vcnRobzJkKGNlbnRlclggLSB3aWR0aCAvIDIsIGNlbnRlclkgLSBoZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLm12cC5vcnRobzJkKDAsIDAsIHcgLSAxLCBoIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmNvbnRleHQuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyBfdGhpcy5yZW5kZXIoKTsgfSk7XG5cdFx0fTtcblx0XHRTcGluZVdpZGdldC5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLnBhdXNlZDtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnByb3RvdHlwZS5zZXRBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uU3RhdGVMaXN0ZW5lcikge1xuXHRcdFx0aWYgKGFuaW1hdGlvblN0YXRlTGlzdGVuZXIgPT09IHZvaWQgMCkgeyBhbmltYXRpb25TdGF0ZUxpc3RlbmVyID0gbnVsbDsgfVxuXHRcdFx0aWYgKCF0aGlzLmxvYWRlZClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiV2lkZ2V0IGlzbid0IGxvYWRlZCB5ZXRcIik7XG5cdFx0XHR0aGlzLnNrZWxldG9uLnNldFRvU2V0dXBQb3NlKCk7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLnN0YXRlLnNldEFuaW1hdGlvbigwLCBhbmltYXRpb25OYW1lLCB0aGlzLmNvbmZpZy5sb29wKTtcblx0XHRcdGVudHJ5Lmxpc3RlbmVyID0gYW5pbWF0aW9uU3RhdGVMaXN0ZW5lcjtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LmxvYWRXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdpZGdldHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic3BpbmUtd2lkZ2V0XCIpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFNwaW5lV2lkZ2V0LmxvYWRXaWRnZXQod2lkZ2V0c1tpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRTcGluZVdpZGdldC5sb2FkV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuXHRcdFx0dmFyIGNvbmZpZyA9IG5ldyBTcGluZVdpZGdldENvbmZpZygpO1xuXHRcdFx0Y29uZmlnLmF0bGFzID0gd2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYXRsYXNcIik7XG5cdFx0XHRjb25maWcuanNvbiA9IHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWpzb25cIik7XG5cdFx0XHRjb25maWcuYW5pbWF0aW9uID0gd2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYW5pbWF0aW9uXCIpO1xuXHRcdFx0aWYgKHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWltYWdlcy1wYXRoXCIpKVxuXHRcdFx0XHRjb25maWcuaW1hZ2VzUGF0aCA9IHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWltYWdlcy1wYXRoXCIpO1xuXHRcdFx0aWYgKHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0bGFzLXBhZ2VzXCIpKVxuXHRcdFx0XHRjb25maWcuYXRsYXNQYWdlcyA9IHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0bGFzLXBhZ2VzXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1za2luXCIpKVxuXHRcdFx0XHRjb25maWcuc2tpbiA9IHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNraW5cIik7XG5cdFx0XHRpZiAod2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtbG9vcFwiKSlcblx0XHRcdFx0Y29uZmlnLmxvb3AgPSB3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1sb29wXCIpID09PSBcInRydWVcIjtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zY2FsZVwiKSlcblx0XHRcdFx0Y29uZmlnLnNjYWxlID0gcGFyc2VGbG9hdCh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zY2FsZVwiKSk7XG5cdFx0XHRpZiAod2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEteFwiKSlcblx0XHRcdFx0Y29uZmlnLnggPSBwYXJzZUZsb2F0KHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXhcIikpO1xuXHRcdFx0aWYgKHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXlcIikpXG5cdFx0XHRcdGNvbmZpZy55ID0gcGFyc2VGbG9hdCh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS15XCIpKTtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1maXQtdG8tY2FudmFzXCIpKVxuXHRcdFx0XHRjb25maWcuZml0VG9DYW52YXMgPSB3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1maXQtdG8tY2FudmFzXCIpID09PSBcInRydWVcIjtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCIpKVxuXHRcdFx0XHRjb25maWcuYmFja2dyb3VuZENvbG9yID0gd2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKTtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVtdWx0aXBsaWVkLWFscGhhXCIpKVxuXHRcdFx0XHRjb25maWcucHJlbXVsdGlwbGllZEFscGhhID0gd2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcHJlbXVsdGlwbGllZC1hbHBoYVwiKSA9PT0gXCJ0cnVlXCI7XG5cdFx0XHRpZiAod2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWdcIikpXG5cdFx0XHRcdGNvbmZpZy5kZWJ1ZyA9IHdpZGdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnXCIpID09PSBcInRydWVcIjtcblx0XHRcdGlmICh3aWRnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hbHBoYVwiKSlcblx0XHRcdFx0Y29uZmlnLmFscGhhID0gd2lkZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYWxwaGFcIikgPT09IFwidHJ1ZVwiO1xuXHRcdFx0bmV3IHNwaW5lLlNwaW5lV2lkZ2V0KHdpZGdldCwgY29uZmlnKTtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnJlYWR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKFNwaW5lV2lkZ2V0LnBhZ2VMb2FkZWQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFNwaW5lV2lkZ2V0LnBhZ2VMb2FkZWQgPSB0cnVlO1xuXHRcdFx0U3BpbmVXaWRnZXQubG9hZFdpZGdldHMoKTtcblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnNldHVwRE9NTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBTcGluZVdpZGdldC5yZWFkeSwgZmFsc2UpO1xuXHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgU3BpbmVXaWRnZXQucmVhZHksIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBmdW5jdGlvbiByZWFkeVN0YXRlQ2hhbmdlKCkge1xuXHRcdFx0XHRcdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpXG5cdFx0XHRcdFx0XHRTcGluZVdpZGdldC5yZWFkeSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsIFNwaW5lV2lkZ2V0LnJlYWR5KTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFNwaW5lV2lkZ2V0LnBhZ2VMb2FkZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gU3BpbmVXaWRnZXQ7XG5cdH0oKSk7XG5cdHNwaW5lLlNwaW5lV2lkZ2V0ID0gU3BpbmVXaWRnZXQ7XG5cdHZhciBTcGluZVdpZGdldENvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gU3BpbmVXaWRnZXRDb25maWcoKSB7XG5cdFx0XHR0aGlzLnNraW4gPSBcImRlZmF1bHRcIjtcblx0XHRcdHRoaXMubG9vcCA9IHRydWU7XG5cdFx0XHR0aGlzLnNjYWxlID0gMS4wO1xuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLmFscGhhID0gdHJ1ZTtcblx0XHRcdHRoaXMuZml0VG9DYW52YXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBcIiM1NTU1NTVcIjtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRlYnVnID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBTcGluZVdpZGdldENvbmZpZztcblx0fSgpKTtcblx0c3BpbmUuU3BpbmVXaWRnZXRDb25maWcgPSBTcGluZVdpZGdldENvbmZpZztcbn0pKHNwaW5lIHx8IChzcGluZSA9IHt9KSk7XG5zcGluZS5TcGluZVdpZGdldC5zZXR1cERPTUxpc3RlbmVyKCk7XG5leHBvcnQgZGVmYXVsdCBzcGluZTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHNwaW5lIGZyb20gXCIuL3NwaW5lX3J1bnRpbWUvc3BpbmUtd2lkZ2V0XCI7XG5pbXBvcnQgeyBTa2VsZXRvbkJpbmFyeSB9IGZyb20gXCIuL3NwaW5lX3J1bnRpbWUvU2tlbGV0b25CaW5hcnkzLjUuanNcIjtcbmZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFNrZWxldG9uQmluYXJ5KCk7XG4gIHBhcnNlci5kYXRhID0gZGF0YTtcbiAgcGFyc2VyLmluaXRKc29uKCk7XG4gIHJldHVybiBwYXJzZXIuanNvbjtcbn1cbmZ1bmN0aW9uIGxvYWRTa2VsKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgeGhyLm9ubG9hZGVuZCA9IChlKSA9PiB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICByZXMocGFyc2UobmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqKHhoci5zdGF0dXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKFxuICBkb20sXG4gIHtcbiAgICBhdGxhc1BhdGgsXG4gICAgYXRsYXNQYWdlcyxcbiAgICBza2VsUGF0aCxcbiAgICBhbmksXG4gICAgYmFja2dyb3VuZENvbG9yID0gXCIjZmZmZmZmXCIsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBsb29wID0gdHJ1ZSxcbiAgICBza2luLFxuICAgIHNjYWxlLFxuICAgIHggPSA1MDAsXG4gICAgeSA9IDIwMCxcbiAgICBmaXRUb0NhbnZhcyA9IGZhbHNlLFxuICAgIG9uU3VjY2VzcyxcbiAgICBvblNrZWxMb2FkZWQsXG4gIH1cbikge1xuICBsb2FkU2tlbChza2VsUGF0aCkudGhlbihmdW5jdGlvbiAoanNvbikge1xuICAgIGlmIChvblNrZWxMb2FkZWQpIHtcbiAgICAgIG9uU2tlbExvYWRlZChqc29uKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhqc29uKTtcbiAgICB9XG4gICAgbmV3IHNwaW5lLlNwaW5lV2lkZ2V0KGRvbSwge1xuICAgICAganNvbkNvbnRlbnQ6IGpzb24sXG4gICAgICBhdGxhczogYXRsYXNQYXRoLFxuICAgICAgYXRsYXNQYWdlcyxcbiAgICAgIGFuaW1hdGlvbjogYW5pLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wLFxuICAgICAgc2tpbixcbiAgICAgIHNjYWxlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmaXRUb0NhbnZhcyxcbiAgICAgIHN1Y2Nlc3M6IG9uU3VjY2VzcyxcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9
